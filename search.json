[{"path":"/articles/ArtOfAlignmentInR.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The Art of Multiple Sequence Alignment in R","text":"document intended illustrate art multiple sequence alignment using DECIPHER. Even though beauty often concealed, multiple sequence alignment form art ways one. Take look Figure @ref(f1) illustration happening behind scenes multiple sequence alignment. practice sequence alignment one requires degree skill, art vignette intends convey. simply enough “plug” sequences multiple sequence aligner blindly trust result. appreciation art well careful consideration results required. really multiple sequence alignment, single correct alignment? Generally speaking, alignment seeks perform act taking multiple divergent biological sequences “type” fitting form reflects shared quality. quality may look structurally, evolved common ancestor, optimization mathematical construct. multiple sequence aligners, DECIPHER “trained” maximize scoring metrics order accomplish combination structural alignment evolutionary alignment. idea give alignment biological basis even though molecules sequences represent never meet align natural circumstance. workhorse sequence alignment DECIPHER AlignProfiles, takes two aligned sets DNA, RNA, amino acid (AA) sequences returns merged alignment. two sequences, function AlignSeqs can used perform multiple sequence alignment progressive/iterative manner sequences kind. case, multiple alignment works aligning two sequences, merging another sequence, merging another set sequences, -forth sequences aligned. process iterated refine alignment. functions extend use AlignSeqs different purposes: first AlignTranslation, align DNA/RNA sequences based amino acid translation reverse translate back DNA/RNA. Aligning protein sequences accurate since amino acids conserved corresponding coding sequence. second function, AlignDB, enables generating alignments many sequences possible fit memory. main purpose merge sub-alignments alignment alone composed many thousands sequences. accomplished storing aligned sequences database working “profiles” representing alignment. function AdjustAlignment takes existing alignment shifts groups gaps right left achieve better alignment. purpose eliminate artifacts accumulate progressive alignment, replace tedious & subjective process manually correcting alignment. Finally, StaggerAlignment create “staggered” alignment separating potentially non-homologous positions separate columns. function help minimize false homologies building phylogenetic tree, although resulting alignment aesthetically pleasing. functions FindSynteny AlignSynteny can used combination perform pairwise alignment homologous regions multiple genomes non-collinear sequences. functions interact sequence database containing genomes, can comprised multiple sequences (.e., scaffolds, contigs, chromosomes).","code":""},{"path":"/articles/ArtOfAlignmentInR.html","id":"alignment-speed","dir":"Articles","previous_headings":"","what":"Alignment Speed","title":"The Art of Multiple Sequence Alignment in R","text":"dynamic programming method used DECIPHER aligning two profiles requires order N*M time memory space N M width pattern subject. Since multiple sequence alignment inherently challenging problem long sequences, heuristics employed maximize speed maintaining reasonable accuracy. regard, two control parameters available user restrict anchor. objective restrict parameter convert problem one taking quadratic time linear time. goal anchor parameter equivalent memory space long sequences can efficiently aligned. orange diagonal line Figure @ref(f2) shows optimal path aligning two sequence profiles. blue segments left right optimal path give constraint boundaries, user controls restrict parameter. Areas upper lower (respectively) constraint boundaries neglected consideration. higher (less negative) value restrict[1] constrain possible “alignment space,” represents possible alignments two sequences. Since optimal path known till completion matrix, risky overly constrain matrix. particularly true situations sequences mostly overlapping optimal path likely diagonal, causing path cross constraint boundary. non-overlapping case restrict[1] set default ensure entire “alignment space” available. Neglecting “corners” alignment space effectively converts quadratic time problem near-linear time problem. can see comparing AlignProfiles without restricting matrix different sequence lengths. extend comparison can include Biostrings function pairwiseAlignment. simulation, two sequences 90% identity aligned elapsed time recorded variety sequence lengths. can seen Figure @ref(f3) , without restriction AlignProfiles takes quadratic time manner pairwiseAlignment. However, restriction AlignProfiles takes linear time, requiring far less microsecond per nucleotide. parameter anchor controls fraction sequences must share common region anchor alignment space (Fig. @ref(f2)). AlignProfiles search shared anchor points two sequence sets aligned, fraction shared anchor (70% default) position fixed “alignment space.” Anchors 15-mer (DNA/RNA) 7-mer (AA) exact matches two sequences must occur order sequence profiles. Anchoring generally affect accuracy, can greatly diminish amount memory required alignment. Fig. @ref(f2), largest white box represents maximal memory space required anchoring, entire alignment space (grey plus white areas) required without anchoring. longest pair sequence profiles can aligned without anchoring 46 thousand nucleotides, shown end red dotted line Figure @ref(f3). regularly spaced anchor points available maximum sequence length greatly extended. vast majority cases anchoring gives result without anchoring, less time memory space required.","code":""},{"path":"/articles/ArtOfAlignmentInR.html","id":"alignment-accuracy","dir":"Articles","previous_headings":"","what":"Alignment Accuracy","title":"The Art of Multiple Sequence Alignment in R","text":"Figure @ref(f4) compares performance DECIPHER sequence alignment software structural amino acid benchmarks [@Edgar:2010]. benchmarks flaws, can easily found eye highly similar sequence sets, therefore benchmark results treated care [@Iantorno:2014]. can seen figure, performance DECIPHER similar popular alignment software MAFFT [@Katoh:2002] MUSCLE [@Edgar:2004] smaller benchmarks. However, DECIPHER outperforms programs large sequence sets (Fig. @ref(f5)), relative advantage continues increase sequences aligned [@Wright:2015]. Importantly, DECIPHER exhibits far less fall-accuracy additional sequences added. accuracy protein alignment begins drop-sequences reference alignment less 40% average pairwise identity (Fig. @ref(f4)). similar decline performance observed DNA/RNA sequences, drop-occurs much earlier around 60% sequence identity. Therefore, generally preferable align coding sequences translation using AlignTranslation. function first translates input DNA/RNA sequences, aligns translation, finally (conceptually) reverse translates amino acid sequences obtain aligned DNA/RNA sequences. Nevertheless, even protein alignment considered reliable sequences aligned differ 70%.","code":""},{"path":"/articles/ArtOfAlignmentInR.html","id":"recommendations-for-optimal-performance","dir":"Articles","previous_headings":"","what":"Recommendations for optimal performance","title":"The Art of Multiple Sequence Alignment in R","text":"DECIPHER number alignment functions associated parameters. flow-chart Figure @ref(f6) intended simplify process frequently encountered multiple sequence alignment tasks. information suggestions, refer examples following sections vignette.","code":""},{"path":[]},{"path":"/articles/ArtOfAlignmentInR.html","id":"example-protein-coding-sequences","dir":"Articles","previous_headings":"Single Gene Alignment","what":"Example: Protein coding sequences","title":"The Art of Multiple Sequence Alignment in R","text":"example going align rplB coding sequence many different Bacteria. rplB gene encodes one primary ribosomal RNA binding proteins: 50S ribosomal protein L2. begin loading library importing sequences FASTA file. sure change path names system replacing text inside quotes labeled “\\(<<\\)path …\\(>>\\)” actual path system. can align DNA either aligning coding sequences directly, translations (amino acid sequences). methods result aligned set DNA sequences, unless argument type \"AAStringSet\" AlignTranslation. quick inspection reveals method translating alignment yields appealing result. particular, reading frame maintained aligning translations. However, dna code protein option use AlignSeqs translation meaningless. Note frameshift errors can greatly disrupt alignment protein coding sequences. Frameshifts can corrected first using CorrectFrameshifts nucleotide sequences, using corrected sequences input AlignTranslation argument readingFrame equal 1. input sequences include exact replicates, alignment can accelerated de-replicating sequences alignment. sequences can re-replicated alignment create larger alignment original sequences. AlignSeqs automatically handle redundancy input sequences, fairly straightforward. case aren’t exact duplicates example dna sequences. Nonetheless, process de-replicate alignment re-replicate alignment look like: Also, aligning nucleotide sequences (translations), may case sequences different orientations. , consider reorienting sequences directionality complementarity using OrientNucleotides prior alignment.","code":"library(DECIPHER)  # specify the path to your sequence file: fas <- \"<<path to FASTA file>>\" # OR find the example sequence file used in this tutorial: fas <- system.file(\"extdata\", \"50S_ribosomal_protein_L2.fas\", package=\"DECIPHER\")  dna <- readDNAStringSet(fas) dna # the unaligned sequences ## DNAStringSet object of length 317: ##       width seq                                             names                ##   [1]   819 ATGGCTTTAAAAAATTTTAATC...ATTTATTGTAAAAAAAAGAAAA Rickettsia prowaz... ##   [2]   822 ATGGGAATACGTAAACTCAAGC...CATCATTGAGAGAAGGAAAAAG Porphyromonas gin... ##   [3]   822 ATGGGAATACGTAAACTCAAGC...CATCATTGAGAGAAGGAAAAAG Porphyromonas gin... ##   [4]   822 ATGGGAATACGTAAACTCAAGC...CATCATTGAGAGAAGGAAAAAG Porphyromonas gin... ##   [5]   819 ATGGCTATCGTTAAATGTAAGC...CATCGTACGTCGTCGTGGTAAA Pasteurella multo... ##   ...   ... ... ## [313]   819 ATGGCAATTGTTAAATGTAAAC...TATCGTACGTCGCCGTACTAAA Pectobacterium at... ## [314]   822 ATGCCTATTCAAAAATGCAAAC...TATTCGCGATCGTCGCGTCAAG Acinetobacter sp.... ## [315]   864 ATGGGCATTCGCGTTTACCGAC...GGGTCGCGGTGGTCGTCAGTCT Thermosynechococc... ## [316]   831 ATGGCACTGAAGACATTCAATC...AAGCCGCCACAAGCGGAAGAAG Bradyrhizobium ja... ## [317]   840 ATGGGCATTCGCAAATATCGAC...CAAGACGGCTTCCGGGCGAGGT Gloeobacter viola... AA <- AlignTranslation(dna, type=\"AAStringSet\") # align the translation BrowseSeqs(AA, highlight=1) # view the alignment  DNA <- AlignSeqs(dna) # align the sequences directly without translation DNA <- AlignTranslation(dna) # align the translation then reverse translate  # write the aligned sequences to a FASTA file writeXStringSet(DNA, file=\"<<path to output file>>\") u_dna <- unique(dna) # the unique input sequences index <- match(dna, u_dna) # de-replication index  U_DNA <- AlignSeqs(u_dna) # align the sequences directly without translation DNA <- U_DNA[index] names(DNA) <- names(dna) # the re-replicated alignment"},{"path":"/articles/ArtOfAlignmentInR.html","id":"example-non-coding-rna-sequences","dir":"Articles","previous_headings":"Single Gene Alignment","what":"Example: Non-coding RNA sequences","title":"The Art of Multiple Sequence Alignment in R","text":"Much like proteins, non-coding RNAs often conserved secondary structure can used improve alignment. PredictDBN function predict base pairings sequence alignment calculating mutual information pairs positions. RNA sequences given input, AlignSeqs automatically use output PredictDBN iteratively improve alignment. Providing RNAStringSet also causes single-base double-base substitution matrices used, preferable providing DNAStringSet sequences non-coding RNA. type input sequences can easily converted RNA, shown .","code":"# database containing 16S ribosomal RNA sequences db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\")  rna <- SearchDB(db, remove=\"all\", type=\"RNAStringSet\") # or if starting with DNA sequences, convert to RNA with: # rna <- RNAStringSet(dna) # or import RNA sequences directly using: # rna <- readRNAStringSet(\"<<path to FASTA file>>\")  alignedRNA <- AlignSeqs(rna) # align with RNA secondary structure"},{"path":"/articles/ArtOfAlignmentInR.html","id":"example-aligning-two-aligned-sequence-sets","dir":"Articles","previous_headings":"Single Gene Alignment","what":"Example: Aligning two aligned sequence sets","title":"The Art of Multiple Sequence Alignment in R","text":"sometimes useful align two previously-aligned sets sequences. can use function AlignProfiles directly align profiles two sequence sets: two sequence sets large may impossible fit sets input sequences output alignment memory . function AlignDB can align sequences two database tables, two sets sequences corresponding separate identifiers table. AlignDB takes input two tblNames /identifiers, iteratively builds profile respective sequence alignments database. profiles aligned, insertions iteratively applied input sequences completed alignment stored add2tbl. number sequences required fit memory aligning two sequence sets AlignDB controlled batchSize parameter. way AlignDB can used align large sequence alignments minimal memory required.","code":"half <- floor(length(dna)/2) dna1 <- dna[1:half] # first half dna2 <- dna[(half + 1):length(dna)] # second half  AA1 <- AlignTranslation(dna1, type=\"AAStringSet\") AA2 <- AlignTranslation(dna2, type=\"AAStringSet\") AA <- AlignProfiles(AA1, AA2) # align two alignments # Align DNA sequences stored in separate tables: dbConn <- dbConnect(SQLite(), \":memory:\") Seqs2DB(AA1, \"DNAStringSet\", dbConn, \"AA1\", tblName=\"AA1\") Seqs2DB(AA2, \"DNAStringSet\", dbConn, \"AA2\", tblName=\"AA2\") AlignDB(dbConn, tblName=c(\"AA1\", \"AA2\"), add2tbl=\"AA\",         type=\"AAStringSet\") AA <- SearchDB(dbConn, tblName=\"AA\", type=\"AAStringSet\") BrowseDB(dbConn, tblName=\"AA\") dbDisconnect(dbConn)"},{"path":[]},{"path":"/articles/ArtOfAlignmentInR.html","id":"example-building-a-guide-tree","dir":"Articles","previous_headings":"Advanced Options & Features","what":"Example: Building a Guide Tree","title":"The Art of Multiple Sequence Alignment in R","text":"AlignSeqs function uses guide tree decide order align pairs sequence profiles. guideTree input dendrogram (tree) object one leaf per input sequence. default guide tree generated directly input sequences using order shared k-mers (.e., argument guideTree NULL). default guide tree performs well requires \\(\\mathcal{O}(n^2)\\) time memory space construct. Therefore, may useful rely chained guide tree aligning hundreds thousands unique sequences. shown reasonably accurate alignments tens thousands sequences can obtained using chain guide tree [@Boyce:2014]. chained guide tree, sequences added one--one growing profile representing aligned sequences. Figure @ref(f7) shows result using DECIPHER align increasing numbers Cytochrome P450 sequences (accordance method reference [@Boyce:2014]), using either chained guide tree default guide tree. chained guide tree can easily generated, shown . also possible read Newick formatted tree using function ReadDendrogram, specify object input guideTree.","code":"# form a chained guide tree gT <- lapply(order(width(dna), decreasing=TRUE),     function(x) {         attr(x, \"height\") <- 0         attr(x, \"label\") <- names(dna)[x]         attr(x, \"members\") <- 1L         attr(x, \"leaf\") <- TRUE         x     }) attr(gT, \"height\") <- 0.5 attr(gT, \"members\") <- length(dna) class(gT) <- \"dendrogram\"  # use the guide tree as input for alignment DNA <- AlignTranslation(dna,     guideTree=gT,     iterations=0,     refinements=0)"},{"path":"/articles/ArtOfAlignmentInR.html","id":"example-post-processing-an-existing-multiple-alignment","dir":"Articles","previous_headings":"Advanced Options & Features","what":"Example: Post-processing an existing multiple alignment","title":"The Art of Multiple Sequence Alignment in R","text":"several steps can taken alignment verify improve alignment. important step look result ensure meets expectations. Spurious (unalignable) sequences can removed alignment process repeated desired. simplest way view sequences DECIPHER using function BrowseSeqs. highlight parameter controls sequence, , focus (highlighted). value zero highlights consensus sequence shown . DECIPHER multiple sequence alignments optimized using AdjustAlignment (unless input argument FUN changed), goal removing artifacts progressive alignment process. function efficiently correct obvious inaccuracies found -eye. Therefore, making manual corrections recommended unless additional expert knowledge sequences available. advantage using AdjustAlignment repeatable process subjective, unlike manual adjustments. order refine existing alignment, AdjustAlignment can called directly. common use alignment preliminary step creation phylogenetic tree. DECIPHER, like majority alignment programs, attempts maximize homologous positions sequences aligned. alignment particularly useful investigating residues structural position protein. However, disparate sequence regions tend concentrated “gappy” areas alignment. viewed phylogenetic perspective homologies highly implausible insertion/deletion scenarios. mitigate problem false homologies, StaggerAlignment automatically generate staggered version existing alignment. Staggered alignments separate potentially non-homologous regions separate columns alignment. result alignment less visually appealing, likely accurate phylogenetic perspective.","code":"BrowseSeqs(DNA, highlight=0) DNA_adjusted <- AdjustAlignment(DNA) DNA_staggered <- StaggerAlignment(DNA)"},{"path":"/articles/ArtOfAlignmentInR.html","id":"aligning-homologous-regions-of-multiple-genomes","dir":"Articles","previous_headings":"","what":"Aligning Homologous Regions of Multiple Genomes","title":"The Art of Multiple Sequence Alignment in R","text":"functions described far required collinear sequences input. requirement frequently broken genomes, may include many sequence rearrangements inversion, duplication, reordering. FindSynteny find homologous regions pairs genomes, can aligned using AlignSynteny. database sequences identified genome name used input functions. enables alignment genomes composed many contigs, long share identifier database. example uses database containing five Influenza virus genomes, composed eight separate segments. output list, list component containing DNAStringSetList pairwise alignments two genomes. Names output correspond sequence’s identifier database, index syntenic block. also possible display blocks synteny pairs genomes. Figure @ref(f8) shows different genome segments (.e., sequences) separated thin horizontal vertical lines. syntenic blocks diagonal lines composed many homologous “hits” genomes.  {#f8} Dot plots showing homologous regions among five Influenza virus genomes.","code":"db <- system.file(\"extdata\", \"Influenza.sqlite\", package=\"DECIPHER\") synteny <- FindSynteny(db, verbose=FALSE) synteny # an object of class `Synteny` ##          H9N2     H5N1     H2N2     H7N9     H1N1 ## H9N2   8 seqs 74% hits 78% hits 76% hits 73% hits ## H5N1 8 blocks   8 seqs 70% hits 74% hits 84% hits ## H2N2 8 blocks 8 blocks   8 seqs 73% hits 71% hits ## H7N9 8 blocks 8 blocks 8 blocks   8 seqs 74% hits ## H1N1 8 blocks 8 blocks 8 blocks 8 blocks   8 seqs InfluenzaA <- AlignSynteny(synteny, db, verbose=FALSE) unlist(InfluenzaA[[1]]) ## DNAStringSet object of length 16: ##      width seq                                              names                ##  [1]  2328 GCAAAAGCAGGCAAACCATTTGA...CTTGTCCTTCATGAAAAAATGC 1.H9N2 ##  [2]  2328 GCAAAAGCAGGCAAACCATTTGA...CTTGTCCTTCATGAAAAAATGC 1.H5N1 ##  [3]  2339 CAAAAGCAGGTCAATTATATTCA...TAAAAACGACCTTGTTTCTACT 2.H9N2 ##  [4]  2339 CAAAAGCAGGTCAATTATATTCA...TAAAAACGACCTTGTTTCTACT 2.H5N1 ##  [5]  2225 AAAGCAGGTACTGATCCAAAATG...GTCCAAAAAAGTACCTTGTTTC 3.H9N2 ##  ...   ... ... ## [12]   865 GTGACAAAGACATAATGGATTCC...CTTATTTAATACTAAAAAACAC 6.H5N1 ## [13]  1453 GAATGGTCCTACATCGTCGAAAG...TCTGGGCCATGTCCAATGGATC 7.H9N2 ## [14]  1453 GAATGGTCTTACATAGTGGAGAA...TATGGATGTGCTCCAATGGATC 7.H5N1 ## [15]  1317 ATGAATCCAAATCAAAAGATAAT...GGAGTTGATAAGAGGGAGACCA 8.H9N2 ## [16]  1317 ATGAATCCAAATCAGAAGATAAT...TGAGCTAATCAGAGGGCGGCCC 8.H5N1 pairs(synteny, boxBlocks=TRUE) # scatterplot matrix"},{"path":"/articles/ArtOfAlignmentInR.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session Information","title":"The Art of Multiple Sequence Alignment in R","text":"output vignette produced following conditions:","code":"## R version 4.3.1 (2023-06-16) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.3 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0  ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0 ##  ## locale: ##  [1] LC_CTYPE=zh_CN.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=zh_CN.UTF-8        LC_COLLATE=zh_CN.UTF-8     ##  [5] LC_MONETARY=zh_CN.UTF-8    LC_MESSAGES=zh_CN.UTF-8    ##  [7] LC_PAPER=zh_CN.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=zh_CN.UTF-8 LC_IDENTIFICATION=C        ##  ## time zone: Asia/Shanghai ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] parallel  stats4    stats     graphics  grDevices utils     datasets  ## [8] methods   base      ##  ## other attached packages: ## [1] DECIPHER_2.29.1     RSQLite_2.3.1       Biostrings_2.68.1   ## [4] GenomeInfoDb_1.36.1 XVector_0.40.0      IRanges_2.34.1      ## [7] S4Vectors_0.38.1    BiocGenerics_0.46.0 ##  ## loaded via a namespace (and not attached): ##  [1] bit_4.0.5               jsonlite_1.8.7          highr_0.10              ##  [4] crayon_1.5.2            compiler_4.3.1          blob_1.2.4              ##  [7] stringr_1.5.0           bitops_1.0-7            jquerylib_0.1.4         ## [10] systemfonts_1.0.4       textshaping_0.3.6       yaml_2.3.7              ## [13] fastmap_1.1.1           R6_2.5.1                knitr_1.43              ## [16] desc_1.4.2              rprojroot_2.0.3         DBI_1.1.3               ## [19] GenomeInfoDbData_1.2.10 bslib_0.5.1             rlang_1.1.1             ## [22] cachem_1.0.8            stringi_1.7.12          xfun_0.40               ## [25] fs_1.6.3                sass_0.4.7              bit64_4.0.5             ## [28] memoise_2.0.1           cli_3.6.1               pkgdown_2.0.7           ## [31] magrittr_2.0.3          zlibbioc_1.46.0         digest_0.6.33           ## [34] rstudioapi_0.15.0       lifecycle_1.0.3         vctrs_0.6.3             ## [37] evaluate_0.21           glue_1.6.2              ragg_1.2.5              ## [40] RCurl_1.98-1.12         rmarkdown_2.24          purrr_1.0.2             ## [43] pkgconfig_2.0.3         tools_4.3.1             htmltools_0.5.6"},{"path":"/articles/ClassifySequences.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Classify Sequences","text":"document describes perform taxonomic classification amino acid nucleotide sequences DECIPHER package using IDTAXA algorithm. definition, taxonomy can scheme classification: organismal, functional, operational. IDTAXA algorithm split two phases: “training” phase classifier learns attributes training set, “testing” phase sequences unknown taxonomic assignments classified. objective sequence classification accurately assign taxonomic label many sequences possible, refraining labeling sequences belonging taxonomic groups represented training data. case study, tutorial focuses classifying set 16S ribosomal RNA (rRNA) gene sequences using training set 16S rRNA sequences organisms belonging known taxonomic groups. Despite focus 16S rRNA gene, IDTAXA process set sequences exist training set known taxonomic assignments testing set unknown taxonomic assignments.","code":""},{"path":[]},{"path":"/articles/ClassifySequences.html","id":"startup","dir":"Articles","previous_headings":"Getting Started","what":"Startup","title":"Classify Sequences","text":"get started need load DECIPHER package, automatically loads required packages. classification process split two parts: training carried LearnTaxa testing IdTaxa. Help either function can accessed : DECIPHER installed, code tutorial can obtained via:","code":"library(DECIPHER) ## Loading required package: Biostrings ## Loading required package: BiocGenerics ##  ## Attaching package: 'BiocGenerics' ## The following objects are masked from 'package:stats': ##  ##     IQR, mad, sd, var, xtabs ## The following objects are masked from 'package:base': ##  ##     anyDuplicated, aperm, append, as.data.frame, basename, cbind, ##     colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ##     get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply, ##     match, mget, order, paste, pmax, pmax.int, pmin, pmin.int, ##     Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort, ##     table, tapply, union, unique, unsplit, which.max, which.min ## Loading required package: S4Vectors ## Loading required package: stats4 ##  ## Attaching package: 'S4Vectors' ## The following object is masked from 'package:utils': ##  ##     findMatches ## The following objects are masked from 'package:base': ##  ##     expand.grid, I, unname ## Loading required package: IRanges ## Loading required package: XVector ## Loading required package: GenomeInfoDb ##  ## Attaching package: 'Biostrings' ## The following object is masked from 'package:base': ##  ##     strsplit ## Loading required package: RSQLite ## Loading required package: parallel > ? IdTaxa > browseVignettes(\"DECIPHER\")"},{"path":"/articles/ClassifySequences.html","id":"training-the-classifier","dir":"Articles","previous_headings":"","what":"Training the Classifier","title":"Classify Sequences","text":"training process needs occur per training set, results object can reused testing many sequences desired. already output training classifier (object class Taxa subclass Train), can skip subsection @ref(viewing) () . Otherwise follow along section learn train classifier. training process begins set sequence representatives assigned taxonomic hierarchy, called “training set”. Typically taxonomic assignments obtained authoritative source, can also automatically created (e.g., TreeLine). describe general training process, classifier iteratively learns reference taxonomy. Note training sequences ideally span full-length gene target region. test (query) sequences can partial length, training sequences expected overlap region test sequences. excess training sequence beyond region test sequence negatively effect performance unless large amount excess sequence. Also, training sequences complete taxonomy. , every training sequence classified terminal rank incomplete classification.","code":""},{"path":"/articles/ClassifySequences.html","id":"importing-the-training-set","dir":"Articles","previous_headings":"Training the Classifier","what":"Importing the training set","title":"Classify Sequences","text":"first step set filepaths sequences (FASTA format) “taxid” file containing information taxonomic ranks. “taxid” file optional, often provided (along training sequences) standard 5-column, asterisks (“*“) delimited, text format used many classifiers. create ”taxid” file, see @ref(taxid) () . sure change path names system replacing text inside quotes labeled “\\(<<\\)path …\\(>>\\)” actual path system. training sequences contain gap (“-” “.”) characters, can easily removed RemoveGaps function: Note training sequences must orientation. case, possible reorient sequences OrientNucleotides: , make assumption sequence labeled original (FASTA) file taxonomy starting “Root;”. example, sequence might labeled “AY193173 Root; Bacteria; SR1; ”, case can extract text starting “Root;” obtain sequence’s “group”. context, groups defined set possible taxonomic labels present training set.","code":"# specify the path to your file of training sequences: seqs_path <- \"<<path to training FASTA file>>\" # read the sequences into memory seqs <- readDNAStringSet(seqs_path) # Alternatively use readAAStringSet or readRNAStringSet  # (optionally) specify a path to the taxid file: rank_path <- \"<<path to taxid text file>>\" taxid <- read.table(rank_path,     header=FALSE,     col.names=c('Index', 'Name', 'Parent', 'Level', 'Rank'),     sep=\"*\", # asterisks delimited     quote=\"\", # preserve quotes     stringsAsFactors=FALSE) # OR, if no taxid text file exists, use: #taxid <- NULL # if they exist, remove any gaps in the sequences: seqs <- RemoveGaps(seqs) # ensure that all sequences are in the same orientation: seqs <- OrientNucleotides(seqs) # obtain the taxonomic assignments groups <- names(seqs) # sequence names # assume the taxonomy begins with 'Root;' groups <- gsub(\"(.*)(Root;)\", \"\\\\2\", groups) # extract the group label groupCounts <- table(groups) u_groups <- names(groupCounts) # unique groups length(u_groups) # number of groups"},{"path":"/articles/ClassifySequences.html","id":"pruning-the-training-set","dir":"Articles","previous_headings":"Training the Classifier","what":"Pruning the training set","title":"Classify Sequences","text":"next step count number representatives per group , optionally, select subset sequences group deemed large. Typically diminishing return accuracy --representative sequences group. Limiting groups size may advantageous groups contain inordinately large number sequences speed classification process. Also, larger groups oftentimes accumulate errors (, sequences belong), constraining group size can help make classification process robust rare errors may exist training data. code , maxGroupSize controls maximum size group, can set Inf (infinity) allow unlimited number sequences per group.","code":"maxGroupSize <- 10 # max sequences per label (>= 1)  remove <- logical(length(seqs)) for (i in which(groupCounts > maxGroupSize)) {     index <- which(groups==u_groups[i])     keep <- sample(length(index),         maxGroupSize)     remove[index[-keep]] <- TRUE } sum(remove) # number of sequences eliminated"},{"path":"/articles/ClassifySequences.html","id":"iteratively-training-the-classifier","dir":"Articles","previous_headings":"Training the Classifier","what":"Iteratively training the classifier","title":"Classify Sequences","text":"Now must train classifier training set. One unique feature IDTAXA algorithm learning process identify training sequences whose assigned classifications completely (high confidence) disagree predicted classification. almost always sequences mislabeled training data, can make classification process slower less accurate introduce error training data. option automatically removing putative “problem sequences” iteratively repeating training process. However, may also want careful remove sequences last remaining representatives entire group training data, can happen entire group appears misplaced taxonomic tree. two training options controlled maxIterations allowGroupRemoval variables (). Setting maxIterations 1 simply train classifier without removing problem sequences, whereas values greater 1 iteratively remove problem sequences.","code":"maxIterations <- 3 # must be >= 1 allowGroupRemoval <- FALSE  probSeqsPrev <- integer() # suspected problem sequences from prior iteration for (i in seq_len(maxIterations)) {     cat(\"Training iteration: \", i, \"\\n\", sep=\"\")          # train the classifier     trainingSet <- LearnTaxa(seqs[!remove],         names(seqs)[!remove],         taxid)          # look for problem sequences     probSeqs <- trainingSet$problemSequences$Index     if (length(probSeqs)==0) {         cat(\"No problem sequences remaining.\\n\")         break     } else if (length(probSeqs)==length(probSeqsPrev) &&         all(probSeqsPrev==probSeqs)) {         cat(\"Iterations converged.\\n\")         break     }     if (i==maxIterations)         break     probSeqsPrev <- probSeqs          # remove any problem sequences     index <- which(!remove)[probSeqs]     remove[index] <- TRUE # remove all problem sequences     if (!allowGroupRemoval) {         # replace any removed groups         missing <- !(u_groups          missing <- u_groups[missing]         if (length(missing) > 0) {             index <- index[groups[index]              remove[index] <- FALSE # don't remove         }     } } sum(remove) # total number of sequences eliminated length(probSeqs) # number of remaining problem sequences"},{"path":"/articles/ClassifySequences.html","id":"viewing-the-training-data","dir":"Articles","previous_headings":"Training the Classifier","what":"Viewing the training data","title":"Classify Sequences","text":"training process results training object (trainingSet) class Taxa subclass Train contains information required classification. want use pre-trained classifier 16S rRNA sequences, can loaded data function. However, just trained classifier using training data skip next two lines code. can view summary properties training set (trainingSet) printing : , shown Figure @ref(f1), can plot training set (trainingSet) view variety information: first panel contains taxonomic tree “Root” top. training set contains different numbers ranks group, leaves tree end different heights. Edges tree colored show putative “problem groups” persist iterative removal “problem sequences” (see ). colored edges problematic classifier descend edge tree initial “tree descent” phase algorithm. slows classification process sequences belonging group edge, affect classifier’s accuracy. second panel Fig. @ref(f1) shows number unique groups taxonomic rank, ordered highest lowest taxonomic rank dataset. can see 2.5 thousand genera, genus lowest rank training set. bottom left panel contains histogram number sequences per group. maximum group size accordance maxGroupSize set . , pre-trained classified single sequence per group take minimal space. Typically classifiers wide distribution number sequences per group. bottom right panel displays inverse document frequency (IDF) weights associated k-mer. can see many rare k-mers high weights (.e., high information content), common k-mers low weights. highly-skewed distribution information content among k-mers typical among sequence data.","code":"data(\"TrainingSet_16S\") trainingSet <- TrainingSet_16S trainingSet ##   A training set of class 'Taxa' ##    * K-mer size: 8 ##    * Number of rank levels: 10 ##    * Total number of sequences: 2472 ##    * Number of groups: 2472 ##    * Number of problem groups: 5 ##    * Number of problem sequences: 8"},{"path":"/articles/ClassifySequences.html","id":"classifying-sequences","dir":"Articles","previous_headings":"","what":"Classifying Sequences","title":"Classify Sequences","text":"Now trained classifier, next step use assign taxonomic classifications new sequences. accomplished IdTaxa function, takes “test” (new) sequences along training set (trainingSet) object returned LearnTaxa. purposes tutorial, going use 16S rRNA gene sequences collected organisms present tap water. Feel free follow along sequences, load FASTA file included tutorial. training (), test sequences contain gap (“-” “.”) characters, can easily removed RemoveGaps function:","code":"fas <- \"<<path to FASTA file>>\" # OR use the example 16S sequences: fas <- system.file(\"extdata\",     \"Bacteria_175seqs.fas\",     package=\"DECIPHER\")  # read the sequences into memory test <- readDNAStringSet(fas) # Alternatively use readAAStringSet or readRNAStringSet # if they exist, remove any gaps in the sequences: test <- RemoveGaps(test) test ## DNAStringSet object of length 175: ##       width seq                                             names                ##   [1]  1235 TCTGATATAGCGGCGGACGGGT...TTCTCAGTTCGGATTGTAGGCT uncultured bacter... ##   [2]  1351 TTAGCGGCGGACGGGTGAGTAA...GAGTTTGTAACACCCGAAGCCG uncultured bacter... ##   [3]  1326 CGGCGGACGGGTGAGTAACACG...CACCGCCCGTCACACCACGAGA uncultured bacter... ##   [4]  1345 GCGAACGGGTGAGTAACACGTG...TTGGAACACCCGAAGTCGGCCG uncultured bacter... ##   [5]  1343 AACGCGTGGGTAACCTACCCAT...GTCTGCACACCCGAAGCCGGTG uncultured bacter... ##   ...   ... ... ## [171]  1314 CGGACGGGTGAGTAAAGCATAG...GCCCGTCACACCATGGGAGTGG uncultured bacter... ## [172]  1316 ACGGGTGAGTAATGCTTAGGAA...CCCGTCACACCATGGGAGTTGG uncultured bacter... ## [173]  1308 GGCAACCCCAGAGAATGGCGAA...TGAACACGTTCCCGGGCCTTGT uncultured bacter... ## [174]  1313 GACGGGTGGTTAACACGTAGGT...AGAGGGTCACGCCCGAAGTCGG uncultured bacter... ## [175]  1333 CTTTCGGGGGTGCTTCAGTGGC...CGAAAGAAGGTCACGCCCGAAG uncultured bacter..."},{"path":"/articles/ClassifySequences.html","id":"assigning-classifications","dir":"Articles","previous_headings":"Classifying Sequences","what":"Assigning classifications","title":"Classify Sequences","text":"Now, moment waiting : ’s time classify test sequences! ’s important read help file IdTaxa acquaint available options performing step. important (optional) arguments type output, strand used testing, confidence threshold assignments, number processors use. , going request \"extended\" (default) output type allows plotting results, also \"collapsed\" type might easier export (see section @ref(export) ). Also, know test sequences (“+” strand) orientation training sequences, can specify look \"top\" strand rather default \"\" strands (.e., “+” “-” strands). makes classification process twice fast. also set processors NULL use available processors. threshold 60% recommended default confidence threshold. Confidence levels informally defined 70% (stringent), 60% (cautious), 50% (sensible), 40% (lenient). Using threshold 0% report classifications rank levels. Note test sequences generally fully-overlapped information training sequences. way, training sequences can longer test sequences, reverse situation result lower confidences. Let’s look results printing object (ids) returned: Note data class Taxa subclass Test, stored object type list. Therefore can access subset returned object (ids) single square brackets ([) access contents individual list elements double square brackets ([[): output can easily converted character vector taxonomic information assigned sequence:","code":"ids <- IdTaxa(test,     trainingSet,     type=\"extended\",     strand=\"top\",     threshold=60,     processors=1) ## ================================================================================ ##  ## Time difference of 5.11 secs |===========================================================================| 100%  Time difference of 12.23 secs ids ##   A test set of class 'Taxa' with length 175 ##       confidence name                 taxon ##   [1]        73% uncultured bacter... Root; Bacteria; Firmicutes; Bacilli; Ba... ##   [2]        68% uncultured bacter... Root; Bacteria; Firmicutes; Bacilli; Ba... ##   [3]        63% uncultured bacter... Root; Bacteria; Firmicutes; Bacilli; Ba... ##   [4]        92% uncultured bacter... Root; Bacteria; Firmicutes; Bacilli; La... ##   [5]        61% uncultured bacter... Root; Bacteria; Firmicutes; Clostridia;... ##   ...        ... ...                  ... ## [171]        39% uncultured bacter... Root; unclassified_Root                    ## [172]        48% uncultured bacter... Root; unclassified_Root                    ## [173]        31% uncultured bacter... Root; unclassified_Root                    ## [174]        49% uncultured bacter... Root; unclassified_Root                    ## [175]        54% uncultured bacter... Root; unclassified_Root ids[1:5] # summary results for the first 5 sequences ##   A test set of class 'Taxa' with length 5 ##     confidence name                 taxon ## [1]        73% uncultured bacter... Root; Bacteria; Firmicutes; Bacilli; Baci... ## [2]        68% uncultured bacter... Root; Bacteria; Firmicutes; Bacilli; Baci... ## [3]        63% uncultured bacter... Root; Bacteria; Firmicutes; Bacilli; Baci... ## [4]        92% uncultured bacter... Root; Bacteria; Firmicutes; Bacilli; Lact... ## [5]        61% uncultured bacter... Root; Bacteria; Firmicutes; Clostridia; C... ids[[1]] # results for the first sequence ## $taxon ## [1] \"Root\"                        \"Bacteria\"                    ## [3] \"Firmicutes\"                  \"Bacilli\"                     ## [5] \"Bacillales\"                  \"Planococcaceae\"              ## [7] \"unclassified_Planococcaceae\" ##  ## $confidence ## [1] 74.21434 74.21434 74.21434 74.21434 74.21434 73.49649 73.49649 ##  ## $rank ## [1] \"rootrank\" \"domain\"   \"phylum\"   \"class\"    \"order\"    \"family\"   \"genus\" ids[c(10, 25)] # combining different sequences ##   A test set of class 'Taxa' with length 2 ##     confidence name                 taxon ## [1]        49% uncultured bacter... Root; unclassified_Root                      ## [2]        34% uncultured bacter... Root; unclassified_Root c(ids[10], ids[25]) # merge different sets ##   A test set of class 'Taxa' with length 2 ##     confidence name                 taxon ## [1]        49% uncultured bacter... Root; unclassified_Root                      ## [2]        34% uncultured bacter... Root; unclassified_Root ids[, c(\"rootrank\", \"domain\", \"class\")] # only look at specific rank levels ##   A test set of class 'Taxa' with length 175 ##       confidence name                 taxon ##   [1]        74% uncultured bacter... Root; Bacteria; Bacilli                    ##   [2]        71% uncultured bacter... Root; Bacteria; Bacilli                    ##   [3]        68% uncultured bacter... Root; Bacteria; Bacilli                    ##   [4]        92% uncultured bacter... Root; Bacteria; Bacilli                    ##   [5]        66% uncultured bacter... Root; Bacteria; Clostridia                 ##   ...        ... ...                  ... ## [171]        39% uncultured bacter... Root; unclassified_Root                    ## [172]        48% uncultured bacter... Root; unclassified_Root                    ## [173]        31% uncultured bacter... Root; unclassified_Root                    ## [174]        49% uncultured bacter... Root; unclassified_Root                    ## [175]        54% uncultured bacter... Root; unclassified_Root ids[threshold=70] # threshold the results at a higher confidence ##   A test set of class 'Taxa' with length 175 ##       confidence name                 taxon ##   [1]        73% uncultured bacter... Root; Bacteria; Firmicutes; Bacilli; Ba... ##   [2]        71% uncultured bacter... Root; Bacteria; Firmicutes; Bacilli; Ba... ##   [3]        68% uncultured bacter... Root; unclassified_Root...                 ##   [4]        92% uncultured bacter... Root; Bacteria; Firmicutes; Bacilli; La... ##   [5]        66% uncultured bacter... Root; unclassified_Root...                 ##   ...        ... ...                  ... ## [171]        39% uncultured bacter... Root; unclassified_Root                    ## [172]        48% uncultured bacter... Root; unclassified_Root                    ## [173]        31% uncultured bacter... Root; unclassified_Root                    ## [174]        49% uncultured bacter... Root; unclassified_Root                    ## [175]        54% uncultured bacter... Root; unclassified_Root assignment <- sapply(ids,     function(x)         paste(x$taxon,             collapse=\";\")) head(assignment) ##                                               uncultured bacterium; Pro_CL-05069_OTU-15.  ## \"Root;Bacteria;Firmicutes;Bacilli;Bacillales;Planococcaceae;unclassified_Planococcaceae\"  ##                                               uncultured bacterium; Fin_CL-100646_OTU-6.  ##           \"Root;Bacteria;Firmicutes;Bacilli;Bacillales;Staphylococcaceae;Staphylococcus\"  ##                                              uncultured bacterium; Mar_CL-050642_OTU-13.  ##           \"Root;Bacteria;Firmicutes;Bacilli;Bacillales;Staphylococcaceae;Staphylococcus\"  ##                                               uncultured bacterium; Mar_CL-100626_OTU-8.  ##      \"Root;Bacteria;Firmicutes;Bacilli;Lactobacillales;Carnobacteriaceae;Dolosigranulum\"  ##                                              uncultured bacterium; Fin_CL-100633_OTU-22.  ##   \"Root;Bacteria;Firmicutes;Clostridia;Clostridiales;Peptococcaceae 1;Desulfosporosinus\"  ##                                               uncultured bacterium; Fin_CL-050645_OTU-2.  ##                                                                 \"Root;unclassified_Root\""},{"path":"/articles/ClassifySequences.html","id":"plotting-the-results","dir":"Articles","previous_headings":"Classifying Sequences","what":"Plotting the results","title":"Classify Sequences","text":"can also plot results, shown Figure @ref(f2). produces pie chart showing relative abundance taxonomic groups assigned test sequences. also displays training taxonomic tree, edges colored match taxonomic groups shown pie chart. Note also plotted pie chart omitting trainingSet. Also, possible specify parameter n classification represents varying number sequences, e.g., unique sequences originally classified.","code":""},{"path":"/articles/ClassifySequences.html","id":"create-and-plot-a-classification-table","dir":"Articles","previous_headings":"Classifying Sequences","what":"Create and plot a classification table","title":"Classify Sequences","text":"analyzing multiple samples, often useful create classification table number times taxon observed. can choose specific taxonomic rank consider, simply select lowest (.e., basal) taxonomic level: Next, need know test sequences belonged sample. must form vector sample names length number samples. example, case sample names part sequence names. Using vector can easily generate classification table: can summarize results stacked barplot:","code":"phylum <- sapply(ids,     function(x) {         w <- which(x$rank==\"phylum\")         if (length(w) != 1) {             \"unknown\"         } else {             x$taxon[w]         }     }) table(phylum) ## phylum ## \"Actinobacteria\"  \"Bacteroidetes\" \"Proteobacteria\"       Firmicutes  ##               26                8               78                5  ##      Nitrospirae          unknown  ##                5               53 taxon <- sapply(ids,     function(x)         x$taxon[length(x$taxon)]) head(taxon) ##  uncultured bacterium; Pro_CL-05069_OTU-15.  ##               \"unclassified_Planococcaceae\"  ##  uncultured bacterium; Fin_CL-100646_OTU-6.  ##                            \"Staphylococcus\"  ## uncultured bacterium; Mar_CL-050642_OTU-13.  ##                            \"Staphylococcus\"  ##  uncultured bacterium; Mar_CL-100626_OTU-8.  ##                            \"Dolosigranulum\"  ## uncultured bacterium; Fin_CL-100633_OTU-22.  ##                         \"Desulfosporosinus\"  ##  uncultured bacterium; Fin_CL-050645_OTU-2.  ##                         \"unclassified_Root\" # get a vector with the sample name for each sequence samples <- gsub(\".*; (.+?)_.*\", \"\\\\1\", names(test)) taxaTbl <- table(taxon, samples) taxaTbl <- t(t(taxaTbl)/colSums(taxaTbl)) # normalize by sample head(taxaTbl) ##                 samples ## taxon              Chlminus    Chlplus        Fin        LO1        LO3 ##   Achromobacter  0.00000000 0.03846154 0.00000000 0.00000000 0.00000000 ##   Acidovorax     0.07692308 0.00000000 0.00000000 0.00000000 0.00000000 ##   Afipia         0.07692308 0.00000000 0.00000000 0.00000000 0.00000000 ##   Asinibacterium 0.00000000 0.03846154 0.00000000 0.00000000 0.00000000 ##   Blastomonas    0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 ##   Brevundimonas  0.00000000 0.03846154 0.00000000 0.00000000 0.12500000 ##                 samples ## taxon                   Mar        Pro        UWH        UWL ##   Achromobacter  0.00000000 0.00000000 0.00000000 0.00000000 ##   Acidovorax     0.00000000 0.00000000 0.00000000 0.00000000 ##   Afipia         0.00000000 0.00000000 0.00000000 0.00000000 ##   Asinibacterium 0.00000000 0.00000000 0.00000000 0.00000000 ##   Blastomonas    0.00000000 0.00000000 0.04166667 0.00000000 ##   Brevundimonas  0.00000000 0.00000000 0.04166667 0.00000000"},{"path":"/articles/ClassifySequences.html","id":"exporting-the-classifications","dir":"Articles","previous_headings":"Classifying Sequences","what":"Exporting the classifications","title":"Classify Sequences","text":"{#export} can switch outputting extended collapsed format setting type argument IdTaxa. collapsed type output simply character vector, plotted easy write text file writeLines function. tutorial requested extended type output, stored list structure must converted character vector can write text file. may choose want text output look like, pasting together result sequence using delimiters. example:","code":"output <- sapply(ids,     function (id) {         paste(id$taxon,             \" (\",             round(id$confidence, digits=1),             \"%\",             sep=\"\",             collapse=\"; \")     }) tail(output) ##  uncultured bacterium; UWH_CL-010746_OTU-2.  ##         \"Root (46%; unclassified_Root (46%\"  ##  uncultured bacterium; UWH_CL-01079_OTU-21.  ##         \"Root (39%; unclassified_Root (39%\"  ##   uncultured bacterium; UWH_CL-08061_OTU-5.  ##     \"Root (48.6%; unclassified_Root (48.6%\"  ##  uncultured bacterium; Fin_CL-03079_OTU-21.  ##     \"Root (31.7%; unclassified_Root (31.7%\"  ## uncultured bacterium; UWL_CL-110518_OTU-11.  ##     \"Root (49.3%; unclassified_Root (49.3%\"  ## uncultured bacterium; UWL_CL-110548_OTU-32.  ##     \"Root (54.1%; unclassified_Root (54.1%\" #writeLines(output, \"<<path to output text file>>\")"},{"path":"/articles/ClassifySequences.html","id":"guaranteeing-repeatability","dir":"Articles","previous_headings":"Classifying Sequences","what":"Guaranteeing repeatability","title":"Classify Sequences","text":"IDTAXA algorithm uses bootstrapping, involves random sampling obtain confidence score. reason, classifications expected change slightly classification process repeated inputs. applications randomness undesirable, can easily avoided setting random seed classification. process setting unsetting seed straightforward:","code":"set.seed(123) # choose a whole number as the random seed # then classify sequences with IdTaxa (not shown) set.seed(NULL) # return to the original state by unsetting the seed"},{"path":"/articles/ClassifySequences.html","id":"creating-a-taxid-file","dir":"Articles","previous_headings":"","what":"Creating a “taxid” file","title":"Classify Sequences","text":"“taxid” file format supplies table can used LearnTaxa specify taxonomic ranks (e.g., phylum, class, order, etc.) associated taxon. Previously imported rank information plain text file containing 5 columns separate asterisks (“*“). example contents file : leftmost column simply index starting zero. Next, column unique taxonomic name training set. third column contains pointer index line’s parent. fourth column gives rank level starting “Root” level 0. last column provides taxonomic rank information used LearnTaxa. first line always , specifies “Root” rank index 0, parent (-1), points (index 0). rest lines must point positive index parent. example, line index 6 states genus “Ferrimicrobium” exist within family “Acidimicrobiaceae” (index 4) rank level 5. like create custom “taxid” file training set, easiest way start set taxonomic labels preceded prefixes indicating rank. example, “taxid” file generated lines text: following code convert text fields required “taxid” file: Now lines text can written file imported “taxid” file .","code":"ranks <- readLines(\"<<path to lines of text>>\") taxa <- setNames(c(\"domain\", \"phylum\", \"order\", \"family\", \"genus\"),         c(\"d__\", \"p__\", \"o__\", \"f__\", \"g__\"))  ranks <- strsplit(ranks, \";\", fix=T) count <- 1L groups <- \"Root\" index <- -1L level <- 0L rank <- \"rootrank\" pBar <- txtProgressBar(style=3) for (i in seq_along(ranks)) {     for (j in seq_along(ranks[[i]])) {         rank_level <- taxa[substring(ranks[[i]][j], 1, 3)]         group <- substring(ranks[[i]][j], 4)         w <- which(groups==group & rank==rank_level)         if (length(w) > 0) {             parent <- match(substring(ranks[[i]][j - 1], 4),                 groups)             if (j==1 || any((parent - 1L)==index[w]))                 next # already included         }                  count <- count + 1L         groups <- c(groups, group)         if (j==1) {             index <- c(index, 0)         } else {             parent <- match(substring(ranks[[i]][j - 1], 4),                 groups)             index <- c(index,                 parent - 1L)         }         level <- c(level, j)         rank <- c(rank, taxa[j])     }          setTxtProgressBar(pBar, i/length(ranks)) } groups <- gsub(\"^[ ]+\", \"\", groups) groups <- gsub(\"[ ]+$\", \"\", groups)  taxid <- paste(0:(length(index) - 1L), groups, index, level, rank, sep=\"*\") head(taxid, n=10) [1] \"0*Root*-1*0*rootrank\"           [2] \"1*Bacteria*0*1*domain\"          [3] \"2*Actinobacteria*1*2*phylum\"    [4] \"3*Acidimicrobiales*2*3*order\"   [5] \"4*Acidimicrobiaceae*3*4*family\" [6] \"5*Acidimicrobium*4*5*genus\"     [7] \"6*Ferrimicrobium*4*5*genus\" writeLines(taxid,     con=\"<<path to taxid file>>\")"},{"path":"/articles/ClassifySequences.html","id":"annotating-protein-sequences","dir":"Articles","previous_headings":"","what":"Annotating Protein Sequences","title":"Classify Sequences","text":"IDTAXA algorithm can also used classify amino acid sequences taxonomy genes, functions, organisms. example, can train classifier set named genes phylum Planctobacteria. Sets can constructed various databases, including https://www.uniprot.org/uniprot/?query=reviewed{SwissProt}. example training sequences can loaded : , protein sequences named enzyme commission (EC) number three four-letter gene name. important train classifier sequences complete labels. case, get rid sequences without EC number. Since taxonomy contains widely disparate sequences, expect tree descent useful. can disable tree descent setting maxChildren 1 LearnTaxa. Next need set query sequences classify. end, use representative genome Chlamydia trachomatis species, member Planctobacteria phylum. can find genes genome using DECIPHER function FindGenes. Now, can take advantage fact training testing sets composed full-length sequences setting fullLength 0.99 IdTaxa. automatically infer expected length variability among proteins, filter potential classifications within reasonable length range. Furthermore, lower threshold 50%, recommended value protein sequences. Since third proteins classifiable dataset, can display subset genes belong “unclassified_Root”. make plot interesting, subset first EC number. see genes either placed class EC number belong EC 2 (Transferases) EC 3 (Hydrolases).","code":"fas <- system.file(\"extdata\",     \"PlanctobacteriaNamedGenes.fas.gz\",     package=\"DECIPHER\") aa <- readAAStringSet(fas) aa ## AAStringSet object of length 2497: ##        width seq                                            names                ##    [1]   227 MAGPKHVLLVSEHWDLFFQTKE...VGYLFSDDGDKKFSQQDTKLS A0A0H3MDW1|Root;N... ##    [2]   394 MKRNPHFVSLTKNYLFADLQKR...GKREDILAACERLQMAPALQS O84395|Root;2;6;1... ##    [3]   195 MAYGTRYPTLAFHTGGIGESDD...GFCLTALGFLNFENAEPAKVN Q9Z6M7|Root;4;1;1... ##    [4]   437 MMLRGVHRIFKCFYDVVLVCAF...TASFDRTWRALKSYIPLYKNS Q46222|Root;2;4;9... ##    [5]   539 MSFKSIFLTGGVVSSLGKGLTA...FIEFIRAAKAYSLEKANHEHR Q59321|Root;6;3;4... ##    ...   ... ... ## [2493]  1038 MFEEVLQESFDEREKKVLKFWQ...EGTDWDLNGEPTKIIIKKSEY Q6MDY1|Root;6;1;1... ## [2494]   102 MVQIVSQDNFADSIASGLVLVD...VERSVGLKDKDSLVKLISKHQ Q9PJK3|Root;NoEC;... ## [2495]   224 MKPQDLKLPYFWEDRCPKIENH...NLWRSKGEKIFCTEFVKRVGI Q9PL91|Root;2;1;1... ## [2496]   427 MLRRLFVSTFLIFGMVSLYAKD...KIVIGLGEKRFPSWGGFPNNQ Q256H8|Root;NoEC;... ## [2497]   344 MLTLGLESSCDETACALVDAKG...GIHPCARYHWESISASLSPLP Q822Y4|Root;2;3;1... head(names(aa)) ## [1] \"A0A0H3MDW1|Root;NoEC;chxR\"        \"O84395|Root;2;6;1;83;dapL\"        ## [3] \"Q9Z6M7|Root;4;1;1;19;aaxB\"        \"Q46222|Root;2;4;99;Multiple;waaA\" ## [5] \"Q59321|Root;6;3;4;2;pyrG\"         \"P0C0Z7|Root;NoEC;groL\" aa <- aa[!grepl(\"Root;NoEC\", names(aa), fixed=TRUE)] aa ## AAStringSet object of length 1542: ##        width seq                                            names                ##    [1]   394 MKRNPHFVSLTKNYLFADLQKR...GKREDILAACERLQMAPALQS O84395|Root;2;6;1... ##    [2]   195 MAYGTRYPTLAFHTGGIGESDD...GFCLTALGFLNFENAEPAKVN Q9Z6M7|Root;4;1;1... ##    [3]   437 MMLRGVHRIFKCFYDVVLVCAF...TASFDRTWRALKSYIPLYKNS Q46222|Root;2;4;9... ##    [4]   539 MSFKSIFLTGGVVSSLGKGLTA...FIEFIRAAKAYSLEKANHEHR Q59321|Root;6;3;4... ##    [5]    92 MQVNEYFDGNVTSIAFENGEGR...DANQKFQVRVIEPTAYLCFYS Q7USA1|Root;2;4;2... ##    ...   ... ... ## [1538]  1036 MDNEDKISISAKEEKILSFWKE...EGEEWDINGHAVSFVLERVER B0BB05|Root;6;1;1... ## [1539]   342 MTIQEELEAVKQQFSCDVSLAH...YGISDIRLFSENDLRFLRQFS O84843|Root;6;1;1... ## [1540]  1038 MFEEVLQESFDEREKKVLKFWQ...EGTDWDLNGEPTKIIIKKSEY Q6MDY1|Root;6;1;1... ## [1541]   224 MKPQDLKLPYFWEDRCPKIENH...NLWRSKGEKIFCTEFVKRVGI Q9PL91|Root;2;1;1... ## [1542]   344 MLTLGLESSCDETACALVDAKG...GIHPCARYHWESISASLSPLP Q822Y4|Root;2;3;1... trainingSet <- LearnTaxa(train=aa,     taxonomy=names(aa),     maxChildren=1) ## ================================================================================ ##  ## Time difference of 0.62 secs fas <- system.file(\"extdata\",     \"Chlamydia_trachomatis_NC_000117.fas.gz\",     package=\"DECIPHER\") genome <- readDNAStringSet(fas) genes <- FindGenes(genome, verbose=FALSE) test <- ExtractGenes(genes, genome, type=\"AAStringSet\") test ## AAStringSet object of length 897: ##       width seq ##   [1]   392 AAAREIAKRWEQRVRDLQDKGAARKLLNDPLGR...QVEGILRDMLTNGSQTFRDLMRRWNREVDRE* ##   [2]    91 MLCKVCRGLSSLIVVLGAINTGILGVTGYKVNL...CLNFLKCCFKKRHGDCCSSKGGYHHHHMDRE* ##   [3]   101 MTESYVNKEEIISLAKNAALELEDAHVEEFVTS...DMVTSDFTQEEFLSNVPVSLGGLVKVPTVIK* ##   [4]   492 MYRKSALELRDAVVNRELSVTAITEYFYHRIES...ICQVGYSFQEHSQIKQLYPKAVNGLFDGGIE* ##   [5]   489 MGIAHTEWESVIGLEVHVELNTESKLFSPARNH...GFLVGQIMKRTEGKAPPKRVNELLLAAMRDM* ##   ...   ... ... ## [893]  1017 MPFSLRSTSFCFLACLCSYSYGFASSPQVLTPN...HHFGRAYMNYSLDARRRQTAHFVSMGLNRIF* ## [894]   101 MLATIKKITVLLLSKRKAGIRIDYCALALDAVE...LDASLESAQVRLAGLMLDYWDGDSRLECKKI* ## [895]   879 MRPDHMNFCCLCAAILSSTAVLFGQDPLGETAL...LHRLQTLLNVSYVLRGQSHSYSLDLGTTYRF* ## [896]    32 MSKKSNNLQTFSSRALFHVFQDEELRKIFGL* ## [897]   200 MSIRGVGGNGNSRIPSHNGDGSNRRSQNTKGNN...NLDVNEARLMAAYTSECADHLEANKLAGPDGV ids <- IdTaxa(test,     trainingSet,     fullLength=0.99,     threshold=50,     processors=1) ## ================================================================================ ##  ## Time difference of 1.52 secs ids ##   A test set of class 'Taxa' with length 897 ##       confidence taxon ##   [1]         8% Root; unclassified_Root                                         ##   [2]         0% Root; unclassified_Root                                         ##   [3]        99% Root; 6; 3; 5; -; gatC                                          ##   [4]       100% Root; 6; 3; 5; 7; gatA                                          ##   [5]        99% Root; 6; 3; 5; -; gatB                                          ##   ...        ... ... ## [893]         5% Root; unclassified_Root                                         ## [894]         3% Root; unclassified_Root                                         ## [895]         8% Root; unclassified_Root                                         ## [896]         0% Root; unclassified_Root                                         ## [897]         8% Root; unclassified_Root"},{"path":"/articles/ClusteringSequences.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Upsize your clustering with Clusterize","text":"may found familiar predicament many bioinformaticians: lot sequences need downsize can get going. may also theorize must easy problem solve given sequences, output clusters. can utilize solve problem? vignette familiarize Clusterize function DECIPHER package. Clusterize revolutionize clustering needs! \\ Clusterize? Scalability - Clusterize linearize search space many sequences can clustered reasonable amount time. Simplicity - Although can individualize Clusterize, defaults straightforward meet needs. Accuracy - Clusterize maximize ability extract biologically meaningful results sequences. vignette summarize use Clusterize cluster DNA, RNA, protein sequences.","code":""},{"path":"/articles/ClusteringSequences.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting Started","title":"Upsize your clustering with Clusterize","text":"get started need load DECIPHER package, automatically mobilize required packages. ’s need memorize inputs Clusterize, help page can accessed :","code":"library(DECIPHER) ## Loading required package: Biostrings ## Loading required package: BiocGenerics ##  ## Attaching package: 'BiocGenerics' ## The following objects are masked from 'package:stats': ##  ##     IQR, mad, sd, var, xtabs ## The following objects are masked from 'package:base': ##  ##     anyDuplicated, aperm, append, as.data.frame, basename, cbind, ##     colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ##     get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply, ##     match, mget, order, paste, pmax, pmax.int, pmin, pmin.int, ##     Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort, ##     table, tapply, union, unique, unsplit, which.max, which.min ## Loading required package: S4Vectors ## Loading required package: stats4 ##  ## Attaching package: 'S4Vectors' ## The following object is masked from 'package:utils': ##  ##     findMatches ## The following objects are masked from 'package:base': ##  ##     expand.grid, I, unname ## Loading required package: IRanges ## Loading required package: XVector ## Loading required package: GenomeInfoDb ##  ## Attaching package: 'Biostrings' ## The following object is masked from 'package:base': ##  ##     strsplit ## Loading required package: RSQLite ## Loading required package: parallel > ? Clusterize"},{"path":"/articles/ClusteringSequences.html","id":"optimize-your-inputs-to-clusterize","dir":"Articles","previous_headings":"","what":"Optimize your inputs to Clusterize","title":"Upsize your clustering with Clusterize","text":"Clusterize requires first digitize sequences loading memory. purpose vignette, capitalize fact DECIPHER already includes built-sets sequences. Clusterize algorithm generalize nucleotide protein sequences, must choose going use. , hypothesize weaker similarities can detected proteins , therefore, decide use translated coding (amino acid) sequences. wish cluster high similarity, also strategize nucleotide sequences better nucleotide amino acid differences. Now can choose parameterize function, main arguments myXStringSet cutoff. case, initialize cutoff seq(0.5, 0, -0.1) cluster sequences 50% 100% similarity 10%’s. important recognize cutoffs can provided ascending descending order , descending, groups cutoff nested within previous cutoff’s groups. must also choose whether customize calculation distance. defaults penalize gaps single events, consecutive set gaps (.e., insertion deletion) considered equivalent one mismatch. want standardize definition distance clustering programs set: penalizeGapLetterMatches TRUE (.e., every gap position mismatch), method \"shortest\", minCoverage 0, includeTerminalGaps TRUE. possible rationalize many different measures distance – see DistanceMatrix function information alternative parameterizations. can personalize inputs desired. main function argument emphasize processors, controls whether function parallelized multiple computer threads (DECIPHER) built OpenMP enabled). Setting processors value greater 1 speed clustering considerably, especially large size clustering problems. ready, ’s time run Clusterize wait output materialize! Notice Clusterize characterize clustering based many clustered pairs came relatedness sorting versus rare k-mers, Clusterize predict effectiveness clustering. Depending input sequences, percentage clusters originating relatedness sorting equalize number originating rare k-mers, commonly clusters originate one source . clustering effectiveness formalizes concept “inexact” clustering approximating fraction possible sequence pairs correctly clustered together. can incentivize higher clustering effectiveness increasing maxPhase3 expense (proportionally) longer run times. can now realize objective decreasing number sequences. , prioritize keeping longest diverse sequences.","code":"# specify the path to your file of sequences: fas <- \"<<path to training FASTA file>>\" # OR use the example DNA sequences: fas <- system.file(\"extdata\",     \"50S_ribosomal_protein_L2.fas\",     package=\"DECIPHER\") # read the sequences into memory dna <- readDNAStringSet(fas) dna ## DNAStringSet object of length 317: ##       width seq                                             names                ##   [1]   819 ATGGCTTTAAAAAATTTTAATC...ATTTATTGTAAAAAAAAGAAAA Rickettsia prowaz... ##   [2]   822 ATGGGAATACGTAAACTCAAGC...CATCATTGAGAGAAGGAAAAAG Porphyromonas gin... ##   [3]   822 ATGGGAATACGTAAACTCAAGC...CATCATTGAGAGAAGGAAAAAG Porphyromonas gin... ##   [4]   822 ATGGGAATACGTAAACTCAAGC...CATCATTGAGAGAAGGAAAAAG Porphyromonas gin... ##   [5]   819 ATGGCTATCGTTAAATGTAAGC...CATCGTACGTCGTCGTGGTAAA Pasteurella multo... ##   ...   ... ... ## [313]   819 ATGGCAATTGTTAAATGTAAAC...TATCGTACGTCGCCGTACTAAA Pectobacterium at... ## [314]   822 ATGCCTATTCAAAAATGCAAAC...TATTCGCGATCGTCGCGTCAAG Acinetobacter sp.... ## [315]   864 ATGGGCATTCGCGTTTACCGAC...GGGTCGCGGTGGTCGTCAGTCT Thermosynechococc... ## [316]   831 ATGGCACTGAAGACATTCAATC...AAGCCGCCACAAGCGGAAGAAG Bradyrhizobium ja... ## [317]   840 ATGGGCATTCGCAAATATCGAC...CAAGACGGCTTCCGGGCGAGGT Gloeobacter viola... aa <- translate(dna) aa ## AAStringSet object of length 317: ##       width seq                                             names                ##   [1]   273 MALKNFNPITPSLRELVQVDKT...STKGKKTRKNKRTSKFIVKKRK Rickettsia prowaz... ##   [2]   274 MGIRKLKPTTPGQRHKVIGAFD...KGLKTRAPKKHSSKYIIERRKK Porphyromonas gin... ##   [3]   274 MGIRKLKPTTPGQRHKVIGAFD...KGLKTRAPKKHSSKYIIERRKK Porphyromonas gin... ##   [4]   274 MGIRKLKPTTPGQRHKVIGAFD...KGLKTRAPKKHSSKYIIERRKK Porphyromonas gin... ##   [5]   273 MAIVKCKPTSAGRRHVVKIVNP...TKGKKTRHNKRTDKFIVRRRGK Pasteurella multo... ##   ...   ... ... ## [313]   273 MAIVKCKPTSPGRRHVVKVVNP...TKGKKTRSNKRTDKFIVRRRTK Pectobacterium at... ## [314]   274 MPIQKCKPTSPGRRFVEKVVHS...KGYKTRTNKRTTKMIIRDRRVK Acinetobacter sp.... ## [315]   288 MGIRVYRPYTPGVRQKTVSDFA...SDALIVRRRKKSSKRGRGGRQS Thermosynechococc... ## [316]   277 MALKTFNPTTPGQRQLVMVDRS...KKTRSNKSTNKFILLSRHKRKK Bradyrhizobium ja... ## [317]   280 MGIRKYRPMTPGTRQRSGADFA...RKRRKPSSKFIIRRRKTASGRG Gloeobacter viola... seqs <- aa # could also cluster the nucleotides clusters <- Clusterize(seqs, cutoff=seq(0.5, 0, -0.1), processors=NULL) ## Partitioning sequences by 6-mer similarity: ##  iteration 8 of up to 400 (100.0% coverage) ##  ## Time difference of 0.03 secs ##  ## Sorting by relatedness within 1 group: ##  iteration 51 of up to 51 (100.0% stability)  ##  ## Time difference of 1.04 secs ##  ## Clustering sequences by 4-mer similarity: ## ================================================================================ ##  ## Clusters via relatedness sorting: 100% (0% exclusively) ## Clusters via rare 4-mers: 100% (0% exclusively) ## Estimated clustering effectiveness: 100% ## Time difference of 0.08 secs class(clusters) ## [1] \"data.frame\" colnames(clusters) ## [1] \"cluster_0_5\" \"cluster_0_4\" \"cluster_0_3\" \"cluster_0_2\" \"cluster_0_1\" ## [6] \"cluster_0\" str(clusters) ## 'data.frame':    317 obs. of  6 variables: ##  $ cluster_0_5: int  4 4 4 4 4 4 4 3 3 3 ... ##  $ cluster_0_4: int  1 6 6 6 4 4 4 10 10 10 ... ##  $ cluster_0_3: int  53 38 38 38 45 45 42 30 30 30 ... ##  $ cluster_0_2: int  1 24 24 24 12 12 16 35 35 35 ... ##  $ cluster_0_1: int  87 54 54 54 69 69 64 42 42 42 ... ##  $ cluster_0  : int  2 45 45 45 24 24 32 57 57 57 ... apply(clusters, 2, max) # number of clusters per cutoff ## cluster_0_5 cluster_0_4 cluster_0_3 cluster_0_2 cluster_0_1   cluster_0  ##           4          27          53          71          87         102 o <- order(clusters[[2]], width(seqs), decreasing=TRUE) # 40 o <- o[!duplicated(clusters[[2]])] aa[o] ## AAStringSet object of length 27: ##      width seq                                              names                ##  [1]   274 MAVRKLKPTTPGQRHKIIGTFEE...KGLKTRAPKKQSSKYIIERRKK Bacteroides sp. 1... ##  [2]   274 MAVRKLKPTTPGQRHKIIGTFEE...KGLKTRAPKKQSSKYIIERRKK Bacteroides theta... ##  [3]   276 MAIRKMKPITNGTRHMSRLVNDE...LGIKTRGRKTSDKFIVRRRNEK Fusobacterium nuc... ##  [4]   280 MAIRKYKPTTPGRRASSVSMFTE...KPKRYSDDMIVRRRRANKNKKR Corynebacterium g... ##  [5]   277 MGIKTYKPKTSSLRYKTTLSFDD...KGYKTRKKKRYSDKFIIKRRNK Borrelia burgdorf... ##  ...   ... ... ## [23]   276 MGIKKYNPTTNGRRNMTTNDFAE...LGFKTRKKNKASDKFIVRRRKK Bacillus thuringi... ## [24]   278 MALKSFNPTTPSQRQLVIVSRAG...KRTRSNKSTDKFIMRSRHQRKK Sinorhizobium mel... ## [25]   276 MSVIKCNPTSPGRRHVVKLVNGG...KGKRTRSNKRTDKFILCRRKKK Candidatus Blochm... ## [26]   274 MAIVKCKPTSPGRRHVVKVVNAD...TKGFKTRKNKRTDKYIVRRRNK Vibrio parahaemol... ## [27]   274 MAIVKCKPTSAGRRHVVKVVNAD...TKGYKTRSNKRTDKYIVRRRNK Vibrio cholerae 1... dna[o] ## DNAStringSet object of length 27: ##      width seq                                              names                ##  [1]   822 ATGGCAGTACGTAAATTAAAGCC...CATTATTGAGAGAAGAAAAAAG Bacteroides sp. 1... ##  [2]   822 ATGGCAGTACGTAAATTAAAGCC...CATTATTGAGAGAAGAAAAAAG Bacteroides theta... ##  [3]   828 ATGGCTATTAGAAAAATGAAACC...CGTAAGAAGAAGAAACGAAAAA Fusobacterium nuc... ##  [4]   840 ATGGCTATTCGTAAGTACAAGCC...TGCTAACAAGAACAAGAAGCGC Corynebacterium g... ##  [5]   831 ATGGGTATTAAGACTTATAAGCC...TATTATTAAAAGAAGAAATAAA Borrelia burgdorf... ##  ...   ... ... ## [23]   828 ATGGGAATCAAAAAGTATAATCC...CATCGTTCGTCGTCGTAAAAAA Bacillus thuringi... ## [24]   834 ATGGCATTGAAAAGTTTCAATCC...CTCGCGTCACCAGCGCAAGAAG Sinorhizobium mel... ## [25]   828 ATGTCTGTTATAAAATGTAATCC...TTTATGTCGTCGTAAGAAAAAA Candidatus Blochm... ## [26]   822 ATGGCTATTGTTAAATGTAAGCC...CATCGTACGTCGTCGTAACAAG Vibrio parahaemol... ## [27]   822 ATGGCTATTGTTAAATGTAAGCC...CATCGTACGTCGTCGTAATAAG Vibrio cholerae 1..."},{"path":"/articles/ClusteringSequences.html","id":"visualize-the-output-of-clusterize","dir":"Articles","previous_headings":"","what":"Visualize the output of Clusterize","title":"Upsize your clustering with Clusterize","text":"can scrutinize clusters selecting looking multiple sequence alignment: ’s possible utilize heatmap function view clustering results. can seen Figure @ref(f1), Clusterize organize clusters new cluster within previous cluster cutoff provided descending order. can also see sequences species tend cluster together, alternative way systematize sequences without clustering.","code":"t <- table(clusters[[1]]) # select the clusters at a cutoff t <- sort(t, decreasing=TRUE) head(t) ##  ##   4   3   1   2  ## 153 105  47  12 w <- which(clusters[[1]] == names(t[1])) AlignSeqs(seqs[w], verbose=FALSE) ## AAStringSet object of length 153: ##       width seq                                             names                ##   [1]   287 -MALKNFNPITPSLRELVQVDK...TR-KNKRTSKFIVKKRK----- Rickettsia prowaz... ##   [2]   287 -MGIRKLKPTTPGQRHKVIGAF...TRAPKKHSSKYIIERRKK---- Porphyromonas gin... ##   [3]   287 -MGIRKLKPTTPGQRHKVIGAF...TRAPKKHSSKYIIERRKK---- Porphyromonas gin... ##   [4]   287 -MGIRKLKPTTPGQRHKVIGAF...TRAPKKHSSKYIIERRKK---- Porphyromonas gin... ##   [5]   287 -MAIVKCKPTSAGRRHVVKIVN...TR-HNKRTDKFIVRRRGK---- Pasteurella multo... ##   ...   ... ... ## [149]   287 -MAFKHFNPTTPGQRQLVIVDR...TR-SNKATDKFIMHTRHQRKK- Bartonella quinta... ## [150]   287 -MAFKHFNPTTPGQRQLVIVDR...TR-SNKATDKFIMHTRHQRKK- Bartonella quinta... ## [151]   287 -MAIVKCKPTSPGRRHVVKVVN...TR-SNKRTDKFIVRRRTK---- Pectobacterium at... ## [152]   287 -MPIQKCKPTSPGRRFVEKVVH...TR-TNKRTTKMIIRDRRVK--- Acinetobacter sp.... ## [153]   287 -MALKTFNPTTPGQRQLVMVDR...TR-SNKSTNKFILLSRHKRKK- Bradyrhizobium ja..."},{"path":"/articles/ClusteringSequences.html","id":"specialize-clustering-for-your-goals","dir":"Articles","previous_headings":"","what":"Specialize clustering for your goals","title":"Upsize your clustering with Clusterize","text":"common use clustering categorize sequences groups sharing similarity threshold pick one representative sequence per group. settings empitomize typical user scenario: default, Clusterize cluster sequences linkage representative sequence group, also possible tell Clusterize minimize number clusters establishing linkage sequence cluster (.e., single-linkage): possible synthesize plot showing cross tabulation taxonomy cluster number. may idealize clustering matching taxonomic labels (@ref(f2)), exactly case.","code":"c1 <- Clusterize(dna, cutoff=0.2, invertCenters=TRUE, processors=1) ## Partitioning sequences by 9-mer similarity: ##  iteration 96 of up to 400 (100.0% coverage) ##  ## Time difference of 0.11 secs ##  ## Sorting by relatedness within 89 groups: ##  iteration 37 of up to 37 (100.0% stability)  ##  ## Time difference of 0.24 secs ##  ## Clustering sequences by 9-mer similarity: ## ================================================================================ ##  ## Clusters via relatedness sorting: 100% (0% exclusively) ## Clusters via rare 6-mers: 100% (0% exclusively) ## Estimated clustering effectiveness: 100% ## Time difference of 1.36 secs w <- which(c1 < 0 & !duplicated(c1)) dna[w] # select cluster representatives (negative cluster numbers) ## DNAStringSet object of length 78: ##      width seq                                              names                ##  [1]   822 ATGGGAATACGTAAACTCAAGCC...CATCATTGAGAGAAGGAAAAAG Porphyromonas gin... ##  [2]   825 ATGCCATTGATGAAGTTCAAACC...CATCGTCCGCGATCGTAGGGGC Xanthomonas campe... ##  [3]   837 GTGGGTATTAAGAAGTATAAACC...TGGTCGCCGTCCAGGCAAACAC Lactobacillus pla... ##  [4]   828 ATGGCAATTAAGAAGTATAAACC...CATTGTACGTCGTCGTAAAAAA Bacillus halodura... ##  [5]   828 ATGGGTATTCGTAATTATCGGCC...GATTGTCCGCCGTCGCACCAAA Synechocystis sp.... ##  ...   ... ... ## [74]   831 ATGGCATTTAAGCACTTTAATCC...TACGCGTCATCAGCGCAAGAAA Bartonella quinta... ## [75]   843 ATGTTTAAGAAATATCGACCTGT...CGTGAAACGTCGAAGGAAGAAG Candidatus Protoc... ## [76]   822 ATGCCTATTCAAAAATGCAAACC...TATTCGCGATCGTCGCGTCAAG Acinetobacter sp.... ## [77]   864 ATGGGCATTCGCGTTTACCGACC...GGGTCGCGGTGGTCGTCAGTCT Thermosynechococc... ## [78]   840 ATGGGCATTCGCAAATATCGACC...CAAGACGGCTTCCGGGCGAGGT Gloeobacter viola... c2 <- Clusterize(dna, cutoff=0.2, singleLinkage=TRUE, processors=1) ## Partitioning sequences by 9-mer similarity: ##  iteration 96 of up to 400 (100.0% coverage) ##  ## Time difference of 0.1 secs ##  ## Sorting by relatedness within 89 groups: ##  iteration 37 of up to 37 (100.0% stability)  ##  ## Time difference of 0.24 secs ##  ## Clustering sequences by 9-mer similarity: ## ================================================================================ ##  ## Clusters via relatedness sorting: 100% (0% exclusively) ## Clusters via rare 6-mers: 100% (0% exclusively) ## Estimated clustering effectiveness: 100% ## Time difference of 1.99 secs max(abs(c1)) # center-linkage ## [1] 78 max(c2) # single-linkage (fewer clusters, but broader clusters) ## [1] 76"},{"path":"/articles/ClusteringSequences.html","id":"finalize-your-use-of-clusterize","dir":"Articles","previous_headings":"","what":"Finalize your use of Clusterize","title":"Upsize your clustering with Clusterize","text":"Notably, Clusterize stochastic algorithm, meaning randomize sequences selected pre-sorting. Even though clusters typically stabilize enough iterations, can set random number seed (every run) guarantee reproducibility clusters: Now know utilize Clusterize cluster sequences.","code":"set.seed(123) # initialize the random number generator clusters <- Clusterize(seqs, cutoff=0.1, processors=1) ## Partitioning sequences by 6-mer similarity: ##  iteration 8 of up to 400 (100.0% coverage) ##  ## Time difference of 0.02 secs ##  ## Sorting by relatedness within 1 group: ##  iteration 51 of up to 51 (100.0% stability)  ##  ## Time difference of 0.47 secs ##  ## Clustering sequences by 4-mer similarity: ## ================================================================================ ##  ## Clusters via relatedness sorting: 100% (0% exclusively) ## Clusters via rare 4-mers: 100% (0% exclusively) ## Estimated clustering effectiveness: 100% ## Time difference of 0.04 secs set.seed(NULL) # reset the seed"},{"path":[]},{"path":"/articles/DECIPHERing.html","id":"about-decipher","dir":"Articles","previous_headings":"","what":"About DECIPHER","title":"Getting Started DECIPHERing","text":"DECIPHER software toolset can used deciphering managing biological sequences efficiently using statistical programming language. program features tools falling five categories: Sequence databases: import, maintain, view, export massive number sequences. Sequence alignment: accurately align thousands DNA, RNA, amino acid sequences. Quickly find align syntenic regions multiple genomes. Oligo design: test oligos silico, create new primer probe sequences optimized variety objectives. Manipulate sequences: trim low quality regions, correct frameshifts, reorient nucleotides, determine consensus, digest restriction enzymes. Analyze sequences: find chimeras, classify taxonomy organisms functions, detect repeats, predict secondary structure, create phylogenetic trees, reconstruct ancestral states. Gene finding: predict coding non-coding genes genome, extract genome, export file. DECIPHER available terms GNU Public License version 3.","code":""},{"path":[]},{"path":"/articles/DECIPHERing.html","id":"curators-protect-the-originals","dir":"Articles","previous_headings":"Design Philosophy","what":"Curators Protect the Originals","title":"Getting Started DECIPHERing","text":"One core principles DECIPHER idea non-destructive workflow. revolves around concept original sequence information never altered: sequences exported looking identical first imported. Essentially, sequence information database thought backup original sequence file function able directly alter sequence data. workflows simply add information database, can used analyze, organize, maintain sequences. comes time export part sequences preserved original state without alteration.","code":""},{"path":"/articles/DECIPHERing.html","id":"dont-reinvent-the-wheel","dir":"Articles","previous_headings":"Design Philosophy","what":"Don’t Reinvent the Wheel","title":"Getting Started DECIPHERing","text":"DECIPHER makes use Biostrings package core part package contains numerous functions common operations searching, manipulating, reverse complementing sequences. Furthermore, DECIPHER makes use Biostrings interface handling sequence data sequences stored XStringSet objects. objects compatible many useful packages Bioconductor suite. wide variety user objectives necessitates DECIPHER extensible customized projects. provides simple way place power thousands packages fingertips. Likewise, enables direct access speed efficiency programming language maintaining utility scripting language. Therefore, minimal code required solve complex new problems. Best , statistical programming language open source, maintains thriving user community direct collaboration users available ","code":""},{"path":"/articles/DECIPHERing.html","id":"that-which-is-the-most-difficult-make-fastest","dir":"Articles","previous_headings":"Design Philosophy","what":"That Which is the Most Difficult, Make Fastest","title":"Getting Started DECIPHERing","text":"core objective DECIPHER make massive tasks feasible minimal time. end, many time consuming functions parallelized make use multiple processors. example, function DistanceMatrix gets almost 1x speed boost processor core. modern processor 8 cores can see factor close eight times speed improvement. Similar speedups can achieved many DECIPHER functions setting processors argument. made possible use OpenMP -level code. time consuming tasks handled efficiently. function FindChimeras can uncover sequence chimeras searching reference database million sequences thousands 30-mer fragments number minutes. incredible feat accomplished using PDict class provided Biostrings. Similarly, SearchDB function can obtain one---million sequences match targeted query matter seconds. high-speed functions enable user find solutions problems previously extremely difficult nearly impossible solve using antiquated methods.","code":""},{"path":"/articles/DECIPHERing.html","id":"stay-organized","dir":"Articles","previous_headings":"Design Philosophy","what":"Stay Organized","title":"Getting Started DECIPHERing","text":"longer necessary store related data several different files. DECIPHER enabled RSQLite, interface DECIPHER creates organized collection sequences associated information known sequence database. SQLite databases flat files, meaning can handled just like file. setup required since SQLite require server, unlike many database engines. attributes SQLite databases make storing, backing-, sharing sequence databases relatively straightforward. Separate projects can stored distinct tables sequence database. new table structured include every sequence’s description, identifier, unique key called row_name one place. sequences referenced row_names identifier throughout functions package. Using row_names, new information created DECIPHER functions can added additional database columns respective sequences’ rows database table. prevent database seeming like black box function named BrowseDB facilitates viewing database contents web browser. similar function available view sequences called BrowseSeqs. amount DNA sequence information available currently increasing phenomenal rate. DECIPHER stores individual sequences using custom compression format, called nbit, database file takes much less drive space standard text file sequences. compressed sequences stored hidden table linked main information table user interacts regularly. example, default sequence information stored table “Seqs”, associated sequences stored table “_Seqs”. Storing sequences separate table greatly improves access speed large amount sequence information. Separating projects distinct tables increases query speed storing every project single table.","code":""},{"path":"/articles/DECIPHERing.html","id":"functionality","dir":"Articles","previous_headings":"","what":"Functionality","title":"Getting Started DECIPHERing","text":"functions DECIPHER can grouped several categories based intended use: Add2DB . DB2Seqs . SearchDB . Seqs2DB IdentifyByRank . IdLengths ConsensusSequence . Disambiguate . IdConsensus DistanceMatrix . Clusterize . MaskAlignment . ReadDendrogram . StaggerAlignment . TreeLine . WriteDendrogram BrowseDB . BrowseSeqs CorrectFrameshifts . OrientNucleotides . RemoveGaps . TrimDNA DetectRepeats . DigestDNA . PredictDBN . PredictHEC AdjustAlignment . AlignDB . AlignProfiles . AlignSeqs . AlignTranslation . ScoreAlignment AlignSynteny . FindSynteny . Synteny-class CreateChimeras . FindChimeras . FormGroups Array2Matrix . CalculateEfficiencyArray . DesignArray . NNLS CalculateEfficiencyFISH . DesignProbes . TileSeqs AmplifyDNA . CalculateEfficiencyPCR . DesignPrimers . DesignSignatures . MeltDNA LearnTaxa . IdTaxa . Taxa-class ExtractGenes . FindGenes . FindNonCoding . Genes-class . LearnNonCoding . NonCoding-class . WriteGenes","code":""},{"path":[]},{"path":"/articles/DECIPHERing.html","id":"typical-installation-recommended","dir":"Articles","previous_headings":"Installation","what":"Typical Installation (recommended)","title":"Getting Started DECIPHERing","text":"Install latest version http://www.r-project.org/. Install DECIPHER R entering:","code":"> if (!requireNamespace(\"BiocManager\", quietly=TRUE)) +     install.packages(\"BiocManager\") > BiocManager::install(\"DECIPHER\")"},{"path":[]},{"path":"/articles/DECIPHERing.html","id":"all-platforms","dir":"Articles","previous_headings":"Installation > Manual Installation","what":"All platforms","title":"Getting Started DECIPHERing","text":"Install latest version http://www.r-project.org/. Install Biostrings R entering: Install RSQLite R entering: Download DECIPHER http://DECIPHER.codes.","code":"> if (!requireNamespace(\"BiocManager\", quietly=TRUE)) +     install.packages(\"BiocManager\") > BiocManager::install(\"Biostrings\") > install.packages(\"RSQLite\")"},{"path":"/articles/DECIPHERing.html","id":"mac-os-x","dir":"Articles","previous_headings":"Installation > Manual Installation","what":"Mac OS X","title":"Getting Started DECIPHERing","text":"First install Command Line Tools Apple, contains compliers required build packages Mac. , run: parallelization Mac OS X, extra steps required <http://mac.r-project.org/openmp/{enable OpenMP>} install. summary, run “clang -v” download corresponding LLVM tar.gz file. Run sudo tar command shown, add two lines \\(\\sim\\)/.R/Makevars file: CPPFLAGS += -Xclang -fopenmp\\ LDFLAGS += -lomp DECIPHER can built installed usual way via command line.","code":"> install.packages(\"<<path to Mac OS X DECIPHER.tgz>>\", repos=NULL)"},{"path":"/articles/DECIPHERing.html","id":"linux","dir":"Articles","previous_headings":"Installation > Manual Installation","what":"Linux","title":"Getting Started DECIPHERing","text":"shell enter:","code":"R CMD build --no-build-vignettes \"<<path to DECIPHER source>>\" R CMD INSTALL \"<<path to newly built DECIPHER.tar.gz>>\""},{"path":"/articles/DECIPHERing.html","id":"windows","dir":"Articles","previous_headings":"Installation > Manual Installation","what":"Windows","title":"Getting Started DECIPHERing","text":"Two options available: first simplest, requires pre-built binary (DECIPHER.zip). First Option: Install Rtools http://cran.r-project.org/bin/windows/Rtools/. sure check box says edit PATH installation. Open MS-DOS command prompt clicking Start -> Programs -> Accessories -> Command Prompt. command prompt enter:","code":"> install.packages(\"<<path to Windows DECIPHER.zip>>\", repos=NULL) R CMD build --no-build-vignettes \"<<path to DECIPHER source>>\" R CMD INSTALL \"<<path to newly built DECIPHER.zip>>\""},{"path":"/articles/DECIPHERing.html","id":"example-workflow","dir":"Articles","previous_headings":"","what":"Example Workflow","title":"Getting Started DECIPHERing","text":"get started need load DECIPHER package, automatically loads several required packages: Help function can accessed command : begin, can import FASTA, FASTQ, GenBank file sequence database. import sequences -memory database removed disconnect database. -memory databases useful temporary examples, typically specify path file want store database. especially case many sequences, might fit memory. example, use GenBank file included DECIPHER installation. must set sequences’ identifier importing Seqs2DB. identify sequences word “Bacteria”. identifier used many DECIPHER functions reference specific subset sequences database, can reset later time using number different methods: Now can view table information just added database web browser (Fig. 1): Suppose wanted count number bases sequence add information database: Next let’s identify sequences phylum update information database: can now look sequences belong phylum Bacteroidetes (Fig. 2): Let’s construct phylogenetic tree Bacteroidetes sequences (Fig. 3): created database -memory connecting “:memory:” . works fine small databases, necessary initialize larger databases quoted file path rather “:memory:”. Optionally, use command save -memory database file long term storage. sure change path names system replacing text inside quotes labeled “\\(<<\\)path …\\(>>\\)” actual path system. Finally, disconnect database connection. Since sequence database created temporary memory, information erased:","code":"library(DECIPHER) ## Loading required package: Biostrings ## Loading required package: BiocGenerics ##  ## Attaching package: 'BiocGenerics' ## The following objects are masked from 'package:stats': ##  ##     IQR, mad, sd, var, xtabs ## The following objects are masked from 'package:base': ##  ##     anyDuplicated, aperm, append, as.data.frame, basename, cbind, ##     colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ##     get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply, ##     match, mget, order, paste, pmax, pmax.int, pmin, pmin.int, ##     Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort, ##     table, tapply, union, unique, unsplit, which.max, which.min ## Loading required package: S4Vectors ## Loading required package: stats4 ##  ## Attaching package: 'S4Vectors' ## The following object is masked from 'package:utils': ##  ##     findMatches ## The following objects are masked from 'package:base': ##  ##     expand.grid, I, unname ## Loading required package: IRanges ## Loading required package: XVector ## Loading required package: GenomeInfoDb ##  ## Attaching package: 'Biostrings' ## The following object is masked from 'package:base': ##  ##     strsplit ## Loading required package: RSQLite ## Loading required package: parallel > ? DECIPHER # access a sequence file included in the package: gen <- system.file(\"extdata\", \"Bacteria_175seqs.gen\", package=\"DECIPHER\")  # connect to a database: dbConn <- dbConnect(SQLite(), \":memory:\")  # import the sequences into the sequence database Seqs2DB(gen, \"GenBank\", dbConn, \"Bacteria\") ##  Reading GenBank file chunk 1 ##  ## 175 total sequences in table Seqs. ## Time difference of 0.06 secs BrowseDB(dbConn) l <- IdLengths(dbConn) ## ================================================================================ ## Lengths counted for 175 sequences. ##  ## Time difference of 0.01 secs head(l) ##   standard nonstandard width ## 1     1222          13  1596 ## 2     1346           5  1596 ## 3     1323           3  1596 ## 4     1337           8  1596 ## 5     1318          25  1596 ## 6     1307           7  1596 Add2DB(l, dbConn, verbose=FALSE) BrowseDB(dbConn, maxChars=20) r <- IdentifyByRank(dbConn, level=3, add2tbl=TRUE) ##  ## Updating column: \"identifier\"... ## Formed 7 distinct groups. ## Added to table Seqs: \"identifier\". ## Time difference of 0.01 secs BrowseDB(dbConn, maxChars=20) dna <- SearchDB(dbConn, identifier=\"Bacteroidetes\") ## Search Expression: ## select row_names, sequence from _Seqs where row_names in (select row_names ## from Seqs where identifier is \"Bacteroidetes\") ##  ## DNAStringSet of length: 18 ## Time difference of 0 secs BrowseSeqs(subseq(dna, 140, 240)) > sqliteCopyDatabase(dbConn, \"<<path to database>>\") dbDisconnect(dbConn)"},{"path":"/articles/DesignMicroarray.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Design Microarray Probes","text":"document describes design validate sequence-specific probes synthesis onto DNA microarray. case study, tutorial focuses development microarray identify taxonomic groups based previously obtained 16S ribosomal RNA sequences. approach applied differentiate sequences representing number groups based shared region DNA. objective microarray probe design straightforward: determine set probes bind one group sequences (target consensus sequence) others (non-targets). Beginning set aligned DNA sequences, program chooses best set probes targeting consensus sequence. importantly, design algorithm able predict potential cross-hybridization probes may occur non-target sequence(s). integrated design approach enables characterizing probe set fabrication, assists analysis experimental results.","code":""},{"path":[]},{"path":"/articles/DesignMicroarray.html","id":"startup","dir":"Articles","previous_headings":"Getting Started","what":"Startup","title":"Design Microarray Probes","text":"get started need load DECIPHER package, automatically loads several required packages. Help DesignArray function can accessed : DECIPHER installed system, code example can obtained via:","code":"library(DECIPHER) ## Loading required package: Biostrings ## Loading required package: BiocGenerics ##  ## Attaching package: 'BiocGenerics' ## The following objects are masked from 'package:stats': ##  ##     IQR, mad, sd, var, xtabs ## The following objects are masked from 'package:base': ##  ##     anyDuplicated, aperm, append, as.data.frame, basename, cbind, ##     colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ##     get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply, ##     match, mget, order, paste, pmax, pmax.int, pmin, pmin.int, ##     Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort, ##     table, tapply, union, unique, unsplit, which.max, which.min ## Loading required package: S4Vectors ## Loading required package: stats4 ##  ## Attaching package: 'S4Vectors' ## The following object is masked from 'package:utils': ##  ##     findMatches ## The following objects are masked from 'package:base': ##  ##     expand.grid, I, unname ## Loading required package: IRanges ## Loading required package: XVector ## Loading required package: GenomeInfoDb ##  ## Attaching package: 'Biostrings' ## The following object is masked from 'package:base': ##  ##     strsplit ## Loading required package: RSQLite ## Loading required package: parallel > ? DesignArray > browseVignettes(\"DECIPHER\")"},{"path":"/articles/DesignMicroarray.html","id":"creating-a-sequence-database","dir":"Articles","previous_headings":"Getting Started","what":"Creating a Sequence Database","title":"Design Microarray Probes","text":"begin set aligned sequences belonging 16S rRNA several samples obtained drinking water distribution systems. sure change path names system replacing text inside quotes labeled “\\(<<\\)path …\\(>>\\)” actual path system. Next, two options importing sequences database: either save database file maintain database memory. build database memory small set sequences intend use database later:","code":"# specify the path to your sequence file: fas <- \"<<path to FASTA file>>\" # OR find the example sequence file used in this tutorial: fas <- system.file(\"extdata\", \"Bacteria_175seqs.fas\", package=\"DECIPHER\") # specify a path for where to write the sequence database dbConn <- \"<<path to write sequence database>>\" # OR create the sequence database in memory dbConn <- dbConnect(SQLite(), \":memory:\") Seqs2DB(fas, \"FASTA\", dbConn, \"uncultured bacterium\") ##  Reading FASTA file chunk 1 ##  ## 175 total sequences in table Seqs. ## Time difference of 0.05 secs"},{"path":"/articles/DesignMicroarray.html","id":"defining-groups","dir":"Articles","previous_headings":"Getting Started","what":"Defining Groups","title":"Design Microarray Probes","text":"point need define groups related sequences database just created. case wish cluster sequences groups 3% distance sequences. Now identified 100 operational taxonomic units (OTUs), must form set consensus sequences represent OTU.","code":"dna <- SearchDB(dbConn) ## Search Expression: ## select row_names, sequence from _Seqs where row_names in (select row_names ## from Seqs) ##  ## DNAStringSet of length: 175 ## Time difference of 0.01 secs dMatrix <- DistanceMatrix(dna, verbose=FALSE) clusters <- TreeLine(myDistMatrix=dMatrix, type=\"clusters\", cutoff=0.03, method=\"complete\", verbose=FALSE) Add2DB(clusters, dbConn, verbose=FALSE) conSeqs <- IdConsensus(dbConn, colName=\"cluster\", verbose=FALSE) dbDisconnect(dbConn) # name the sequences by their cluster number ns <- lapply(strsplit(names(conSeqs), \"_\", fixed=TRUE), `[`, 1) names(conSeqs) <- gsub(\"cluster\", \"\", unlist(ns), fixed=TRUE) # order the sequences by their cluster number o <- order(as.numeric(names(conSeqs))) conSeqs <- conSeqs[o]"},{"path":[]},{"path":"/articles/DesignMicroarray.html","id":"designing-the-probe-set","dir":"Articles","previous_headings":"Array Design and Validation Steps","what":"Designing the Probe Set","title":"Design Microarray Probes","text":"Next design optimal set 20 probes targeting OTU. Since 100 OTUs, process result set 2,000 probes. default, probes designed optimal length hybridization 46\\(^\\circ\\)C 10% (vol/vol) formamide. wish allow 2 permutations probe, potentially require space microarray. Since sequences span alignment, design probes alignment positions 120 1,450, region encompassed sequences. can see probe sequence, target site positioning, melt point (formamide), predicted cross-hybridization efficiency non-targets (mismatches). first probe targeting first consensus sequence (OTU #1) predicted 84% hybridization efficiency formamide concentration used experiment (10%). probe also predicted cross-hybridize OTU #5 59% hybridization efficiency. wished probe set synthesized onto microarray, need unique set probes. Note predictive model calibrated using NimbleGen microarrays. Although predictions likely similar microarray platforms, hybridization conditions always experimentally optimized.","code":"probes <- DesignArray(conSeqs, maxPermutations=2, numProbes=20,     start=120, end=1450, verbose=FALSE) dim(probes) ## [1] 2000   12 names(probes) ##  [1] \"name\"          \"start\"         \"length\"        \"start_aligned\" ##  [5] \"end_aligned\"   \"permutations\"  \"score\"         \"formamide\"     ##  [9] \"hyb_eff\"       \"target_site\"   \"probes\"        \"mismatches\" probes[1,] ##   name start length start_aligned end_aligned permutations        score ## 1    1     1     22           120         143            1 22.75502.... ##      formamide      hyb_eff            target_site ## 1 16.06832.... 84.26072.... GCATCGGAACGTGTCCTAAAGT ##                                       probes mismatches ## 1 ACTTTAGGACACGTTCCGATGCTTTTTTTTTTTTTTTTTTTT  5 (59.4%) u <- unique(unlist(strsplit(probes$probes, \",\", fixed=TRUE))) length(u) ## [1] 1899 head(u) ## [1] \"ACTTTAGGACACGTTCCGATGCTTTTTTTTTTTTTTTTTTTT\"   ## [2] \"GTATTAGCGCATCTTTCGATGCTTTTTTTTTTTTTTTTTTTT\"   ## [3] \"GTCTTTCGATCCCCTACTTTCCTCTTTTTTTTTTTTTTTTTTTT\" ## [4] \"GGCCGCTCCAAAAGCATAAGGTTTTTTTTTTTTTTTTTTTTT\"   ## [5] \"ATGGCAATTAATGACAAGGGTTGCTTTTTTTTTTTTTTTTTTTT\" ## [6] \"CAGTGTGGTTGGCCATCCTCTTTTTTTTTTTTTTTTTTTTT\""},{"path":"/articles/DesignMicroarray.html","id":"validating-the-probe-set","dir":"Articles","previous_headings":"Array Design and Validation Steps","what":"Validating the Probe Set","title":"Design Microarray Probes","text":"fabrication onto DNA microarray may useful predict whether probe set adequately discriminate OTUs. can accomplished simulating hybridization process multiple times incorporating error. begin converting predicted cross-hybridization efficiencies sparse matrix mathematically represents microarray (). rows matrix represent probe, columns matrix represent OTU. entries matrix therefore give hybridization efficiency probe OTU j. can neglect hybridization efficiencies less 5% likely hybridize insufficient brightness. multiply matrix amount (x) OTU present determine corresponding brightness (b) values probe. can add heteroskedastic error brightness values result accurate simulation (b = Ax + error). Furthermore, can introduce 5% rate probes hybridize randomly. Finally, can solve amount OTU present microarray solving Ax = b x using non-negative (x \\(\\ge\\) 0) least squares. Plotting expected amount versus predicted amount shows probe set may result small number false positives false negatives (Fig. 1). False negatives expected observations dashed threshold line, represents minimum amount required considered present. threshold lowered false negatives appear amount expected.","code":"A <- Array2Matrix(probes, verbose=FALSE) w <- which(A$x < 0.05) if (length(w) > 0) {     A$i <- A$i[-w]     A$j <- A$j[-w]     A$x <- A$x[-w] } # simulate the case where 10 present <- sample(length(conSeqs), floor(0.1*length(conSeqs))) x <- numeric(length(conSeqs)) x[present] <- abs(rnorm(length(present), sd=2))  # determine the predicted probe brightnesses based on the present OTUS background <- 0.2 b <- matrix(tapply(A$x[A$j]*x[A$j], A$i, sum), ncol=1) + background b <- b + rnorm(length(b), sd=0.2*b) # add 20 b <- b - background # background subtracted brightnesses  # add in a 5 bad_hybs <- sample(length(b), floor(0.05*length(b))) b[bad_hybs] <- abs(rnorm(length(bad_hybs), sd=max(b)/3)) # solve for the predicted amount of each OTU present on the array x_out <- NNLS(A, b, verbose=FALSE)"},{"path":"/articles/DesignMicroarray.html","id":"further-improving-the-result","dir":"Articles","previous_headings":"Array Design and Validation Steps","what":"Further Improving the Result","title":"Design Microarray Probes","text":"Least squares regression particularly sensitive outlier observations heteroskedastic noise. reason decrease effects outlier observations using weighted regression. iteration weights refined using residuals prior solution Ax = b. Weighted regression lowered threshold detection OTUs detectable (Fig. 2). However, false negatives still remain based simulation small amount expected. threshold lowered capture expected OTUs can determine false positive(s) result. false positive sequences substantially different nearest sequence present.","code":"# initialize weights to one: weights <- matrix(1, nrow=nrow(b), ncol=ncol(b)) # iteratively unweight observations with high residuals: for (i in 1:10) { # 10 iterations     weights <- weights*exp(-0.1*abs(x_out$residuals))     A_weighted <- A     A_weighted$x <- A$x*weights[A$i]     b_weighted <- b*weights     x_out <- NNLS(A_weighted, b_weighted, verbose=FALSE) } w <- which(x_out$x >= min(x_out$x[present])) w <- w[-match(present, w)] # false positives dMatrix <- DistanceMatrix(conSeqs, verbose=FALSE) # print distances of false positives to the nearest present OTU for (i in w)     print(min(dMatrix[i, present])) ## [1] 0.07703927 ## [1] 0.112588 ## [1] 0.08248233 ## [1] 0.03396524 ## [1] 0.06382979 ## [1] 0.0608565 ## [1] 0.1231603"},{"path":"/articles/DesignMicroarray.html","id":"extending-the-simulation","dir":"Articles","previous_headings":"Array Design and Validation Steps","what":"Extending the Simulation","title":"Design Microarray Probes","text":"simulation can repeated multiple times different initial conditions better approximate expected number false positives false negatives (Fig. 3). manner design parameters can iteratively optimized improve predicted specificity probe set based simulation results. fabrication, validation experiments using known samples used replace simulated brightness values.","code":"# simulate multiple cases where 10 iterations <- 100 b <- matrix(0, nrow=dim(b)[1], ncol=iterations) x <- matrix(0, nrow=length(conSeqs), ncol=iterations) for (i in 1:iterations) {     present <- sample(length(conSeqs), floor(0.1*length(conSeqs)))     x[present, i] <- abs(rnorm(length(present), sd=2))          # determine the predicted probe brightnesses based on the present OTUS     b[, i] <- tapply(A$x[A$j]*x[A$j, i], A$i, sum) + background     b[, i] <- b[, i] + rnorm(dim(b)[1], sd=0.2*b[, i]) # add 20     b[, i] <- b[, i] - background # background subtracted brightnesses          # add in a 5     bad_hybs <- sample(dim(b)[1], floor(0.05*length(b[, i])))     b[bad_hybs, i] <- abs(rnorm(length(bad_hybs), sd=max(b[, i])/3)) }  x_out <- NNLS(A, b, verbose=FALSE)"},{"path":"/articles/DesignPrimers.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Design Group-Specific Primers","text":"document describes design group-specific primers using DECIPHER package use DesignPrimers function. case study, tutorial focuses Internal Transcribed Spacer () fully sequenced genomes belonging different species genus Streptomyces. resides chromosome genes coding 16S 23S ribosomal RNA. examples document directed towards finding primers target single species Streptomyces among number closely related Streptomyces species. However, similar strategy used set aligned sequences separated groups. example, genus-specific primers targeting 16S gene designed program provided online http://DECIPHER.codes. database aligned DNA sequences separated groups used input program. First function TileSeqs used pre-process sequences overlapping tiles, serve template DNA primer design. Second, DesignPrimers function determines set possible primers meet certain design constraints, ability efficiently amplify group interest specified experimental conditions. Next, complete set primers scored predicted potential cross-amplify DNA belonging groups. Finally, optimal set forward reverse primers chosen used PCR experiment enrich DNA interest sample containing DNA multiple groups.","code":""},{"path":"/articles/DesignPrimers.html","id":"the-objective-of-primer-design","dir":"Articles","previous_headings":"","what":"The Objective of Primer Design","title":"Design Group-Specific Primers","text":"objective primer design straightforward: determine set forward reverse primers amplify one group sequences (target) others (non-targets). primer set unattainable goal becomes accurately predict potential cross-amplification non-target groups. knowledge enables educated assessment different primer options used minimize non-target interference. chosen primers synthesized experimentally characterized PCR quantitative PCR (qPCR). Possible applications include: allele specific PCR quantifying subset organisms sample enriching DNA target group downstream sequencing. Improved specificity target group achieved two ways: 1) decreasing hybridization efficiency, 2) minimizing elongation efficiency primer non-target DNA. Hybridization efficiency theoretical variable represents fraction DNA template bound primer annealing step PCR thermal cycling. manner, mismatches primer DNA templates utilized lower affinity primers non-target DNA. Elongation efficiency represents efficiency DNA polymerase initiating extension DNA template mismatched 3’ primer terminus, measured relative perfectly matched primer’s ability elongate. Mismatches near 3’ end primer used hinder extension non-target DNA templates thereby increasing specificity primers target DNA. Therefore, model terminal mismatches offers dual benefits decreased hybridization elongation efficiency, allows accurate predictions amplification efficiency increased specificity target group.","code":""},{"path":[]},{"path":"/articles/DesignPrimers.html","id":"installing-oligoarrayaux","dir":"Articles","previous_headings":"Getting Started","what":"Installing OligoArrayAux","title":"Design Group-Specific Primers","text":"program OligoArrayAux (http://www.unafold.org/Dinamelt/software/oligoarrayaux.php) used predict hybridization efficiency must installed location accessible system. example, following code print installed OligoArrayAux version executed R console:","code":"system(\"hybrid-min -V\")"},{"path":"/articles/DesignPrimers.html","id":"start-up","dir":"Articles","previous_headings":"Getting Started","what":"Start up","title":"Design Group-Specific Primers","text":"get started need load DECIPHER package, automatically loads several required packages. Help DesignPrimers function can accessed : DECIPHER installed system, code example can obtained via:","code":"library(DECIPHER) ## Loading required package: Biostrings ## Loading required package: BiocGenerics ##  ## Attaching package: 'BiocGenerics' ## The following objects are masked from 'package:stats': ##  ##     IQR, mad, sd, var, xtabs ## The following objects are masked from 'package:base': ##  ##     anyDuplicated, aperm, append, as.data.frame, basename, cbind, ##     colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ##     get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply, ##     match, mget, order, paste, pmax, pmax.int, pmin, pmin.int, ##     Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort, ##     table, tapply, union, unique, unsplit, which.max, which.min ## Loading required package: S4Vectors ## Loading required package: stats4 ##  ## Attaching package: 'S4Vectors' ## The following object is masked from 'package:utils': ##  ##     findMatches ## The following objects are masked from 'package:base': ##  ##     expand.grid, I, unname ## Loading required package: IRanges ## Loading required package: XVector ## Loading required package: GenomeInfoDb ##  ## Attaching package: 'Biostrings' ## The following object is masked from 'package:base': ##  ##     strsplit ## Loading required package: RSQLite ## Loading required package: parallel library(dplyr) ##  ## Attaching package: 'dplyr' ## The following objects are masked from 'package:Biostrings': ##  ##     collapse, intersect, setdiff, setequal, union ## The following object is masked from 'package:GenomeInfoDb': ##  ##     intersect ## The following object is masked from 'package:XVector': ##  ##     slice ## The following objects are masked from 'package:IRanges': ##  ##     collapse, desc, intersect, setdiff, slice, union ## The following objects are masked from 'package:S4Vectors': ##  ##     first, intersect, rename, setdiff, setequal, union ## The following objects are masked from 'package:BiocGenerics': ##  ##     combine, intersect, setdiff, union ## The following objects are masked from 'package:stats': ##  ##     filter, lag ## The following objects are masked from 'package:base': ##  ##     intersect, setdiff, setequal, union > ? DesignPrimers > browseVignettes(\"DECIPHER\")"},{"path":"/articles/DesignPrimers.html","id":"creating-a-sequence-database","dir":"Articles","previous_headings":"Getting Started","what":"Creating a Sequence Database","title":"Design Group-Specific Primers","text":"begin set aligned sequences belonging Internal Transcribed Spacer () several Streptomyces chromosomes. wish determine region enough variability used distinguishing closely related species qPCR. example uses FASTA sequence file included part DECIPHER package, follow along FASTA file aligned sequences. sure change path names system replacing text inside quotes labeled “\\(<<\\)path …\\(>>\\)” actual path system. Next, two options importing sequences database: either save database file maintain database memory. build database memory small set sequences intend use database later:","code":"# specify the path to your sequence file: fas <- \"<<path to FASTA file>>\" # OR find the example sequence file used in this tutorial: fas <- system.file(\"extdata\", \"Streptomyces_ITS_aligned.fas\", package=\"DECIPHER\") # specify a path for where to write the sequence database dbConn <- \"<<path to write sequence database>>\" # OR create the sequence database in memory dbConn <- dbConnect(SQLite(), \":memory:\") Seqs2DB(fas, \"FASTA\", dbConn, \"Streptomyces\") ##  Reading FASTA file chunk 1 ##  ## 88 total sequences in table Seqs. ## Time difference of 0.03 secs"},{"path":"/articles/DesignPrimers.html","id":"defining-groups","dir":"Articles","previous_headings":"Getting Started","what":"Defining Groups","title":"Design Group-Specific Primers","text":"point need define groups related sequences database just created. case wish define unique group sequences belonging species Streptomyces. order accomplish must parse information contained description FASTA sequence record just imported. Alternatively use functions IdentifyByRank, FormGroups, Clusterize, TreeLine define groups. Now 19 different species names, must add database identifier sequence.","code":"# get the FASTA record description desc <- dbGetQuery(dbConn, \"select description from Seqs\") # parse the sequence description to obtain the species name desc <- unlist(lapply(strsplit(desc$description, \"Streptomyces \", fixed=TRUE),     function(x) return(x[length(x)]))) desc <- gsub(\"sp. \", \"\", desc, perl=TRUE) desc <- gsub(\"sp_\", \"\", desc, perl=TRUE) desc <- unlist(lapply(strsplit(desc, \" \", fixed=TRUE), function(x) return(x[1]))) unique(desc) ##  [1] \"albus\"             \"clavuligerus\"      \"ghanaensis\"        ##  [4] \"griseoflavus\"      \"lividans\"          \"pristinaespiralis\" ##  [7] \"Mg1\"               \"SPB78\"             \"AA4\"               ## [10] \"SPB74\"             \"SirexAA-E\"         \"scabiei\"           ## [13] \"griseus\"           \"coelicolor\"        \"cattleya\"          ## [16] \"bingchenggensis\"   \"avermitilis\"       \"C\"                 ## [19] \"Tu6071\" Add2DB(data.frame(identifier=desc, stringsAsFactors=FALSE), dbConn) ## Expression: ## update Seqs set identifier = :identifier where row_names = :row_names ##  ## Added to table Seqs:  \"identifier\". ##  ## Time difference of 0 secs"},{"path":[]},{"path":"/articles/DesignPrimers.html","id":"tiling-sequences","dir":"Articles","previous_headings":"Primer Design Steps","what":"Tiling Sequences","title":"Design Group-Specific Primers","text":"continue creating set k-mers, known “tiles”, represent sequences group. must make several decisions affect primer design future. defaults create tiles length 26-27 nucleotides 10 permutations represent least 90% permutations present target site. parameters generally fit primer designs, recommended read help file TileSeqs function make sure desired. save resulting tiles back database new table named “Tiles” case wish access future. Now can examine first tiles using head command. see tiles flagged misprime=TRUE, case caused permutations target site containing degenerate bases (N’s). Ambiguity codes used primer design thus excluded consideration potential target sites primers. reasons mispriming include runs single base di-nucleotide repeats, increase primer entropy result non-specific annealing. least minCoverage fraction group represented maxPermutations misprime also marked TRUE.","code":"tiles <- TileSeqs(dbConn, add2tbl=\"Tiles\", minCoverage=1) ## ================================================================================ ##  ## Time difference of 8.23 secs head(tiles) ##   row_names start end start_aligned end_aligned misprime width    id coverage ## 1         1     1  27             1          28     TRUE   627 albus      0.6 ## 2         2     2  28             2          29     TRUE   627 albus      0.6 ## 3         3     3  29             3          30     TRUE   627 albus      0.6 ## 4         4     4  30             4          31     TRUE   627 albus      0.6 ## 5         5     5  31             5          32    FALSE   627 albus      1.0 ## 6         6     6  32             6          33    FALSE   627 albus      1.0 ##   groupCoverage                 target_site ## 1           0.6 TGTACACACCGCCCGTCACGTCACGAA ## 2           0.6 GTACACACCGCCCGTCACGTCACGAAA ## 3           0.6 TACACACCGCCCGTCACGTCACGAAAG ## 4           0.6 ACACACCGCCCGTCACGTCACGAAAGT ## 5           1.0 CACACCGCCCGTCACGTCACGAAAGTC ## 6           1.0 ACACCGCCCGTCACGTCACGAAAGTCG"},{"path":"/articles/DesignPrimers.html","id":"designing-all-possible-primers","dir":"Articles","previous_headings":"Primer Design Steps","what":"Designing All Possible Primers","title":"Design Group-Specific Primers","text":"Next wish design primers group S. avermitilis. example, begin designing primers every possible target site meet certain design criteria. example, default reagent conditions defined : 3 mM [dNTPs], 70 mM [\\(K^{+}\\)], 3 mM [\\(Mg^{2+}\\)], primer concentration 400 nM. Also, defaults specify 4 forward reverse primer permutations can used long cover 90% variants present target site. case wish encompass 100% species’ sequences, use minCoverage = 1 minGroupCoverage = 1 rather default 90% 20%, respectively. default parameters include annealing temperature \\(64^{\\circ}C\\), minimum maximum product size 75 1,200 base pairs, respectively. Note input parameters DesignPrimers carefully considered order adequately represent actual PCR conditions used. worth noting estimates elongation efficiency applicable standard Taq DNA Polymerase, apply high-fidelity polymerases. polymerases, commonly used cloning sequencing applications, 3’ 5’ exonuclease activity attempt remove mismatches located primer’s 3’ terminus. intend use high-fidelity polymerase specify taqEfficiency=FALSE issuing commands DesignPrimers CalculateEfficiencyPCR. case elongation efficiency included estimate amplification efficiency hybridization efficiency used. command designs individual primers different command required design pairs forward reverse primers (see ). Let’s examine first primer available, 499 potential target sites. can see one permutation required cover 100% species target site. However, score primer relatively bad (negative) high efficiency amplification predicted groups (.e., species). predicted forward reverse primer efficiencies respectively 84.4% 88.7% default annealing temperature \\(64^{\\circ}C\\). efficiency metric useful approximates fraction available templates copied cycle PCR. mismatches_forward mismatches_reverse fields predicted amplification efficiency using primers non-target group shown. can see non-target groups predicted efficiency target, DNA perfectly matches primer sequences.","code":"primers <- DesignPrimers(tiles, identifier=\"avermitilis\",     minCoverage=1, minGroupCoverage=1) ##  ## avermitilis (499 candidate primers): ## ================================================================================ ##  ## Time difference of 4.9 secs primers |> dplyr::as_tibble() ## # A tibble: 499 × 17 ##    identifier  start_forward start_reverse start_aligned_forward ##    <I<chr>>         <I<int>>      <I<dbl>>              <I<int>> ##  1 avermitilis            11            17                     1 ##  2 avermitilis            11            19                     2 ##  3 avermitilis            11            19                     3 ##  4 avermitilis            12            20                     4 ##  5 avermitilis            12            21                     5 ##  6 avermitilis            13            22                     6 ##  7 avermitilis            14            23                     7 ##  8 avermitilis            14            24                     8 ##  9 avermitilis            16            25                     9 ## 10 avermitilis            16            26                    10 ## # ℹ 489 more rows ## # ℹ 13 more variables: start_aligned_reverse <I<int>>, ## #   permutations_forward <I<dbl>>, permutations_reverse <I<dbl>>, ## #   score_forward <I<dbl>>, score_reverse <I<dbl>>, forward_primer <chr[,4]>, ## #   reverse_primer <chr[,4]>, forward_efficiency <dbl[,4]>, ## #   reverse_efficiency <dbl[,4]>, forward_coverage <dbl[,4]>, ## #   reverse_coverage <dbl[,4]>, mismatches_forward <I<chr>>, …"},{"path":"/articles/DesignPrimers.html","id":"designing-the-best-possible-primer-set","dir":"Articles","previous_headings":"Primer Design Steps","what":"Designing the Best Possible Primer Set","title":"Design Group-Specific Primers","text":"potentially examine primers one--one find best forward reverse primers amplify target group. Another option allow program find best primer sets searching combinations forward reverse primers. simply change parameter numPrimerSets positive number default zero. DesignPrimers function search best forward reverse primers find option minimizes forward reverse primer overlap. Furthermore, program search potential target sites within 20 nucleotides primer might bind upstream downstream target site alignment. Now row output (primers) contains one pair forward reverse primers. Examining output see several primer sets predicted amplify S. avermitilis species, shown empty column mismatches_set.","code":"primers <- DesignPrimers(tiles, identifier=\"avermitilis\", minCoverage=1,     minGroupCoverage=1, numPrimerSets=5, maxSearchSize=20) ##  ## avermitilis (499 candidate primers): ## ================================================================================ ## Determining Best Primer Pairs: ## ================================================================================ ##  ## Time difference of 6.7 secs head(primers) |> as_tibble() ## # A tibble: 5 × 20 ##   identifier  start_forward start_reverse product_size start_aligned_forward ##   <I<chr>>         <I<int>>      <I<dbl>>     <I<dbl>>              <I<int>> ## 1 avermitilis           245           325           81                   247 ## 2 avermitilis           245           322           78                   247 ## 3 avermitilis           245           326           82                   247 ## 4 avermitilis           245           324           80                   247 ## 5 avermitilis           245           324           80                   247 ## # ℹ 15 more variables: start_aligned_reverse <I<int>>, ## #   permutations_forward <I<dbl>>, permutations_reverse <I<dbl>>, ## #   score_forward <I<dbl>>, score_reverse <I<dbl>>, score_set <I<dbl>>, ## #   forward_primer <I<chr[,4]>[,4]>, reverse_primer <I<chr[,4]>[,4]>, ## #   forward_efficiency <I<dbl[,4]>[,4]>, reverse_efficiency <I<dbl[,4]>[,4]>, ## #   forward_coverage <I<dbl[,4]>[,4]>, reverse_coverage <I<dbl[,4]>[,4]>, ## #   mismatches_forward <I<chr>>, mismatches_reverse <I<chr>>, …"},{"path":[]},{"path":"/articles/DesignPrimers.html","id":"denaturation-plot","dir":"Articles","previous_headings":"Additional Primer Analysis","what":"Denaturation Plot","title":"Design Group-Specific Primers","text":"choosing forward reverse primers can graph melt curves order predict behave different annealing temperatures. Recall example single forward reverse primer permutation necessary cover entire group.  originally designed primers least 80% minEfficiency annealing temperature \\(64^{\\circ}C\\), clear graph primers predicted similarly high efficiencies temperature. However, appears forward primer denature quickly reverse primer temperature increased. due fact primers different enthalpy entropy, similar free energies duplex formation near annealing temperature melt curves intersect.","code":"temp_range <- 60:75 ps <- c(\"CGTTGATTATTCGGCACACTCGAC\", \"CCCTCGCCCTCCCATGT\") # forward and reverse f <- function(temp) {   CalculateEfficiencyPCR(ps, reverseComplement(DNAStringSet(ps)),                          temp, P=4e-7, ions=.225) } efficiency <- matrix(unlist(lapply(temp_range, f)), ncol=2, byrow=TRUE) plot(temp_range, efficiency[,1], ylim=c(0,1), ylab=\"Hybridization Efficiency\",      xlab=expression(paste(\"Temperature (\", degree, \"C)\", sep=\"\")),      type=\"l\", lwd=2, col=\"Blue\", main=\"Denaturation Plot\") lines(temp_range, efficiency[,2], col=\"Red\", lwd=2) abline(h=0.5, lty=2, lwd=2, col=\"Orange\") abline(v=64, lty=2, lwd=2, col=\"Green\") legend(\"topright\", legend=c(\"Forward Primer\", \"Reverse Primer\", \"50% Efficiency\",                             \"Annealing Temperature\"), col=c(\"Blue\", \"Red\", \"Orange\", \"Green\"),        lwd=c(2, 2, 2, 2), lty=c(1, 1, 2, 2))"},{"path":"/articles/DesignPrimers.html","id":"visualizing-the-target-sites","dir":"Articles","previous_headings":"Additional Primer Analysis","what":"Visualizing the Target Sites","title":"Design Group-Specific Primers","text":"Often useful visualize sequence region primers anneal target non-targets side--side. can accomplish looking amplicon sequences highlighting region primers. First query database sequences interest proceed trim region around amplicon given start_aligned_forward start_aligned_reverse outputs DesignPrimers. Next name order unique sequences set target (S. avermitilis) appears top. can use function BrowseSeqs visualize target site primer amplicon. command open new window default web browser. top sequence shows target (S. avermitilis), primer’s target site colored. can highlight target sequence mismatches colored non-target sequences. clear target site chosen, Streptomyces species multiple mismatches forward reverse primers. non-target mismatches, especially located nearest 3’ end (towards center amplicon), act lower hybridization elongation efficiency non-target amplification.","code":"dna <- SearchDB(dbConn) ## Search Expression: ## select row_names, sequence from _Seqs where row_names in (select row_names ## from Seqs) ##  ## DNAStringSet of length: 88 ## Time difference of 0 secs dbDisconnect(dbConn) amplicon <- subseq(dna, 247, 348) names(amplicon) <- desc # only show unique sequences u_amplicon <- unique(amplicon) names(u_amplicon) <- names(amplicon)[match(u_amplicon, amplicon)] amplicon <- u_amplicon # move the target group to the top w <- which(names(amplicon)==\"avermitilis\") amplicon <- c(amplicon[w], amplicon[-w]) BrowseSeqs(amplicon, colorPatterns=c(4, 27, 76, 94), highlight=1)"},{"path":"/articles/DesignPrimers.html","id":"finishing-up","dir":"Articles","previous_headings":"Additional Primer Analysis","what":"Finishing Up","title":"Design Group-Specific Primers","text":"Finally, can order forward reverse primers synthesis try PCR reaction! forward reverse primers synthesized orientation sense listed output (primers). Initially may useful perform temperature gradient PCR reaction target DNA order experimentally determine melt point. example, case run several reactions target species increasing temperature, \\(56^{\\circ}C\\) \\(72^{\\circ}C\\). annealing temperature increased hybridization efficiency eventually decrease amplification observed. subsequent experiments annealing temperature set just highest temperature robust amplification observed.","code":""},{"path":"/articles/DesignPrimers.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session Information","title":"Design Group-Specific Primers","text":"output vignette produced following conditions:","code":"sessionInfo() ## R version 4.3.1 (2023-06-16) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.3 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0  ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0 ##  ## locale: ##  [1] LC_CTYPE=zh_CN.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=zh_CN.UTF-8        LC_COLLATE=zh_CN.UTF-8     ##  [5] LC_MONETARY=zh_CN.UTF-8    LC_MESSAGES=zh_CN.UTF-8    ##  [7] LC_PAPER=zh_CN.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=zh_CN.UTF-8 LC_IDENTIFICATION=C        ##  ## time zone: Asia/Shanghai ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] parallel  stats4    stats     graphics  grDevices utils     datasets  ## [8] methods   base      ##  ## other attached packages: ## [1] dplyr_1.1.2         DECIPHER_2.29.1     RSQLite_2.3.1       ## [4] Biostrings_2.68.1   GenomeInfoDb_1.36.1 XVector_0.40.0      ## [7] IRanges_2.34.1      S4Vectors_0.38.1    BiocGenerics_0.46.0 ##  ## loaded via a namespace (and not attached): ##  [1] utf8_1.2.3              sass_0.4.7              generics_0.1.3          ##  [4] bitops_1.0-7            stringi_1.7.12          digest_0.6.33           ##  [7] magrittr_2.0.3          evaluate_0.21           fastmap_1.1.1           ## [10] blob_1.2.4              rprojroot_2.0.3         jsonlite_1.8.7          ## [13] DBI_1.1.3               fansi_1.0.4             purrr_1.0.2             ## [16] textshaping_0.3.6       jquerylib_0.1.4         cli_3.6.1               ## [19] rlang_1.1.1             crayon_1.5.2            bit64_4.0.5             ## [22] cachem_1.0.8            yaml_2.3.7              tools_4.3.1             ## [25] memoise_2.0.1           GenomeInfoDbData_1.2.10 vctrs_0.6.3             ## [28] R6_2.5.1                lifecycle_1.0.3         zlibbioc_1.46.0         ## [31] stringr_1.5.0           fs_1.6.3                bit_4.0.5               ## [34] ragg_1.2.5              pkgconfig_2.0.3         desc_1.4.2              ## [37] pkgdown_2.0.7           bslib_0.5.1             pillar_1.9.0            ## [40] glue_1.6.2              systemfonts_1.0.4       highr_0.10              ## [43] tidyselect_1.2.0        tibble_3.2.1            xfun_0.40               ## [46] rstudioapi_0.15.0       knitr_1.43              htmltools_0.5.6         ## [49] rmarkdown_2.24          compiler_4.3.1          RCurl_1.98-1.12"},{"path":"/articles/DesignProbes.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Design Group-Specific FISH Probes","text":"document describes design group-specific FISH probes using DECIPHER package use DesignProbes function. Fluorescent -Situ Hybridization (FISH) laboratory technique enables visualizing specific microorganisms natural environment using fluorescent microscopy. case study, tutorial focuses small-subunit ribosomal RNA (SSU rRNA) collection bacteria found drinking water. describe design probes targeting group interest cross-hybridize bacteria sample. similar strategy used set aligned sequences separated groups. example, genus-specific probes designed program target named bacteria archaea genera provided online http://DECIPHER.codes/16SOligos.html. database aligned DNA sequences separated groups used input program. First function TileSeqs used pre-process sequences overlapping tiles, serve template DNA probe design. Second, DesignProbes function determines set possible probes meet certain design constraints, ability hybridize group interest specified experimental conditions. Next, complete set probes scored potential cross-hybridize sequences groups including comprehensive database non-target sequences. Finally, optimal set dual probes chosen used FISH experiment identify microbes interest.","code":""},{"path":"/articles/DesignProbes.html","id":"the-objective-of-fish-probe-design","dir":"Articles","previous_headings":"","what":"The Objective of FISH Probe Design","title":"Design Group-Specific FISH Probes","text":"objective FISH probe design balance sensitivity probe target group sequences, simultaneously maximizing specificity prevent cross-hybridizations non-target groups. fundamental trade-, probe weak bind target, strong also bind non-targets. balancing act complicated difficulty accurately predicting binding strength probe variety potential target non-target sequences. confront challenge, DesignProbes uses state art model probe hybridization presence denaturant formamide. model, implemented function CalculateEfficiencyFISH, used conjunction reasonable safety factors minimize need experimental optimization. cases desired level specificity achieved, DesignProbes predicts degree potential cross-hybridization non-target groups. single probe insufficient, dual probes distinct colors can employed increase specificity target group. DesignProbes choose optimal combination dual probes minimize cross-hybridization overlap. experiment, combination individual probe colors provides additional assurance positive identification. example, one probe labeled green (e.g., fluorescein) labeled red (e.g., Cy3) hybridization probes point appear yellow.","code":""},{"path":[]},{"path":"/articles/DesignProbes.html","id":"installing-oligoarrayaux","dir":"Articles","previous_headings":"Getting Started","what":"Installing OligoArrayAux","title":"Design Group-Specific FISH Probes","text":"program OligoArrayAux (http://www.unafold.org/Dinamelt/software/oligoarrayaux.php) used predict hybridization efficiency must installed location accessible system. example, following code print installed OligoArrayAux version executed R console:","code":"system(\"hybrid-min -V\") hybrid-min (OligoArrayAux) 3.8 By Nicholas R. Markham and Michael Zuker Copyright (C) 2006 Rensselaer Polytechnic Institute Troy, NY 12810-3590 USA"},{"path":"/articles/DesignProbes.html","id":"startup","dir":"Articles","previous_headings":"Getting Started","what":"Startup","title":"Design Group-Specific FISH Probes","text":"{#sec:startup} get started need load DECIPHER package, automatically loads several required packages. Help DesignProbes function can accessed : DECIPHER installed system, code example can obtained via:","code":"library(DECIPHER) ## Loading required package: Biostrings ## Loading required package: BiocGenerics ##  ## Attaching package: 'BiocGenerics' ## The following objects are masked from 'package:stats': ##  ##     IQR, mad, sd, var, xtabs ## The following objects are masked from 'package:base': ##  ##     anyDuplicated, aperm, append, as.data.frame, basename, cbind, ##     colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ##     get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply, ##     match, mget, order, paste, pmax, pmax.int, pmin, pmin.int, ##     Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort, ##     table, tapply, union, unique, unsplit, which.max, which.min ## Loading required package: S4Vectors ## Loading required package: stats4 ##  ## Attaching package: 'S4Vectors' ## The following object is masked from 'package:utils': ##  ##     findMatches ## The following objects are masked from 'package:base': ##  ##     expand.grid, I, unname ## Loading required package: IRanges ## Loading required package: XVector ## Loading required package: GenomeInfoDb ##  ## Attaching package: 'Biostrings' ## The following object is masked from 'package:base': ##  ##     strsplit ## Loading required package: RSQLite ## Loading required package: parallel > ? DesignProbes > browseVignettes(\"DECIPHER\")"},{"path":"/articles/DesignProbes.html","id":"creating-a-sequence-database","dir":"Articles","previous_headings":"Getting Started","what":"Creating a Sequence Database","title":"Design Group-Specific FISH Probes","text":"begin set aligned 16S sequences representing variety bacteria collected drinking water samples. wish design probes targeting genus Sphingopyxis, common organism detected drinking water distribution systems. example uses GenBank sequence file included part DECIPHER package, follow along GenBank, FASTA, FASTQ file aligned sequences. sure change path names system replacing text inside quotes labeled “\\(<<\\)path …\\(>>\\)” actual path system. Next, two options importing sequences database: either save database file maintain database memory. build database memory small set sequences intend use database later:","code":"# specify the path to your sequence file: gb <- \"<<path to GenBank file>>\" # OR find the example sequence file used in this tutorial: gb <- system.file(\"extdata\", \"Bacteria_175seqs.gen\", package=\"DECIPHER\") # specify a path for where to write the sequence database dbConn <- \"<<path to write sequence database>>\" # OR create the sequence database in memory dbConn <- dbConnect(SQLite(), \":memory:\") Seqs2DB(gb, \"GenBank\", dbConn, \"Bacteria\") ##  Reading GenBank file chunk 1 ##  ## 175 total sequences in table Seqs. ## Time difference of 0.08 secs"},{"path":"/articles/DesignProbes.html","id":"defining-groups","dir":"Articles","previous_headings":"Getting Started","what":"Defining Groups","title":"Design Group-Specific FISH Probes","text":"point need define groups related sequences database just created. case wish define phylogenetic groups based taxonomic information included original GenBank file. advantage using GenBank file taxonomic information automatically imported ORGANISM field “rank” column sequence database. importing FASTA FASTQ file taxonomic information must come another source, parsing sequence identifiers building tree function TreeLine. case GenBank file, “rank” column can used function IdentifyByRank identify groups taxonomic level (e.g., genus).","code":"ids <- IdentifyByRank(dbConn, level=Inf, add2tbl=TRUE) ##  ## Updating column: \"identifier\"... ## Formed 72 distinct groups. ## Added to table Seqs: \"identifier\". ## Time difference of 0.01 secs"},{"path":[]},{"path":"/articles/DesignProbes.html","id":"tiling-sequences","dir":"Articles","previous_headings":"Probe Design Steps","what":"Tiling Sequences","title":"Design Group-Specific FISH Probes","text":"continue creating set k-mers, known “tiles”, represent sequences group. must make several decisions affect probe design future. defaults create tiles length 26-27 nucleotides 10 permutations represent least 90% permutations present target site. parameters generally fit probe designs, recommended read help file TileSeqs function make sure desired. save resulting tiles back database new table named “Tiles” case wish access future.","code":"tiles <- TileSeqs(dbConn, add2tbl=\"Tiles\") |===========================================================================| 100%  Time difference of 572.06 secs"},{"path":"/articles/DesignProbes.html","id":"designing-all-possible-probes","dir":"Articles","previous_headings":"Probe Design Steps","what":"Designing All Possible Probes","title":"Design Group-Specific FISH Probes","text":"Next wish design probes targeting 5 sequences identified belonging genus Sphingopyxis. example, begin designing probes every possible target site meet certain design criteria. default, allow 4 probe permutations long cover 90% permutations present target site. Note input parameters DesignProbes carefully considered order adequately represent experimental conditions used. example, limit target sites alignment positions 120 1,450 region shared sequences. can now examine top-scoring probe maximal sensitivity specificity target group. best probe 678 candidate target sites three permutations, formamide melt points (FAm) 35% 39% [FA] (v/v). three permutations can represented single consensus probe: Based column mismatches, probe two predicted cross-hybridizations groups sequence set. groups, unclassified Sphingomonadaceae unclassified Sphingomonadales, predicted 63.2% 9.1% hybridization efficiency equilibrium hybridization buffer 35% [FA] (v/v). first non-target exactly Gibb’s free energy perfect match probe. Note formamide melt point (FAm) 4.1% greater probe permutation lowest melt point, limiting factor experiment. second probe 6.2 kcal/mol greater Gibb’s free energy formamide melt point 17.8% [FA] less probe target. can examine predicted melt curve probes target non-target:","code":"probes <- DesignProbes(tiles, identifier=\"Sphingopyxis\",     start=120, end=1450) Sphingopyxis (678):   |===========================================================================| 100%  Time difference of 250 secs o <- order(probes$score, decreasing=TRUE) probes[o[1],] identifier start start_aligned permutations 826 Sphingopyxis   859          1019            3            score                 probe.1 826 -1.43876.... CCGCGATTAGGATGTCAAACGCT                     probe.2                 probe.3 probe.4 826 CCGCGATCAGGATGTCAAATGCT CCGCGATCAGGATGTCAAACGCT    <NA>     efficiency.1 efficiency.2 efficiency.3 efficiency.4 826    0.5014489    0.5506237    0.6315190           NA        FAm.1    FAm.2    FAm.3    FAm.4 coverage.1 826 35.04488 36.57339 39.17166       NA        0.4     coverage.2 coverage.3 coverage.4 826        0.2        0.4         NA mismatches 826 unclassified_Sphingomonadaceae (63.2 4.1 unclassified_Sphingomonadales (9.1 -17.8 ConsensusSequence(DNAStringSet(probes[o[1], \"probe\"][1:3])) A DNAStringSet instance of length 1     width seq [1]    23 CCGCGATYAGGATGTCAAAYGCT FA_range <- 0:70 # [FA] ( probe <- probes$probe[o[1], 1:3] targets <- reverseComplement(DNAStringSet(probe)) f <- function(FA)     CalculateEfficiencyFISH(probe, targets,         temp=46, P=250e-9, ions=1, FA)[, \"HybEff\"] efficiency <- matrix(unlist(lapply(FA_range, f)), ncol=3, byrow=TRUE) matplot(FA_range, efficiency, ylim=c(0,1), ylab=\"Hybridization Efficiency\",     xlab=expression(paste(\"[Formamide] (     type=\"l\", lwd=2, col=\"Blue\", main=\"Formamide Curve\", lty=1)  nontargets <- DNAStringSet(c(\"AGCGTTTGACATCCTGATCGCGG\",     \"AGCTTTTGACATCCCGGTCGCGG\")) f <- function(FA)     CalculateEfficiencyFISH(probe[3:2], nontargets,         temp=46, P=250e-9, ions=1, FA)[, \"HybEff\"] efficiency <- matrix(unlist(lapply(FA_range, f)), ncol=2, byrow=TRUE) matlines(FA_range, efficiency, col=\"Red\", lwd=2, lty=3)  abline(h=0.5, lty=2, lwd=2, col=\"Orange\") abline(v=35, lty=2, lwd=2, col=\"Green\") legend(\"topright\", legend=c(\"Targets\", \"Non-Targets\", \"50     \"Experimental [FA]\"), col=c(\"Blue\", \"Red\", \"Orange\", \"Green\"),     lwd=c(2, 2, 2, 2), lty=c(1, 3, 2, 2))"},{"path":"/articles/DesignProbes.html","id":"finding-non-targets-in-a-comprehensive-reference-database","dir":"Articles","previous_headings":"Probe Design Steps","what":"Finding Non-targets in a Comprehensive Reference Database","title":"Design Group-Specific FISH Probes","text":"now important find potential non-targets included sequence set used design. purpose can either build new comprehensive reference database, download one online http://DECIPHER.cee.wisc.edu/Download.html. reference database must unzipped download. database includes pre-processed set tiles, generated manner shown , can found table named “Tiles”. sure change path names system replacing text inside quotes labeled “\\(<<\\)path …\\(>>\\)” actual path system. Next can use tiles find hits comprehensive database non-targets may included sequence set used design. step unnecessary comprehensive sequence set used design steps . used reduced set non-targets design, must search comprehensive reference database non-targets. step requires searching substantial number probes large number non-targets. accomplish feat reasonable time leverage Biostrings’ dictionary matching functionality. Nevertheless step still requires several minutes complete. Note process can accelerated eliminating lowest scoring probes (.e., probes <- probes[o[1:20],]), used cases number non-targets included design sequence set sufficient narrow list potential probes reasonable candidates. Now can use thermodynamic model predict degree cross-hybridization probe non-target. information used update score every probe, stored column mismatches alongside previous non-targets identified design. Refer section~@ref(sec:startup) easily obtain code shown : Finally, can examine top scoring single probe updating results using comprehensive database. new best scoring probe targets site 300 nucleotides away original best scoring probe. design set missing many non-targets found searching comprehensive database. Note target group, Sphingopyxis, present comprehensive database now appears set non-targets (mismatches). net impact scores however, candidate probes effected equally since perfect match sequences group.","code":"dbConn_ref <- dbConnect(SQLite(), \"<<path to reference database>>\") # select the most common k-mers ref_tiles <- dbGetQuery(dbConn_ref,     \"select * from Tiles where groupCoverage > 0.2 and coverage > 0.01\") dbDisconnect(dbConn_ref) ref_tiles$id <- paste(\"ref\", ref_tiles$id, sep=\"_\") seqs <- DNAStringSet(ref_tiles$target_site) w <- which(!is.na(t(probes$probe))) probes_rc <- reverseComplement(DNAStringSet(t(probes$probe)[w])) p <- PDict(probes_rc, tb.start=1, tb.width=5) hits1 <- vwhichPDict(p, seqs, max.mismatch=5) l <- vapply(hits1, length, integer(1)) hits1 <- unlist(hits1, use.names=FALSE) names(hits1) <- rep(1:length(l), l) p <- PDict(probes_rc, tb.end=-1, tb.width=5) hits2 <- vwhichPDict(p, seqs, max.mismatch=5) l <- vapply(hits2, length, integer(1)) hits2 <- unlist(hits2, use.names=FALSE) names(hits2) <- rep(1:length(l), l) hits <- c(hits1, hits2) Hyb_FA <- 35 # the default Hybridization [FA] ( count <- 0L pBar <- txtProgressBar(style=3) for (i in 1:dim(probes)[1]) {     # for each hit calculate the degree of cross-hybridization     w <- which(!is.na(probes[i, \"probe\"]))     results <- NULL     for (j in 1:length(w)) {         count <- count + 1L         w <- which(hits==count)         if (length(w) > 0) {             ns <- as.integer(unique(names(hits[w])))             eff <- CalculateEfficiencyFISH(rep(probes$probe[i, j],                     length(ns)),                 ref_tiles$target_site[ns],                 46, # temperature                 250e-9, # [Probe]                 1, # [NA]                 Hyb_FA)             eff <- cbind(eff,                 data.frame(id=ref_tiles$id[ns],                     probe_rc=toString(probes_rc[count]),                     target=ref_tiles$target_site[ns],                     dFAm=eff[, \"FAm\"] - Hyb_FA,                     stringsAsFactors=FALSE))             results <- rbind(results, eff)         }     }          w <- which(results$dFAm > -20)     if (length(w) > 0) {         # only record the strongest cross-hybridization in each group         results <- results[w,]         u <- unique(results$id)         keep <- integer()         for (j in 1:length(u)) {             w <- which(results$id==u[j])             keep <- c(keep, w[which.max(results$dFAm[w])])         }         results <- results[keep,]                  # append more non-targets to mismatches         p <- pairwiseAlignment(results$probe_rc,             results$target,             type=\"global-local\")         probes$mismatches[i] <- paste(probes$mismatches[i],             paste(results$id,                 \" (\", round(100*results$HybEff, 1), \"                 round(results$ddG1, 2), \"kcal/mol,\",                 round(results$dFAm, 1), \"                 substring(reverseComplement(DNAStringSet(pattern(p))),                     1L),                 \"/\", substring(subject(p), 1L), \")\",                 sep=\"\",                 collapse=\" \"),             sep=\"\")                  # score -= 0.2 + 1.2^dFAm         probes$score[i] <- probes$score[i] -             sum(ifelse(results$dFAm < -20, 0, 0.2 +                 1.2^ifelse(results$dFAm > 0, 0, results$dFAm)))     }          setTxtProgressBar(pBar, i/dim(probes)[1]) } |===========================================================================| 100% # the original best scoring probe after searching the comprehensive database probes[o[1],] identifier start start_aligned permutations        score 826 Sphingopyxis   859          1019            3 -7.75865....                     probe.1                 probe.2 826 CCGCGATTAGGATGTCAAACGCT CCGCGATCAGGATGTCAAATGCT                     probe.3 probe.4 efficiency.1 efficiency.2 826 CCGCGATCAGGATGTCAAACGCT    <NA>    0.5014489    0.5506237     efficiency.3 efficiency.4    FAm.1    FAm.2    FAm.3    FAm.4 826    0.6315190           NA 35.04488 36.57339 39.17166       NA     coverage.1 coverage.2 coverage.3 coverage.4 826        0.4        0.2        0.4         NA                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          mismatches 826 unclassified_Sphingomonadaceae (63.2 AGCGTTTGACATCCTGATCGCGG) unclassified_Sphingomonadales (9.1 mol,-17.8 (13.2 ref_Sphingopyxis (63.2 AGCGTTTGACATCCTGATCGCGG) ref_Zymomonas (63.2 4.2 6.25kcal/mol,-19.5 ref_Cucumibacter (25.9 AGCTCTTGACATCCTGATCGCGG) ref_Celeribacter (15 mol,-13.5 5.64kcal/mol,-13.5 ref_Maritimibacter (15 AACCCTTGACATCCTGATCGCGG) ref_Pseudoruegeria (15 mol,-13.5 5.64kcal/mol,-13.5 (15 ref_Altererythrobacter (24.4 AGCCTTTGACATCCTGGTCGCGG) ref_Croceicoccus (24.4 mol,-8.8 6.32kcal/mol,-18.2 (8.7 # the new best scoring probe after searching the comprehensive database o <- order(probes$score, -1*probes$permutations,     rowSums(as.matrix(probes$coverage[,]), na.rm=TRUE),     decreasing=TRUE) probes[o[1],] identifier start start_aligned permutations        score 489 Sphingopyxis   522           679            2 -5.93961....                       probe.1                   probe.2 probe.3 probe.4 489 CACTGACCTCTCCAAGATTCAAGTT CACTGACCTCTCCAAGATTCTAGTT    <NA>    <NA>     efficiency.1 efficiency.2 efficiency.3 efficiency.4    FAm.1 489    0.5700456    0.6445774           NA           NA 37.04415        FAm.2    FAm.3    FAm.4 coverage.1 coverage.2 coverage.3 489 39.31453       NA       NA        0.8        0.2         NA     coverage.4 489         NA                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    mismatches 489 Porphyrobacter (12.3 AGCTAGAATCTTGGAGAGGCGAGTG) Blastomonas (9.2 mol,-18.6 (54.1 unclassified_Sphingomonadaceae (12.3 CGCTAGAATCTTGGAGAGGCGAGTG) Spirochaeta (12.6 mol,-16.1 (57 ref_Croceicoccus (65.8 GACTAGAATCTTGGAGAGGTCAGTG) ref_Novosphingobium (65.8 4.7 5.91kcal/mol,-13"},{"path":[]},{"path":"/articles/DesignProbes.html","id":"designing-the-optimal-dual-probe-set","dir":"Articles","previous_headings":"Dual Probe Design Steps","what":"Designing the Optimal Dual Probe Set","title":"Design Group-Specific FISH Probes","text":"Since single probe sufficient completely distinguish non-targets, can increase specificity using two probes combination. two methods accomplish design dual probes: using comprehensive sequence set design, simply set parameter numProbeSets positive number default zero. DesignProbes function search potential combinations two probes. value numProbeSets determine many dual probe sets DesignProbes design. example: searching non-targets using comprehensive reference database (outlined sections ) simpler continue left , already finished designing single probes searching potential non-targets. case, need search combination two probes minimal mismatch overlap, described . continue, first compute score using pair probes dual probe set. new score using two probes based minimal cross-hybridization pair probes every non-target. example, probe #1 cross-hybridizes non-target, probe #2 , non-target threat two probes used conjunction hybridization probes required positive identification. expected, score using two probes combination significantly better using single probe alone. can seen Figure 2, -diagonal colors represent use two probes, diagonal elements represent use single probe. combinations two probes results poor scores (seen red/magenta), others give high scores (blue/green). many combinations two probes fairly similar scores, now challenge becomes choose best two probes. One criteria first second probe’s target sites must separated least 50 nucleotides mitigate helper-oligonucleotide effects. criteria include number probe permutations required, percent coverage group, individual probe’s scores. Next take considerations account choosing top dual-probe sets. now multiple candidate dual probe sets consideration, target variable regions alignment. Notice top dual probe set include best scoring single probe. Using two probes conjunction sufficient eliminate many non-targets, listed column mismatches_set. However, even using two probes several non-targets still remain, careful consideration given probe set least liklihood causing false positive sample. example, several potential non-targets rarely found drinking water pose little threat causing false positive identification sample.","code":"probes <- DesignProbes(tiles, identifier=\"Sphingopyxis\",     start=120, end=1450,     numProbeSets=100) # note numProbeSets > 0 Sphingopyxis (678):   |=======================================================================| 100%  Time difference of 270 secs dim(probes) # now there are 100 potential probe sets [1] 100 21 numProbeSets <- 100 # number of probe sets to generate s <- ifelse(dim(probes)[1] > numProbeSets, numProbeSets, dim(probes)[1]) MMs <- strsplit(probes$mismatches[o[1:s]], \"mol,\", fixed=TRUE) ls <- unlist(lapply(MMs, length)) ls <- ifelse(ls > 0, ls - 1, 0) index <- rep(1:length(ls), ls) if (length(index) > 0) {     MMs <- strsplit(unlist(MMs), \"     MMs <- unlist(strsplit(unlist(MMs), \") \", fixed=TRUE))     effs <- as.numeric(MMs[seq(2, length(MMs), 3)])     MMs <- MMs[seq(1, length(MMs), 3)]     MMs <- unlist(strsplit(MMs, \" (\", fixed=TRUE))     MMs <- MMs[seq(1, length(MMs), 2)] }  m <- matrix(0, nrow=s, ncol=s, dimnames=list(o[1:s], o[1:s])) # scores n <- matrix(0, nrow=s, ncol=s, dimnames=list(o[1:s], o[1:s])) # counts for (i in 1:(s - 1)) {     w1 <- which(index==i)     if (length(w1)==0)         next     for (j in (i + 1):s) {         w2 <- which(index==j)         if (length(w2)==0)             next         overlap_MMs <- match(MMs[w1], MMs[w2])         w <- which(!is.na(overlap_MMs))         n[i, j] <- length(w)         if (length(w) > 0)             m[i, j] <- sum(tapply(c(effs[w1[w]], effs[w2[overlap_MMs[w]]]),                 rep(1:length(w), 2),                 function(x) return(-1.2^ifelse(min(x) > 0, 0, min(x)))))     } } # plot the matrix of dual-probe scores m <- m + t(m) # make symmetric diag(m) <- probes$score[o[1:s]] O <- order(o[1:s]) # unsort cols <- colorRamp(rainbow(101, start=0, end=0.35, v=0.9), bias=0.1)(0:100/100)/255 cols <- mapply(rgb, cols[, 1], cols[, 2], cols[, 3]) image(m[O, O[dim(m)[2]:1]], yaxt='n', xaxt='n', col=cols,     xlab=\"Probe #1 Target Site Position\", ylab=\"Probe #2 Target Site Position\") axis(1, seq(0, 1, 0.01), probes$start[o[1:s]][O[seq(1, s, length.out=101)]]) axis(2, seq(1, 0, -0.01), probes$start[o[1:s]][O[seq(1, s, length.out=101)]]) # choose the best probe sets d <- dimnames(m) p <- outer(probes$permutations[o[1:s]],     probes$permutations[o[1:s]],     FUN=\"+\") c <- -1*outer(rowSums(as.matrix(probes$coverage[o[1:s],]), na.rm=TRUE),     ifelse(rep(s, s)==1,         sum(probes$coverage[o[1:s],], na.rm=TRUE),         rowSums(as.matrix(probes$coverage[o[1:s],]), na.rm=TRUE)),     FUN=\"*\") ss <- -1*outer(probes$score[o[1:s]],     probes$score[o[1:s]],     FUN=\"+\") # order probes by dual-probe score, permutations, coverage, and individual scores o <- order(m + n/5, p, c, ss) # score = 0.2*n + 1.2^dFAm j <- 0 first <- second <- integer() scores <- numeric() mismatches <- character() for (k in 1:numProbeSets) {     if ((j + 1) > length(o))         break     for (j in (j + 1):length(o)) {         w_o <- c((o[j] - 1)              (o[j] - 1)         f <- as.numeric(d[[1]][w_o[1]])         r <- as.numeric(d[[2]][w_o[2]])                  start_F <- probes$start[f]         start_R <- probes$start[r]         if (abs(start_F - start_R) > (50 + nchar(probes$probe[f][1])))             break # > 50 nt separation     }          if (abs(start_F - start_R) > (50 + nchar(probes$probe[f][1]))) {         first <- c(first, f)         second <- c(second, r)         scores <- c(scores, -m[o[j]]/100)                  w_F <- which(index==w_o[1])         w_R <- which(index==w_o[2])         overlap_MMs <- match(MMs[w_F], MMs[w_R])         w_S <- which(!is.na(overlap_MMs))         if (length(w_S)==0)             next         EFFs <- tapply(c(effs[w_F[w_S]], effs[w_R[overlap_MMs[w_S]]]),                 rep(1:length(w_S), 2),                 min)         # record set mismatches         w1 <- which(EFFs >= -20)         if (length(w1) > 0)             mismatches <- c(mismatches, paste(MMs[w_F][w_S][w1],                 \" (\", formatC(EFFs[w1], digits=1, width=1, format=\"f\"),                 \"     } }  pSets <- cbind(probes[first,], probes[second,]) ns <- names(pSets) ns[1:10] <- paste(ns[1:10], \"one\", sep=\"_\") ns[11:20] <- paste(ns[11:20], \"two\", sep=\"_\") names(pSets) <- ns pSets$score_set <- scores pSets$mismatches_set <- mismatches  pSets[1, -which(names(pSets) identifier_one start_one start_aligned_one permutations_one 653   Sphingopyxis       686               844                2        score_one                probe_one.1                probe_one.2 653 -50.1945.... CCCGGACAGCTAGTTATCATCGTTTA CCCGGACAGATAGTTATCATCGTTTA     probe_one.3 probe_one.4 efficiency_one.1 efficiency_one.2 653        <NA>        <NA>        0.8086710        0.6370537     efficiency_one.3 efficiency_one.4 FAm_one.1 FAm_one.2 FAm_one.3 653               NA               NA  45.12303  38.95117        NA     FAm_one.4 coverage_one.1 coverage_one.2 coverage_one.3 653        NA            0.8            0.2             NA     coverage_one.4 identifier_two start_two start_aligned_two 653             NA   Sphingopyxis      1195              1376     permutations_two    score_two         probe_two.1 probe_two.2 653                1 -44.1990.... CCGCCTTCATGCTCTCGAG        <NA>     probe_two.3 probe_two.4 efficiency_two.1 efficiency_two.2 653        <NA>        <NA>        0.6540405               NA     efficiency_two.3 efficiency_two.4 FAm_two.1 FAm_two.2 FAm_two.3 653               NA               NA  40.71256        NA        NA     FAm_two.4 coverage_two.1 coverage_two.2 coverage_two.3 653        NA              1             NA             NA     coverage_two.4 score_set 653             NA 0.1546974                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      mismatches_set 653 Porphyrobacter (-4.4 unclassified_Sphingomonadaceae (0.0 ref_ref_Altererythrobacter (5.7 ref_ref_Erythrobacter (5.7 (5.7 ref_ref_Sandarakinorhabdus (-3.9 ref_ref_Sphingomonas (5.7 (-5.2"},{"path":"/articles/DesignProbes.html","id":"visualizing-the-target-sites","dir":"Articles","previous_headings":"Dual Probe Design Steps","what":"Visualizing the Target Sites","title":"Design Group-Specific FISH Probes","text":"Often useful visualize target sites probes hybridize target non-targets side--side. can accomplish highlighting region probes sequence set BrowseSeqs. querying database sequences interest, can selectively color target site regions given start_aligned_one start_aligned_two outputs DesignProbes. Next name order sequences set target (Sphingopyxis) appears top. Examining output, clear target sites chosen dual probes: least one dual probes number mismatches non-target groups.","code":"dna <- SearchDB(dbConn, nameBy=\"identifier\", verbose=FALSE) dbDisconnect(dbConn)  # move the target group to the top of the sequence set w <- which(names(dna)==\"Sphingopyxis\") dna <- c(dna[w], dna[-w])  BrowseSeqs(dna, colorPatterns=c(pSets$start_aligned_one[1],     pSets$start_aligned_one[1] + nchar(pSets$probe_one[1]) - 1,     pSets$start_aligned_two[1],     pSets$start_aligned_two[1] + nchar(pSets$probe_two[1]) - 1),     highlight=1)"},{"path":"/articles/DesignProbes.html","id":"finishing-up","dir":"Articles","previous_headings":"Dual Probe Design Steps","what":"Finishing Up","title":"Design Group-Specific FISH Probes","text":"Finally, can order first second probe try experiment! probes labeled different fluorphores (e.g., fluorescein Cy3). cases non-targets eliminated, may possible increase specificity using competitor oligonucleotide complementary non-target permutations given mismatches columns. Hybridization conditions optimized based results formamide gradient experiment. two probes markedly different optimal formamide concentrations dual-hybridization approach can employed washing stringent condition followed second.","code":""},{"path":"/articles/DesignProbes.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session Information","title":"Design Group-Specific FISH Probes","text":"output vignette produced following conditions:","code":""},{"path":"/articles/DesignSignatures.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Design Primers That Yield Group-Specific Signatures","text":"DECIPHER function DesignSignatures created perform common primer design task: efficiently amplify shared region DNA produce maximal amplicon diversity. goal independent method used differentiate amplicons, although design details may depend technique employed. DesignSignatures supports three common methods distinguishing amplicons: sequencing, High Resolution Melting (HRM) analysis, Fragment Length Polymorphism (FLP) analysis. case study, tutorial focuses designing primers differentiate SNP alleles using HRM analysis. However, methods described can easily adjusted experimental techniques. input, use known sequence variants Isocitrate Dehydrogenase 2 ( gene implicated human gliomas. First, database constructed variants identified unique name. Next, database used design primers yield maximal amplicon diversity. top scoring primers investigated determine whether can easily distinguished experimentally. Finally, process repeated using restriction enzyme diversify amplicons’ signatures. Note much functionality described accessible via web tool http://DECIPHER.codes.","code":""},{"path":[]},{"path":"/articles/DesignSignatures.html","id":"startup","dir":"Articles","previous_headings":"Getting Started","what":"Startup","title":"Design Primers That Yield Group-Specific Signatures","text":"get started need load DECIPHER package, automatically loads several required packages. Help DesignSignatures function can accessed : DECIPHER installed system, code example can obtained via:","code":"library(DECIPHER) ## Loading required package: Biostrings ## Loading required package: BiocGenerics ##  ## Attaching package: 'BiocGenerics' ## The following objects are masked from 'package:stats': ##  ##     IQR, mad, sd, var, xtabs ## The following objects are masked from 'package:base': ##  ##     anyDuplicated, aperm, append, as.data.frame, basename, cbind, ##     colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ##     get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply, ##     match, mget, order, paste, pmax, pmax.int, pmin, pmin.int, ##     Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort, ##     table, tapply, union, unique, unsplit, which.max, which.min ## Loading required package: S4Vectors ## Loading required package: stats4 ##  ## Attaching package: 'S4Vectors' ## The following object is masked from 'package:utils': ##  ##     findMatches ## The following objects are masked from 'package:base': ##  ##     expand.grid, I, unname ## Loading required package: IRanges ## Loading required package: XVector ## Loading required package: GenomeInfoDb ##  ## Attaching package: 'Biostrings' ## The following object is masked from 'package:base': ##  ##     strsplit ## Loading required package: RSQLite ## Loading required package: parallel > ? DesignSignatures > browseVignettes(\"DECIPHER\")"},{"path":"/articles/DesignSignatures.html","id":"creating-a-sequence-database","dir":"Articles","previous_headings":"Getting Started","what":"Creating a Sequence Database","title":"Design Primers That Yield Group-Specific Signatures","text":"begin set IDH2 sequences FASTA file included part DECIPHER package. file contains common IDH2 allele, three alleles single nucleotide polymorphisms (SNPs). goal design primers can distinguish four variants IDH2 gene. wish follow along FASTA file unaligned sequences, sure change path names system replacing text inside quotes labeled “\\(<<\\)path …\\(>>\\)” actual path system. Next, two options importing sequences database: either save database file maintain database memory. build database memory small set sequences intend use database later:","code":"# specify the path to your sequence file: fas <- \"<<path to FASTA file>>\" # OR find the example sequence file used in this tutorial: fas <- system.file(\"extdata\", \"IDH2.fas\", package=\"DECIPHER\") # specify a path for where to write the sequence database dbConn <- \"<<path to write sequence database>>\" # OR create the sequence database in memory dbConn <- dbConnect(SQLite(), \":memory:\") N <- Seqs2DB(fas, \"FASTA\", dbConn, \"\") ##  Reading FASTA file chunk 1 ##  ## 4 total sequences in table Seqs. ## Time difference of 0.04 secs N # number of sequences in the database ## [1] 4"},{"path":"/articles/DesignSignatures.html","id":"defining-groups","dir":"Articles","previous_headings":"Getting Started","what":"Defining Groups","title":"Design Primers That Yield Group-Specific Signatures","text":"point necessary define groups related sequences database just created. Ideally, groups designate different variants (.e., strains alleles) hope distinguish. example, define groups based allele’s name, included description FASTA record imported. common case, simply uses sequence’s name group name. assign group names directly sequence names (FASTA identifiers), simply run code shown . complex cases, use functions IdentifyByRank, FormGroups, Clusterize, TreeLine define groups. Now unique names four variants, must add database identifier sequence.","code":"# if each sequence belongs to its own group, # then identify the sequences with a number: desc <- as.character(seq_len(N)) # N is the number of sequences # OR get the FASTA record description: desc <- dbGetQuery(dbConn, \"select description from Seqs\")$description # show the unique descriptors: unique(desc) ## [1] \"IDH2\"  \"R172K\" \"R172G\" \"R172M\" Add2DB(data.frame(identifier=desc, stringsAsFactors=FALSE), dbConn) ## Expression: ## update Seqs set identifier = :identifier where row_names = :row_names ##  ## Added to table Seqs:  \"identifier\". ##  ## Time difference of 0 secs"},{"path":[]},{"path":"/articles/DesignSignatures.html","id":"adjusting-input-parameters","dir":"Articles","previous_headings":"Designing primers with diverse signatures","what":"Adjusting Input Parameters","title":"Design Primers That Yield Group-Specific Signatures","text":"using database design primers, must carefully consider inputs used. inputs can large impact outcome, therefore tailored experimental goal. recommended inputs sequencing, FLP, HRM:","code":"# Designing primers for sequencing experiments: TYPE <- \"sequence\" MIN_SIZE <- 300 # base pairs MAX_SIZE <- 700 RESOLUTION <- 5 # k-mer signature LEVELS <- 5 # max number of each k-mer # Designing primers for community fingerprinting (FLP): TYPE <- \"length\" # it is important to have a width range of lengths MIN_SIZE <- 200 # base pairs MAX_SIZE <- 1400 # define bin boundaries for distinguishing length, # the values below require high-resolution, but # the bin boundaries can be redefined for lower # resolution experiments such as gel runs RESOLUTION <- c(seq(200, 700, 3),                 seq(705, 1000, 5),                 seq(1010, 1400, 10)) LEVELS <- 2 # presence/absence of the length # Designing primers for high resolution melting (HRM): TYPE <- \"melt\" MIN_SIZE <- 55 # base pairs MAX_SIZE <- 400 # the recommended values for resolution RESOLUTION <- seq(75, 100, 0.25) # degrees Celsius LEVELS <- 10"},{"path":"/articles/DesignSignatures.html","id":"select-restriction-enzymes","dir":"Articles","previous_headings":"Designing primers with diverse signatures","what":"Select Restriction Enzymes","title":"Design Primers That Yield Group-Specific Signatures","text":"following step applicable sequencing experiments (.e., TYPE \"sequence\"), optional types experiments. using HRM FLP analysis differentiate amplicon signatures, digestion step following PCR amplification may generate fragments widely different signatures. especially useful trying distinguish large number different groups based small variations. Potential enzymes can selected built-RESTRICTION_ENZYMES dataset, includes standard enzymes sold ","code":"ENZYMES <- NULL # required for sequencing # OR select restriction enzymes to consider data(RESTRICTION_ENZYMES) # load available enzymes # for this tutorial we will use the enzyme MslI ENZYMES <- RESTRICTION_ENZYMES[\"MslI\"] ENZYMES ##          MslI  ## \"CAYNN/NNRTG\""},{"path":"/articles/DesignSignatures.html","id":"designing-primers","dir":"Articles","previous_headings":"Designing primers with diverse signatures","what":"Designing Primers","title":"Design Primers That Yield Group-Specific Signatures","text":"Now can design primers target groups result maximal amplicon diversity: output data.frame sorted sum \"score\" \"digest_score\". However, can separately look top scoring primers without using restriction enzymes. PCR products digested MslI substantially higher scoring (digest_score) undigested primers (score). Note columns \"similar_signatures\" \"missing_signatures\" empty primer set, indicating groups distinct signatures digestion restriction enzyme.","code":"primers <- DesignSignatures(dbConn,                             type=TYPE,                             minProductSize=MIN_SIZE,                             maxProductSize=MAX_SIZE,                             resolution=RESOLUTION,                             levels=LEVELS,                             enzymes=ENZYMES) ## Tallying 8-mers for 4 groups: ## ================================================================================ ##  ## Time difference of 0.11 secs ##  ## Designing primer sequences based on the group 'IDH2': ## ================================================================================ ##  ## Time difference of 24.93 secs ##  ## Selecting the most common primer sequences: ## ================================================================================ ##  ## Time difference of 3.23 secs ##  ## Determining PCR products from each group: ## ================================================================================ ##  ## Time difference of 83.54 secs ##  ## Scoring primer pair combinations: ## ================================================================================ ##  ## Time difference of 0.34 secs ##  ## Choosing optimal forward and reverse pairs: ## ================================================================================ ##  ## Time difference of 0.51 secs ##  ## Finding the best restriction enzyme: ## ================================================================================ ##  ## Time difference of 2.51 secs primers[which.max(primers$score),] # best primers without digestion ##       forward_primer       reverse_primer        score coverage products ## 48 TGGCTGGACCAAGCCCA CCTTGTACTGGTCGCCATGG 0.041666....        1        4 ##    similar_signatures missing_signatures enzyme digest_score fragments ## 48                                         MslI            0         2 primers[which.max(primers$digest_score),] # best primers with digestion ##      forward_primer       reverse_primer        score coverage products ## 1 TGGCTGGACCAAGCCCA CTGTGGCCTTGTACTGGTCG 0.035555....        1        4 ##   similar_signatures missing_signatures enzyme digest_score fragments ## 1                                         MslI    0.1805556        13"},{"path":[]},{"path":"/articles/DesignSignatures.html","id":"view-the-target-sites","dir":"Articles","previous_headings":"Assessing the Results","what":"View the Target Sites","title":"Design Primers That Yield Group-Specific Signatures","text":"can now look target sites top scoring primers restriction enzyme. can see Figure @ref(f1) forward reverse primers target sites sides SNP, located approximately center amplicon. restriction sites next SNP, shorten amplicons spread melting curves. Furthermore, final allele two adjacent restriction sites, whereas others one.","code":"PSET <- 1 # examine the top scoring primer set overall  # select the first sequence from each group dna <- SearchDB(dbConn,                 remove=\"all\",                 nameBy=\"identifier\",                 clause=\"row_names =                         (select min(row_names) from Seqs as S                          where S.identifier = Seqs.identifier)\",                 verbose=FALSE)  f_primer <- DNAStringSet(primers$forward_primer[PSET]) r_primer <- DNAStringSet(primers$reverse_primer[PSET]) patterns <- c(f_primer,               reverseComplement(r_primer),               DNAStringSet(gsub(\"[^A-Z]\", \"\", ENZYMES)))  BrowseSeqs(dna,            patterns=patterns)"},{"path":"/articles/DesignSignatures.html","id":"plot-the-signatures","dir":"Articles","previous_headings":"Assessing the Results","what":"Plot the Signatures","title":"Design Primers That Yield Group-Specific Signatures","text":"Next compare signatures top scoring primers without digestion. simplest way accomplish use Biostrings function matchLRPatterns find amplicons. Refer section~@ref(sec:startup) easily obtain code shown :  Figure @ref(f2) shows two alleles indistinguishable using primers melting curves nearly overlapping. now compare result using restriction enzyme. Note possible previously specified restriction enzyme input DesignSignatures.  Figure @ref(f3) shows two amplicons nearly identical melt curves can easily distinguished restriction digest.","code":"PSET <- which.max(primers$score) # top scoring without digestion  f_primer <- DNAString(primers$forward_primer[PSET]) r_primer <- DNAString(primers$reverse_primer[PSET]) r_primer <- reverseComplement(r_primer)  ids <- dbGetQuery(dbConn, \"select distinct identifier from Seqs\") ids <- ids$identifier  if (TYPE==\"sequence\") {     signatures <- matrix(0, nrow=4^RESOLUTION, ncol=length(ids)) } else if (TYPE==\"melt\") {     signatures <- matrix(0, nrow=length(RESOLUTION), ncol=length(ids)) } else { # TYPE==\"length\"     signatures <- matrix(0, nrow=length(RESOLUTION) - 1, ncol=length(ids)) } colnames(signatures) <- abbreviate(ids, 15)  for (i in seq_along(ids)) {     dna <- SearchDB(dbConn, identifier=ids[i], remove=\"all\", verbose=FALSE)     amplicons <- matchLRPatterns(f_primer, r_primer,                                  MAX_SIZE, unlist(dna),                                  max.Lmismatch=2, max.Rmismatch=2,                                  Lfixed=\"subject\", Rfixed=\"subject\")     amplicons <- as(amplicons, \"DNAStringSet\")     if (length(amplicons)==0)         next          if (TYPE==\"sequence\") {         signature <- oligonucleotideFrequency(amplicons, RESOLUTION)         signatures[, i] <- colMeans(signature)     } else if (TYPE==\"melt\") {         signature <- MeltDNA(amplicons, \"melt curves\", RESOLUTION)         # weight melting curves by their amlicon's width         signature <- t(signature)*width(amplicons)         signatures[, i] <- colSums(signature)/sum(width(amplicons))     } else { # TYPE==\"length\"         signature <- .bincode(width(amplicons), RESOLUTION)         for (j in signature[which(!is.na(signature))])             signatures[j, i] <- signatures[j, i] + 1/length(signature)     } }  if (TYPE==\"sequence\") {     d <- dist(t(signatures), \"minkowski\", p=1) # L1-Norm     TreeLine(myDistMatrix=as.matrix(d), method=\"UPGMA\", showPlot=TRUE)     mtext(paste(RESOLUTION, \"-mer Profile Distance\", sep=\"\"),         side=2, padj=-4) } else if (TYPE==\"melt\") {     matplot(RESOLUTION, signatures, type=\"l\",         xlab=\"Temperature (degrees Celsius)\", ylab=\"Average Helicity\") } else { # TYPE==\"length\"     if (length(ids) > 20) {         plot(NA,             xlim=c(0.5, length(ids) + 0.5), ylim=range(RESOLUTION),             xlab=\"Group Index\", ylab=\"Amplicon Length\",             yaxs=\"i\", xaxs=\"i\")         axis(1, at=1:length(ids), labels=FALSE, tck=-0.01)     } else {         plot(NA,             xlim=c(0.5, length(ids) + 0.5), ylim=range(RESOLUTION),             xlab=\"\", ylab=\"Amplicon Length\",             yaxs=\"i\", xaxs=\"i\", xaxt=\"n\")         axis(1, at=1:length(ids), labels=abbreviate(ids, 7), las=2)     }     xaxs <- RESOLUTION[-1] - diff(RESOLUTION)/2 # average lengths     for (i in seq_along(ids)) {         w <- which(signatures[, i] > 0)         if (length(w) > 0)             segments(i - 0.45, xaxs[w], i + 0.45, xaxs[w], lwd=2)     } } PSET <- which.max(primers$digest_score) # top scoring with digestion  f_primer <- DNAString(primers$forward_primer[PSET]) r_primer <- DNAString(primers$reverse_primer[PSET]) r_primer <- reverseComplement(r_primer) enzyme <- RESTRICTION_ENZYMES[primers$enzyme[PSET]]  signatures[] <- 0 # initialize the results matrix used previously for (i in seq_along(ids)) {     dna <- SearchDB(dbConn, identifier=ids[i], remove=\"all\", verbose=FALSE)     amplicons <- matchLRPatterns(f_primer, r_primer,                                  MAX_SIZE, unlist(dna),                                  max.Lmismatch=2, max.Rmismatch=2,                                  Lfixed=\"subject\", Rfixed=\"subject\")     amplicons <- as(amplicons, \"DNAStringSet\")     if (length(amplicons)==0)         next     digested <- DigestDNA(enzyme, amplicons, strand=\"top\")     digested <- unlist(digested) # convert to DNAStringSet          if (TYPE==\"melt\") {         signature <- MeltDNA(digested, \"melt curves\", RESOLUTION)         # weight melting curves by their fragment's width         signature <- t(signature)*width(digested)         signatures[, i] <- colSums(signature)/sum(width(digested))     } else { # TYPE==\"length\"         signature <- .bincode(width(digested), RESOLUTION)         for (j in signature[which(!is.na(signature))])             signatures[j, i] <- signatures[j, i] + 1/length(signature)     } }  if (TYPE==\"melt\") {     matplot(RESOLUTION, signatures, type=\"l\",         xlab=\"Temperature (degrees Celsius)\", ylab=\"Average Helicity\") } else { # TYPE==\"length\"     if (length(ids) > 20) {         plot(NA,             xlim=c(0.5, length(ids) + 0.5), ylim=range(RESOLUTION),             xlab=\"Group Index\", ylab=\"Amplicon Length\",             yaxs=\"i\", xaxs=\"i\")         axis(1, at=1:length(ids), labels=FALSE, tck=-0.01)     } else {         plot(NA,             xlim=c(0.5, length(ids) + 0.5), ylim=range(RESOLUTION),             xlab=\"\", ylab=\"Amplicon Length\",             yaxs=\"i\", xaxs=\"i\", xaxt=\"n\")         axis(1, at=1:length(ids), labels=abbreviate(ids, 7), las=2)     }     xaxs <- RESOLUTION[-1] - diff(RESOLUTION)/2 # average lengths     for (i in seq_along(ids)) {         w <- which(signatures[, i] > 0)         if (length(w) > 0)             segments(i - 0.45, xaxs[w], i + 0.45, xaxs[w], lwd=2)     } }"},{"path":"/articles/DesignSignatures.html","id":"finishing-up","dir":"Articles","previous_headings":"Assessing the Results","what":"Finishing Up","title":"Design Primers That Yield Group-Specific Signatures","text":"Finally, can order top scoring forward reverse primers synthesis try PCR reaction! primers synthesized orientation given output (primers).","code":""},{"path":"/articles/FindChimeras.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Finding Chimeric Sequences","text":"document illustrates detect chimeric sequences using DECIPHER package use FindChimeras function. function finds chimeric sequences present database (dbFile) sequences making use reference database (dbFileReference) good sequences. examples document directed towards finding chimeric 16S rRNA sequences, although similar strategy used type sequence. 16S sequences functionality FindChimeras implemented web tool available http://DECIPHER.codes.","code":""},{"path":"/articles/FindChimeras.html","id":"chimera-finding-problems","dir":"Articles","previous_headings":"","what":"Chimera Finding Problems","title":"Finding Chimeric Sequences","text":"Chimeras common type sequence anomaly result use PCR amplification. Chimeras masquerade normal sequences, actually made several different sequence parts exist together reality. Undetected chimeras can insidious effects, causing incorrect assessments sequence diversity primer/probe specificity. Chimeras difficult detect, several detection methods proposed varying degrees success. basic problem can described search one regions sequence belong rest sequence. FindChimeras algorithm works finding suspect sequence fragments uncommon group sequence belongs, common another group sequence belong. sequence dbFile tiled short sequence segments called fragments. fragments infrequent respective group dbFileReference considered suspect. enough suspect fragments sequence meet specified constraints sequence flagged chimera.","code":""},{"path":"/articles/FindChimeras.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting Started","title":"Finding Chimeric Sequences","text":"get started need load DECIPHER package, automatically loads several required packages. Help DECIPHER function, FindChimeras, can accessed : DECIPHER installed system, code example can obtained via:","code":"library(DECIPHER) ## Loading required package: Biostrings ## Loading required package: BiocGenerics ##  ## Attaching package: 'BiocGenerics' ## The following objects are masked from 'package:stats': ##  ##     IQR, mad, sd, var, xtabs ## The following objects are masked from 'package:base': ##  ##     anyDuplicated, aperm, append, as.data.frame, basename, cbind, ##     colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ##     get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply, ##     match, mget, order, paste, pmax, pmax.int, pmin, pmin.int, ##     Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort, ##     table, tapply, union, unique, unsplit, which.max, which.min ## Loading required package: S4Vectors ## Loading required package: stats4 ##  ## Attaching package: 'S4Vectors' ## The following object is masked from 'package:utils': ##  ##     findMatches ## The following objects are masked from 'package:base': ##  ##     expand.grid, I, unname ## Loading required package: IRanges ## Loading required package: XVector ## Loading required package: GenomeInfoDb ##  ## Attaching package: 'Biostrings' ## The following object is masked from 'package:base': ##  ##     strsplit ## Loading required package: RSQLite ## Loading required package: parallel > ? FindChimeras > browseVignettes(\"DECIPHER\")"},{"path":"/articles/FindChimeras.html","id":"obtainingbuilding-a-reference-database","dir":"Articles","previous_headings":"","what":"Obtaining/Building A Reference Database","title":"Finding Chimeric Sequences","text":"first step necessary use FindChimeras obtain reference database (dbFileReference) good sequences. order algorithm work accurately, crucial reference database free chimeras. examples given document use 16S rRNA sequences, suitable reference database can found http://DECIPHER.codes/Download.html. reference database present feasible create one significantly large repository sequences available. using input database reference database possible remove chimeras database. Iteratively repeating process can eventually result clean reference database chimera free. reference database required several fields information found newly created sequence database: bases nonbases provided function IdLengths. origin provided function FormGroups. origin column contains taxonomic rank level shared whole group. example, origin group Nanoarchaeum Root; Archaea; Nanoarchaeota. Without taxonomic classifications possible substitute numbers. example, rank 3.1.4.2 group named 4 included 4.1 4.2 origin 3.1. numbers generated using Clusterize TreeLine multiple cutoffs. example building reference database de novo FASTA file ribosomal RNA (rRNA) sequences downloaded SILVA (http://www.arb-silva.de/). course, reference database must match type query sequences, remainder vignette use comprehensive SSU rRNA (16S) database. information section given example build reference database scratch. importing GenBank file rank (classification) information automatically imported ORGANISM field. classification simply level taxonomic rank separated semicolons. case classification must parsed sequence’s description information following “>” symbol. necessary perform two steps can use reference database chimera finding: can now screen reference database chimeras. process can repeated new chimeras can found reference database, point reference database ready checking new sequences. Note sequences reference database must orientation query sequences. function OrientNucleotides can used reorient query sequences, necessary.","code":"> dbRef <- dbConnect(SQLite(), \"<<path to reference database>>\") > Seqs2DB(\"<<path to reference sequences>>\", \"FASTA\", dbRef, \"\") 645151 total sequences in table Seqs. Time difference of 172.81 secs > ns <- dbGetQuery(dbRef, \"select description from Seqs\") > ns$rank <- gsub(\"(.+) (.+)?\", \"\\\\2\", ns$description) > ns$rank <- gsub(\"(.+)?;(.*)$\", \"\\\\2\\nRoot;\\\\1\", ns$rank) > ns$description <- gsub(\"(.+) (.+)?\", \"\\\\1\", ns$description) > Add2DB(ns, dbRef) Expression: update Seqs set description = :description where row_names = :row_names  Expression: alter table Seqs add column rank TEXT  Expression: update Seqs set rank = :rank where row_names = :row_names  Added to table Seqs:  \"description\" and \"rank\".  Time difference of 883.32 secs > lengths <- IdLengths(dbRef, add2tbl=TRUE)   |===============================================================| 100% Lengths counted for 645151 sequences. Added to Seqs:  \"bases\", \"nonbases\", and \"width\".  Time difference of 3924.83 secs  > groups <- FormGroups(dbRef, add2tbl=TRUE)   |===============================================================| 100% Updating column: \"identifier\"... Updating column: \"origin\"... Formed 1760 distinct groups. Added to table Seqs: \"identifier\", \"origin\".  Time difference of 19860.67 secs > chimeras <- FindChimeras(dbRef, dbFileReference=dbRef, add2tbl=TRUE) Found 102 possible chimeras. Added to table Seqs:  \"chimera\". Time difference of 13387.34 secs"},{"path":[]},{"path":[]},{"path":"/articles/FindChimeras.html","id":"training-the-classifier","dir":"Articles","previous_headings":"Steps to Find Chimeras > Assigning Sequences to Reference Groups","what":"Training the Classifier","title":"Finding Chimeric Sequences","text":"order assign new sequences group reference database, necessary first classify sequences. can use functions LearnTaxa IdTaxa assign groups query sequences. See “Classify Sequences” vignette detailed description process.","code":"ids <- dbGetQuery(dbRef, \"select identifier, origin from Seqs\") ids <- paste(ids$origin, ids$identifier, sep=\";\")  dna <- SearchDB(dbRef, type=\"DNAStringSet\", remove=\"all\")  trainingSet <- LearnTaxa(dna, ids)"},{"path":"/articles/FindChimeras.html","id":"creating-a-query-sequence-database","dir":"Articles","previous_headings":"Steps to Find Chimeras > Assigning Sequences to Reference Groups","what":"Creating a Query Sequence Database","title":"Finding Chimeric Sequences","text":"Chimera finding requires two database tables, one reference sequences one query sequences. Now finished creating chimera-free reference sequence database training classifer taxonomy, time make query sequence database. can accomplished specifying new table within reference sequence database creating new database file query sequences, shown .","code":"dbConn <- dbConnect(SQLite(), '<<path to query database>>') Seqs2DB('<<path to query sequences>>', 'FASTA', dbConn, '')"},{"path":"/articles/FindChimeras.html","id":"assigning-to-groups","dir":"Articles","previous_headings":"Steps to Find Chimeras > Assigning Sequences to Reference Groups","what":"Assigning to Groups","title":"Finding Chimeric Sequences","text":"can now classify query sequences assign corresponding group reference database. Note query sequences need orientation sequences reference sequence database.","code":"query <- SearchDB(dbConn, remove=\"all\") groups <- IdTaxa(query, trainingSet, strand=\"top\", threshold=0, processors=1) groups <- sapply(groups, function(x) tail(x$taxon, n=1)) groups <- data.frame(identifier=groups, row.names=seq_along(groups), stringsAsFactors=FALSE) Add2DB(groups, dbConn)"},{"path":"/articles/FindChimeras.html","id":"finding-chimeras","dir":"Articles","previous_headings":"Steps to Find Chimeras","what":"Finding Chimeras","title":"Finding Chimeric Sequences","text":"Finally, can use FindChimeras function search chimeras sequences. chimeras found stored chimeras data.frame. several ways determine sequences found chimeric.","code":"# full-length sequences chimeras <- FindChimeras(dbConn, dbFileReference=dbRef, add2tbl=TRUE) Group of Sequence (Number of Sequences):   |===============================================================| 100%  Searching Other Groups:   |===============================================================| 100%  Found 19 possible chimeras. Added to table Seqs:  \"chimera\". Time difference of 981.21 secs > # outputs the number of chimeras that were found > cat(\"Number of chimeras =\", dim(chimeras)[1]) Number of chimeras = 19  > # get the indices of chimeric sequences in the set > as.numeric(row.names(chimeras))  [1] 147 89  87  90  88  132 139 97  5  120 123 13  [13] 118 114 173 174 175 18 124 > # allows viewing the chimera results in a web browser > BrowseDB(dbConn) [1] TRUE > # returns the FASTA description of the chimeric sequences > dbGetQuery(dbConn, \"select description from Seqs where chimera is not null\") 1       uncultured bacterium; Fin_CL-100633_OTU-22. 2       uncultured bacterium; Fin_CL-030731_OTU-12. 3        uncultured bacterium; Fin_CL-050647_OTU-9. 4       uncultured bacterium; Pro_CL-100643_OTU-10. 5        uncultured bacterium; LO1_CL-100643_OTU-3. 6        uncultured bacterium; LO3_CL-100641_OTU-3. 7       uncultured bacterium; UWH_CL-010711_OTU-13. 8   uncultured bacterium; Chlplus_CL-120529_OTU-35. 9       uncultured bacterium; UWH_CL-110523_OTU-35. 10      uncultured bacterium; UWH_CL-100636_OTU-11. 11 uncultured bacterium; Chlminus_CL-090519_OTU-14. 12      uncultured bacterium; UWL_CL-080514_OTU-34. 13      uncultured bacterium; UWL_CL-080545_OTU-12. 14       uncultured bacterium; Pro_CL-100633_OTU-7. 15      uncultured bacterium; UWL_CL-110645_OTU-15. 16        uncultured bacterium; UWL_CL-09061_OTU-5. 17       uncultured bacterium; Fin_CL-03079_OTU-21. 18      uncultured bacterium; UWL_CL-110518_OTU-11. 19      uncultured bacterium; UWL_CL-110548_OTU-32. > dbDisconnect(dbRef) [1] TRUE > dbDisconnect(dbConn) [1] TRUE"},{"path":"/articles/FindingGenes.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The Magic of Gene Finding","text":"vignette reveals tricks behind magic ab initio gene finding. Cells magical ability transcribe translate portions genome, somehow decoding key signals sea possibilities. FindGenes function attempts decipher signals order accurately predict organism’s set genes. Cells much magic using information upstream gene, whereas FindGenes uses content gene upstream information predict gene boundaries. case study, tutorial focuses finding genes genome Chlamydia trachomatis, intracellular bacterial pathogen known causing chlamydia. genome chosen relatively small (~1 Mbp) examples run quickly. Nevertheless, FindGenes designed work genome lacks introns, making well-suited prokaryotic gene finding.","code":""},{"path":[]},{"path":"/articles/FindingGenes.html","id":"startup","dir":"Articles","previous_headings":"Getting Started","what":"Startup","title":"The Magic of Gene Finding","text":"get started need load DECIPHER package, automatically loads required packages. Gene finding performed function FindGenes. Help can accessed via: DECIPHER installed, code tutorial can obtained via:","code":"library(DECIPHER) ## Loading required package: Biostrings ## Loading required package: BiocGenerics ##  ## Attaching package: 'BiocGenerics' ## The following objects are masked from 'package:stats': ##  ##     IQR, mad, sd, var, xtabs ## The following objects are masked from 'package:base': ##  ##     anyDuplicated, aperm, append, as.data.frame, basename, cbind, ##     colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ##     get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply, ##     match, mget, order, paste, pmax, pmax.int, pmin, pmin.int, ##     Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort, ##     table, tapply, union, unique, unsplit, which.max, which.min ## Loading required package: S4Vectors ## Loading required package: stats4 ##  ## Attaching package: 'S4Vectors' ## The following object is masked from 'package:utils': ##  ##     findMatches ## The following objects are masked from 'package:base': ##  ##     expand.grid, I, unname ## Loading required package: IRanges ## Loading required package: XVector ## Loading required package: GenomeInfoDb ##  ## Attaching package: 'Biostrings' ## The following object is masked from 'package:base': ##  ##     strsplit ## Loading required package: RSQLite ## Loading required package: parallel > ? FindGenes > browseVignettes(\"DECIPHER\")"},{"path":"/articles/FindingGenes.html","id":"finding-genes-in-a-genome","dir":"Articles","previous_headings":"","what":"Finding Genes in a Genome","title":"The Magic of Gene Finding","text":"Ab initio gene finding begins genome locates genes without prior knowledge specific organism.","code":""},{"path":"/articles/FindingGenes.html","id":"importing-the-genome","dir":"Articles","previous_headings":"Finding Genes in a Genome","what":"Importing the genome","title":"The Magic of Gene Finding","text":"first step set filepaths genome sequence (FASTA format). sure change path names system replacing text inside quotes labeled “\\(<<\\)path …\\(>>\\)” actual path system.","code":"# specify the path to your genome: genome_path <- \"<<path to genome FASTA file>>\" # OR use the example genome: genome_path <- system.file(\"extdata\",     \"Chlamydia_trachomatis_NC_000117.fas.gz\",     package=\"DECIPHER\")  # read the sequences into memory genome <- readDNAStringSet(genome_path) genome ## DNAStringSet object of length 1: ##       width seq                                             names                ## [1] 1042519 GCGGCCGCCCGGGAAATTGCTA...GTTGGCTGGCCCTGACGGGGTA NC_000117.1 Chlam..."},{"path":"/articles/FindingGenes.html","id":"finding-genes","dir":"Articles","previous_headings":"Finding Genes in a Genome","what":"Finding genes","title":"The Magic of Gene Finding","text":"next step find genes genome using FindGenes, magic. fairly choices make step. default, bacterial archaeal genetic code used translation, including initiation codons “ATG”, “GTG”, “TTG”, “CTG”, “ATA”, “ATT”, “ATC”. default minGeneLength 60, although set lower (e.g., 30) locate short genes higher (e.g., 90) (slightly) better accuracy. argument allowEdges (default TRUE) controls whether genes allowed run ends genome, expected circular incomplete chromosomes. , set showPlot TRUE display summary gene finding process allScores TRUE see scores open reading frames (including predicted genes).","code":""},{"path":"/articles/FindingGenes.html","id":"inspecting-the-output","dir":"Articles","previous_headings":"Finding Genes in a Genome","what":"Inspecting the output","title":"The Magic of Gene Finding","text":"presto! wave magic wand now gene predictions form object belonging class Genes. Now genes hand, let’s take look : Open reading frames defined Begin End position, well whether top (.e., Strand 0) bottom strand. , genes flagged non-zero value Gene column. see open reading frames output allScores set TRUE. want look subset open reading frames predicted genes, can subset object: \"Gene\" column one several describing open reading frames. Objects class Genes stored matrices many columns:","code":"orfs ## Genes object of size 109,490 specifying: ## 897 protein coding genes from 66 to 5,361 nucleotides. ## 108,593 open reading frames from 60 to 5,370 nucleotides. ##  ##   Index Strand Begin  End TotalScore ... Gene ## 1     1      0     1 1176      77.95 ...    1 ## 2     1      0     2   82      -4.47 ...    0 ## 3     1      0    16 1176      61.94 ...    0 ## 4     1      0    17   82      -8.87 ...    0 ## 5     1      1    41  106     -13.48 ...    0 ## 6     1      1    91  150     -35.21 ...    0 ## ... with 109,484 more rows. genes <- orfs[orfs[, \"Gene\"]==1,] colnames(genes) ##  [1] \"Index\"                    \"Strand\"                   ##  [3] \"Begin\"                    \"End\"                      ##  [5] \"TotalScore\"               \"LengthScore\"              ##  [7] \"CodingScore\"              \"CodonModel\"               ##  [9] \"CouplingScore\"            \"StartScore\"               ## [11] \"StopScore\"                \"InitialCodonScore\"        ## [13] \"TerminationCodonScore\"    \"RibosomeBindingSiteScore\" ## [15] \"AutocorrelationScore\"     \"UpstreamNucleotideScore\"  ## [17] \"UpstreamMotifScore\"       \"FoldingScore\"             ## [19] \"FractionReps\"             \"Gene\""},{"path":[]},{"path":"/articles/FindingGenes.html","id":"extracting-genes-from-the-genome","dir":"Articles","previous_headings":"Analyzing the Output","what":"Extracting genes from the genome","title":"The Magic of Gene Finding","text":"Predictions hand, first thing can extract genes genome. can easily done using ExtractGenes. see first gene start codon last gene stop codon. implies genes likely connect genome circular genome end splits one gene two. Therefore, first predicted gene’s first codon true start codon need drop first sequence analysis start codons. can look distribution predicted start codons : typical three bacterial initiation codons, “ATG”, “GTG”, “TTG”, one predicted non-canonical initiation codon: “CTG”. Let’s take closer look genes non-canonical initiation codons: worked like charm, let’s look predicted protein sequences translating genes: genes start methionine (“M”) residue end stop (“*“) except first last gene wrap around end genome. inclined, easily remove first last positions :","code":"dna <- ExtractGenes(genes, genome) dna ## DNAStringSet object of length 897: ##       width seq ##   [1]  1176 GCGGCCGCCCGGGAAATTGCTAAAAGATGGGAG...GGCGTTGGAATAGAGAAGTCGATAGGGAATAA ##   [2]   273 ATGCTTTGTAAAGTTTGTAGAGGATTATCTTCT...GATACCACCACCATCATATGGATAGAGAATAA ##   [3]   303 ATGACAGAGTCATATGTAAACAAAGAAGAAATC...GATTAGTCAAAGTCCCTACAGTTATCAAATAG ##   [4]  1476 ATGTATCGTAAGAGTGCTTTAGAATTAAGAGAT...TGAATGGACTTTTTGACGGAGGAATAGAATAA ##   [5]  1467 ATGGGCATAGCACATACTGAATGGGAGTCTGTG...AATTGCTATTAGCAGCTATGCGAGATATGTAA ##   ...   ... ... ## [893]  3051 ATGCCTTTTTCTTTGAGATCTACATCATTTTGT...TTGTATCCATGGGCTTGAATAGAATCTTTTAA ## [894]   303 ATGCTGGCAACAATTAAAAAAATTACTGTGTTG...GAGATTCTCGCCTAGAATGCAAGAAGATATAA ## [895]  2637 ATGCGACCTGATCATATGAACTTCTGTTGTCTA...CCCTGGATCTGGGGACCACTTACAGGTTCTAG ## [896]    96 ATGTCAAAAAAAAGTAATAATTTACAGACTTTT...ATGAAGAGTTAAGGAAGATTTTTGGATTGTGA ## [897]   600 ATGAGCATCAGGGGAGTAGGAGGCAACGGGAAT...AAGCGAACAAGTTGGCTGGCCCTGACGGGGTA table(subseq(dna[-1], 1, 3)) ##  ## ATG GTG TTG  ## 782  93  21 w <- which(!subseq(dna, 1, 3)  %in% c(\"ATG\", \"GTG\", \"TTG\")) w ## [1] 1 w <- w[-1] # drop the first sequence because it is a fragment w ## integer(0) dna[w] ## DNAStringSet object of length 0 genes[w] ## Genes object of size 0. aa <- ExtractGenes(genes, genome, type=\"AAStringSet\") aa ## AAStringSet object of length 897: ##       width seq ##   [1]   392 AAAREIAKRWEQRVRDLQDKGAARKLLNDPLGR...QVEGILRDMLTNGSQTFRDLMRRWNREVDRE* ##   [2]    91 MLCKVCRGLSSLIVVLGAINTGILGVTGYKVNL...CLNFLKCCFKKRHGDCCSSKGGYHHHHMDRE* ##   [3]   101 MTESYVNKEEIISLAKNAALELEDAHVEEFVTS...DMVTSDFTQEEFLSNVPVSLGGLVKVPTVIK* ##   [4]   492 MYRKSALELRDAVVNRELSVTAITEYFYHRIES...ICQVGYSFQEHSQIKQLYPKAVNGLFDGGIE* ##   [5]   489 MGIAHTEWESVIGLEVHVELNTESKLFSPARNH...GFLVGQIMKRTEGKAPPKRVNELLLAAMRDM* ##   ...   ... ... ## [893]  1017 MPFSLRSTSFCFLACLCSYSYGFASSPQVLTPN...HHFGRAYMNYSLDARRRQTAHFVSMGLNRIF* ## [894]   101 MLATIKKITVLLLSKRKAGIRIDYCALALDAVE...LDASLESAQVRLAGLMLDYWDGDSRLECKKI* ## [895]   879 MRPDHMNFCCLCAAILSSTAVLFGQDPLGETAL...LHRLQTLLNVSYVLRGQSHSYSLDLGTTYRF* ## [896]    32 MSKKSNNLQTFSSRALFHVFQDEELRKIFGL* ## [897]   200 MSIRGVGGNGNSRIPSHNGDGSNRRSQNTKGNN...NLDVNEARLMAAYTSECADHLEANKLAGPDGV subseq(aa, 2, -2) ## AAStringSet object of length 897: ##       width seq ##   [1]   390 AAREIAKRWEQRVRDLQDKGAARKLLNDPLGRR...QQVEGILRDMLTNGSQTFRDLMRRWNREVDRE ##   [2]    89 LCKVCRGLSSLIVVLGAINTGILGVTGYKVNLL...VCLNFLKCCFKKRHGDCCSSKGGYHHHHMDRE ##   [3]    99 TESYVNKEEIISLAKNAALELEDAHVEEFVTSM...EDMVTSDFTQEEFLSNVPVSLGGLVKVPTVIK ##   [4]   490 YRKSALELRDAVVNRELSVTAITEYFYHRIESH...QICQVGYSFQEHSQIKQLYPKAVNGLFDGGIE ##   [5]   487 GIAHTEWESVIGLEVHVELNTESKLFSPARNHF...LGFLVGQIMKRTEGKAPPKRVNELLLAAMRDM ##   ...   ... ... ## [893]  1015 PFSLRSTSFCFLACLCSYSYGFASSPQVLTPNV...IHHFGRAYMNYSLDARRRQTAHFVSMGLNRIF ## [894]    99 LATIKKITVLLLSKRKAGIRIDYCALALDAVEY...QLDASLESAQVRLAGLMLDYWDGDSRLECKKI ## [895]   877 RPDHMNFCCLCAAILSSTAVLFGQDPLGETALL...ALHRLQTLLNVSYVLRGQSHSYSLDLGTTYRF ## [896]    30 SKKSNNLQTFSSRALFHVFQDEELRKIFGL ## [897]   198 SIRGVGGNGNSRIPSHNGDGSNRRSQNTKGNNK...GNLDVNEARLMAAYTSECADHLEANKLAGPDG"},{"path":"/articles/FindingGenes.html","id":"removing-genes-with-too-many-ambiguities","dir":"Articles","previous_headings":"Analyzing the Output","what":"Removing genes with too many ambiguities","title":"The Magic of Gene Finding","text":"Genomes sometimes contain ambiguous positions (e.g., “N”) within open reading frames. ambiguities can make open reading frame look longer actually , giving illusion single gene none (one) present. can easily remove magic number (let’s say 20 5%) ambiguous positions: Abracadabra! genes many ambiguities magically disappeared gene set.","code":"a <- alphabetFrequency(dna, baseOnly=TRUE) w <- which(a[, \"other\"] <= 20 & a[, \"other\"]/width(dna) <= 5) genes <- genes[w]"},{"path":"/articles/FindingGenes.html","id":"taking-a-look-at-the-shortest-genes","dir":"Articles","previous_headings":"Analyzing the Output","what":"Taking a look at the shortest genes","title":"The Magic of Gene Finding","text":"might think finding short genes (< 90 nucleotides) require black magic, FindGenes can quite well. can select subset short genes take look repeatedly called genes iteration: can see FractionReps column always 100% short genes repeatedly identified iteration, suggesting weren’t pulled hat. ’s impressive given short !","code":"w <- which(width(dna) < 90) dna[w] ## DNAStringSet object of length 3: ##     width seq ## [1]    69 ATGAGTCATATAAGTATTCGCAATAGTAGTTATTTATTCGCTAATCCAAATCAAGAAATCGTATTTTGA ## [2]    87 ATGAAATTAAAACAAAAGATCGGAATAAAAACAT...GCTCTGGGCCTTGCGAAAAAAACCAAAAAATAG ## [3]    66 ATGTTAGTGTGGGTTATGAGACAGCCGCGTTATAACTCGGAAGTAGAGAAAAAACAAGATTTTTAG aa[w] ## AAStringSet object of length 3: ##     width seq ## [1]    23 MSHISIRNSSYLFANPNQEIVF* ## [2]    29 MKLKQKIGIKTFGQKKRKALGLAKKTKK* ## [3]    22 MLVWVMRQPRYNSEVEKKQDF* genes[w] ## Genes object of size 3 specifying: ## 3 protein coding genes from 66 to 87 nucleotides. ##  ##       Index Strand  Begin    End TotalScore ... Gene ## 4606      1      1  44025  44093       8.75 ...    1 ## 9793      1      1  94116  94202       8.16 ...    1 ## 45975     1      1 443090 443155       7.93 ...    1 genes[w, \"End\"] - genes[w, \"Begin\"] + 1 # lengths ##  4606  9793 45975  ##    69    87    66 genes[w, \"FractionReps\"] ##  4606  9793 45975  ##     1     1     1"},{"path":"/articles/FindingGenes.html","id":"revealing-the-secrets-of-gene-finding","dir":"Articles","previous_headings":"Analyzing the Output","what":"Revealing the secrets of gene finding","title":"The Magic of Gene Finding","text":"might seem like hocus pocus, predictions made FindGenes supported many scores. scores related make use information region relative gene boundaries. can take look score correlations : Certainly magic gene finding lot scores! can see ribosome binding site score upstream nucleotide score correlated. isn’t just magical thinking, scores rely nucleotides immediately upstream start codon. different scores defined follows: Upstream signals Ribosome Binding Site Score - Binding strength position Shine-Delgarno sequence, well motifs first bases upstream start codon. Upstream Nucleotide Score - Nucleotides position immediately upstream start codon. Upstream Motif Score - K-mer motifs upstream start codon. Start site signals Start Score - Choice start codon relative background distribution open reading frames. Folding Score - Free energy RNA-RNA folding around start codon relative locations upstream downstream start. Initial Codon Score - Choice codons first positions start codon. Gene content signals Coding Score - Usage codons pairs codons within open reading frame. Codon Model - Number codon model best fit open reading frame. Length Score - Length open reading frame relative background lengths expected chance. Autocorrelation Score - degree different codons used sequentially code amino acid. Coupling Score - Likelihood observing neighboring amino acids real proteins. Termination signals Termination Codon Score - Codon bias immediately stop codon. Stop Score - Choice stop codon relative observed distribution possible stop codons.","code":""},{"path":"/articles/FindingGenes.html","id":"taking-a-closer-look-at-the-output","dir":"Articles","previous_headings":"Analyzing the Output","what":"Taking a closer look at the output","title":"The Magic of Gene Finding","text":"particular gene interest, can sometimes useful plot output FindGenes set possible open reading frames predicted genes highlighted. plot function Genes object interactive, possible pan left right setting interact argument equal TRUE. now look beginning genome:","code":""},{"path":[]},{"path":"/articles/FindingGenes.html","id":"examining-the-intergenic-spaces","dir":"Articles","previous_headings":"Incorporating non-coding RNAs","what":"Examining the intergenic spaces","title":"The Magic of Gene Finding","text":"space genes sometimes contains promoter sequences, pseudogenes, non-coding RNA genes interest. can conjure intergenic sequences longer given width (e.g., 30 nucleotides) commands: intergenic regions might similar . can find related intergenic sequences clustering within certain distance (e.g., 20 Since used inexact clustering, clusters containing longest sequences first. can look sequences belonging first cluster: two long intergenic regions probably contain copies ribosomal RNA operon. signature non-coding RNAs tend higher GC content expected. can create plot GC content intergenic regions versus size. Since genome averages 41% GC content, can use statistics add line 95% confidence interval. intergenic regions unexpectedly high GC content.","code":"s <- c(1, genes[, \"End\"] + 1) e <- c(genes[, \"Begin\"] - 1, width(genome)) w <- which(e - s >= 30) intergenic <- unlist(extractAt(genome, IRanges(s[w], e[w]))) intergenic ## DNAStringSet object of length 503: ##       width seq                                             names                ##   [1]   144 ACTGGTATCTACCATAGGTTTG...TATAATCTGAAAGGAAGGCGTT NC_000117.1 Chlam... ##   [2]   200 GACGTTTCTCCAACGTAGATGT...TTGACCATGTTTAGGATGGAAG NC_000117.1 Chlam... ##   [3]    98 TTTGCAGCATCCTCAAAAAAGG...AGGCTTTATCGCTTTTCCAATA NC_000117.1 Chlam... ##   [4]   127 AAAATTATCCCAAAAACAAAAA...ACATAGATTCTAGCACTTCTTA NC_000117.1 Chlam... ##   [5]   312 TTTTCCAACTAGGTGTTATGTA...GCTGATTGTATGATGGAGTGGT NC_000117.1 Chlam... ##   ...   ... ... ## [499]   164 CGCAGGTTAAAAGGGGGATGTT...TTTATCTCTCAGCTTTTGTGTG NC_000117.1 Chlam... ## [500]   596 TAAAGATTTTTCTTTTCAGAAG...AAAGAAGATGTCATCAAACAGG NC_000117.1 Chlam... ## [501]   174 TCGCCAGGTTTCGAGACAAAGT...AACGCAATGCTAGGCAAGGGAA NC_000117.1 Chlam... ## [502]    33 GGGATTCCCCCTAAGAGTCTAAAAGAAGAGGTT               NC_000117.1 Chlam... ## [503]   144 AATTAGAAAAATCAGAATTATC...TTTAGTTTTGGGTTGGTTTGTT NC_000117.1 Chlam... intergenic <- c(intergenic, reverseComplement(intergenic)) names(intergenic) <- c(w, paste(w, \"rc\", sep=\"_\")) clusts <- Clusterize(myXStringSet=intergenic, cutoff=0.3) ## Partitioning sequences by 9-mer similarity: ##  iteration 400 of up to 400 (66.6% coverage) ##  ## Time difference of 0.52 secs ##  ## Sorting by relatedness within 324 groups: ##  iteration 29 of up to 29 (100.0% stability)  ##  ## Time difference of 0.77 secs ##  ## Clustering sequences by 9-mer similarity: ## ================================================================================ ##  ## Clusters via relatedness sorting: 69% (21.2% exclusively) ## Clusters via rare 6-mers: 78.8% (31% exclusively) ## Estimated clustering effectiveness: 99.9% ##  ## Time difference of 1.03 secs t <- sort(table(clusts$cluster), decreasing=TRUE) head(t) # the biggest clusters ##  ##  36  92 149 231  89 199  ##   4   4   4   4   3   3 AlignSeqs(intergenic[clusts$cluster == names(t)[1]], verbose=FALSE) ## DNAStringSet object of length 4: ##     width seq                                               names                ## [1]   224 TTCAGTTCCTTCTATTGCATTTC...TTGTTTTTATTTAATTTGTAGTT 467 ## [2]   224 -----------------------...----------------------- 579 ## [3]   224 -----------------------...----------------------- 47_rc ## [4]   224 -----------------------...----------------------- 54_rc"},{"path":"/articles/FindingGenes.html","id":"finding-and-including-non-coding-rnas","dir":"Articles","previous_headings":"Incorporating non-coding RNAs","what":"Finding and including non-coding RNAs","title":"The Magic of Gene Finding","text":"DECIPHER separate function, FindNonCoding, find non-coding RNAs genome. searches predefined models created multiple sequence alignments non-coding RNAs. Thankfully DECIPHER includes pre-built models non-coding RNAs commonly found bacteria, archaea, eukarya. Since C. trachomatis bacterium, load bacterial models. genomes belonging organisms domains life, simply replace “Bacteria” “Archaea” “Eukarya”. need search models genome can incorporate gene calls. Tada! FindNonCoding outputs object class Genes just like FindGenes. However, non-coding RNAs denoted negative numbers Gene column. number corresponds model identified. can look set non-coding RNAs found C. trachomatis genome: least one tRNA gene found amino acid, well two copies ribosomal RNA gene, RNaseP tmRNA genes. Now, can easily include non-coding RNAs gene calls. worked like magic! Now Genes object contains protein coding genes non-coding RNAs.","code":"data(NonCodingRNA_Bacteria) x <- NonCodingRNA_Bacteria names(x) ##  [1] \"tRNA-Ala\"                             ##  [2] \"tRNA-Arg\"                             ##  [3] \"tRNA-Asn\"                             ##  [4] \"tRNA-Asp\"                             ##  [5] \"tRNA-Cys\"                             ##  [6] \"tRNA-Gln\"                             ##  [7] \"tRNA-Glu\"                             ##  [8] \"tRNA-Gly\"                             ##  [9] \"tRNA-His\"                             ## [10] \"tRNA-Ile\"                             ## [11] \"tRNA-Leu\"                             ## [12] \"tRNA-Lys\"                             ## [13] \"tRNA-Met\"                             ## [14] \"tRNA-Phe\"                             ## [15] \"tRNA-Pro\"                             ## [16] \"tRNA-Ser\"                             ## [17] \"tRNA-Thr\"                             ## [18] \"tRNA-Trp\"                             ## [19] \"tRNA-Tyr\"                             ## [20] \"tRNA-Val\"                             ## [21] \"tRNA-Sec\"                             ## [22] \"rRNA_5S-RF00001\"                      ## [23] \"rRNA_16S-RF00177\"                     ## [24] \"rRNA_23S-RF02541\"                     ## [25] \"tmRNA-RF00023\"                        ## [26] \"tmRNA_Alpha-RF01849\"                  ## [27] \"RNase_P_class_A-RF00010\"              ## [28] \"RNase_P_class_B-RF00011\"              ## [29] \"SsrS-RF00013\"                         ## [30] \"Intron_Gp_I-RF00028\"                  ## [31] \"Intron_Gp_II-RF00029\"                 ## [32] \"SmallSRP-RF00169\"                     ## [33] \"Cyclic-di-GMP_Riboswitch-RF01051\"     ## [34] \"Cyclic-di-AMP_Riboswitch-RF00379\"     ## [35] \"T-box_Leader-RF00230\"                 ## [36] \"Ribosomal_Protein_L10_Leader-RF00557\" ## [37] \"Cobalamin_Riboswitch-RF00174\"         ## [38] \"TPP_Riboswitch-RF00059\"               ## [39] \"SAM_Riboswitch-RF00162\"               ## [40] \"Fluoride_Riboswitch-RF01734\"          ## [41] \"FMN_Riboswitch-RF00050\"               ## [42] \"Glycine_Riboswitch-RF00504\"           ## [43] \"HEARO-RF02033\"                        ## [44] \"Flavo_1-RF01705\"                      ## [45] \"Acido_Lenti_1-RF01687\"                ## [46] \"5'_ureB-RF02514\" rnas <- FindNonCoding(x, genome) ## ================================================================================ ##  ## Time difference of 39.88 secs rnas ## Genes object of size 46 specifying: ## 46 non-coding RNAs from 72 to 2,938 nucleotides. ##  ##   Index Strand  Begin    End TotalScore Gene ## 1     1      1  20663  21082      88.33  -25 ## 2     1      1  42727  42801      69.94   -3 ## 3     1      1  68920  68995      78.62  -15 ## 4     1      0 158662 158736      55.75  -17 ## 5     1      0 158744 158827      52.31  -19 ## 6     1      1 202339 202414      68.64  -10 ## ... with 40 more rows. annotations <- attr(rnas, \"annotations\") m <- match(rnas[, \"Gene\"], annotations) sort(table(names(annotations)[m])) ##  ## RNase_P_class_A-RF00010        SmallSRP-RF00169           tmRNA-RF00023  ##                       1                       1                       1  ##                tRNA-Asn                tRNA-Asp                tRNA-Cys  ##                       1                       1                       1  ##                tRNA-Gln                tRNA-Glu                tRNA-His  ##                       1                       1                       1  ##                tRNA-Ile                tRNA-Lys                tRNA-Phe  ##                       1                       1                       1  ##                tRNA-Trp                tRNA-Tyr        rRNA_16S-RF00177  ##                       1                       1                       2  ##        rRNA_23S-RF02541         rRNA_5S-RF00001                tRNA-Ala  ##                       2                       2                       2  ##                tRNA-Gly                tRNA-Pro                tRNA-Val  ##                       2                       2                       2  ##                tRNA-Arg                tRNA-Met                tRNA-Thr  ##                       3                       3                       3  ##                tRNA-Ser                tRNA-Leu  ##                       4                       5 genes <- FindGenes(genome, includeGenes=rnas) ## Iter  Models Start Motif  Init  Fold UpsNt  Term   RBS  Auto  Stop Genes ## 1          1 18.40                 _                                 931 1          1 18.40                 \\                                 931 1          1 18.40                 |                                 931 1          1 18.40                 /                                 931 1          1 18.40                 _                                 931 1          1 18.40                 \\                                 931 1          1 18.40                 |                                 931 1          1 18.40                 /                                 931 1          1 18.40                 _                                 931 2         12 18.40  0.48  0.91                                       934 3         15 18.38  0.53  1.16  0.41  1.41                           937 4         14 15.59  0.52  1.26  0.46  1.75  0.24                     939 5         12 15.62  0.51  1.25  0.50  1.83  0.25  0.95  0.10  0.07   941 6         12 15.60  0.51  1.25  0.49  1.91  0.25  1.02  0.10  0.07   943 7         11 15.57  0.51  1.25  0.51  1.95  0.26  1.06  0.10  0.07   943 8         11 15.57  0.51  1.25  0.51  1.95  0.26  1.09  0.10  0.07   943 ##  ## Time difference of 18.94 secs genes ## Genes object of size 943 specifying: ## 897 protein coding genes from 66 to 5,361 nucleotides. ## 46 non-coding RNAs from 72 to 2,938 nucleotides. ##  ##   Index Strand Begin  End TotalScore ... Gene ## 1     1      0     1 1176      78.91 ...    1 ## 2     1      1  1321 1593      21.23 ...    1 ## 3     1      0  1794 2096      34.12 ...    1 ## 4     1      0  2108 3583     139.61 ...    1 ## 5     1      0  3585 5051     125.31 ...    1 ## 6     1      1  5150 6241     106.94 ...    1 ## ... with 937 more rows."},{"path":"/articles/FindingGenes.html","id":"annotating-the-protein-coding-genes","dir":"Articles","previous_headings":"","what":"Annotating the protein coding genes","title":"The Magic of Gene Finding","text":"magic doesn’t end . can annotate protein coding genes just like non-coding RNAs. master sleight hand, first need training set labeled protein sequences. exactly included DECIPHER Chlamydia. training sequences named enzyme commission (EC) number three four-letter gene name. process training classifier described elsewhere. now, let’s jump straight solution: Now need take proteins just found FindGenes classify using classifier. Finally, can assign protein coding sequences classification Genes object: little wizardry, can now look top annotations genome.","code":"fas <- system.file(\"extdata\",     \"PlanctobacteriaNamedGenes.fas.gz\",     package=\"DECIPHER\") prot <- readAAStringSet(fas) prot ## AAStringSet object of length 2497: ##        width seq                                            names                ##    [1]   227 MAGPKHVLLVSEHWDLFFQTKE...VGYLFSDDGDKKFSQQDTKLS A0A0H3MDW1|Root;N... ##    [2]   394 MKRNPHFVSLTKNYLFADLQKR...GKREDILAACERLQMAPALQS O84395|Root;2;6;1... ##    [3]   195 MAYGTRYPTLAFHTGGIGESDD...GFCLTALGFLNFENAEPAKVN Q9Z6M7|Root;4;1;1... ##    [4]   437 MMLRGVHRIFKCFYDVVLVCAF...TASFDRTWRALKSYIPLYKNS Q46222|Root;2;4;9... ##    [5]   539 MSFKSIFLTGGVVSSLGKGLTA...FIEFIRAAKAYSLEKANHEHR Q59321|Root;6;3;4... ##    ...   ... ... ## [2493]  1038 MFEEVLQESFDEREKKVLKFWQ...EGTDWDLNGEPTKIIIKKSEY Q6MDY1|Root;6;1;1... ## [2494]   102 MVQIVSQDNFADSIASGLVLVD...VERSVGLKDKDSLVKLISKHQ Q9PJK3|Root;NoEC;... ## [2495]   224 MKPQDLKLPYFWEDRCPKIENH...NLWRSKGEKIFCTEFVKRVGI Q9PL91|Root;2;1;1... ## [2496]   427 MLRRLFVSTFLIFGMVSLYAKD...KIVIGLGEKRFPSWGGFPNNQ Q256H8|Root;NoEC;... ## [2497]   344 MLTLGLESSCDETACALVDAKG...GIHPCARYHWESISASLSPLP Q822Y4|Root;2;3;1... head(names(prot)) ## [1] \"A0A0H3MDW1|Root;NoEC;chxR\"        \"O84395|Root;2;6;1;83;dapL\"        ## [3] \"Q9Z6M7|Root;4;1;1;19;aaxB\"        \"Q46222|Root;2;4;99;Multiple;waaA\" ## [5] \"Q59321|Root;6;3;4;2;pyrG\"         \"P0C0Z7|Root;NoEC;groL\" trainingSet <- LearnTaxa(train=prot,     taxonomy=names(prot),     maxChildren=1) ## ================================================================================ ##  ## Time difference of 0.49 secs trainingSet ##   A training set of class 'Taxa' ##    * K-mer size: 9 ##    * Number of rank levels: 7 ##    * Total number of sequences: 2497 ##    * Number of groups: 532 ##    * Number of problem groups: 0 ##    * Number of problem sequences: 0 annotations <- sapply(ids, function(x) paste(x$taxon[-1], collapse=\"; \")) u_annotations <- unique(annotations) genes[w, \"Gene\"] <- match(annotations, u_annotations) + 1L attr(genes, \"annotations\") <- c(attr(genes, \"annotations\"),     setNames(seq_along(u_annotations) + 1L,         u_annotations)) genes ## Genes object of size 943 specifying: ## 897 protein coding genes from 66 to 5,361 nucleotides. ## 46 non-coding RNAs from 72 to 2,938 nucleotides. ##  ##   Index Strand Begin  End TotalScore ... Gene ## 1     1      0     1 1176      78.91 ...    2 ## 2     1      1  1321 1593      21.23 ...    2 ## 3     1      0  1794 2096      34.12 ...    3 ## 4     1      0  2108 3583     139.61 ...    4 ## 5     1      0  3585 5051     125.31 ...    5 ## 6     1      1  5150 6241     106.94 ...    2 ## ... with 937 more rows. annotations <- attr(genes, \"annotations\") m <- match(genes[, \"Gene\"], annotations) head(sort(table(names(annotations)[m]), decreasing=TRUE)) ##  ## unclassified_Root          tRNA-Leu          tRNA-Ser          tRNA-Arg  ##               567                 5                 4                 3  ##          tRNA-Met          tRNA-Thr  ##                 3                 3"},{"path":"/articles/FindingGenes.html","id":"guaranteeing-repeatability","dir":"Articles","previous_headings":"","what":"Guaranteeing repeatability","title":"The Magic of Gene Finding","text":"FindGenes sometimes uses random sampling increase speed algorithm. reason, gene predictions may change slightly prediction process repeated inputs. applications randomness undesirable, can easily avoided setting random seed using FindGenes. process setting unsetting seed straightforward:","code":"set.seed(123) # choose a whole number as the random seed # then make gene predictions with FindGenes (not shown) set.seed(NULL) # return to the original state by unsetting the seed"},{"path":"/articles/FindingGenes.html","id":"exporting-the-output","dir":"Articles","previous_headings":"","what":"Exporting the output","title":"The Magic of Gene Finding","text":"genes can exported variety formats, including FASTA file writeXStringSet, GenBank (gbk) general feature format (gff) file WriteGenes, delimited file formats (e.g., csv, tab, etc.) write.table. Now know tricks trade, can work magic find new genes!","code":""},{"path":[]},{"path":"/articles/FindingNonCodingRNAs.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The Double Life of RNA: Uncovering Non-Coding RNAs","text":"RNA leads double life messenger (mRNA) alphabet soup roles cell (e.g., rRNA, tRNA, snRNA, tmRNA, etc.). RNAs take life notoriously difficult detect ab initio using bioinformatics. part signature characteristic, single strand RNA folds stable structure, can found many regions genome. makes life difficult clear signature genomic region contains non-coding RNA way protein coding regions. promising approach search intergenic regions high GC-content folded structure conserved across many genomes. single genome want find non-coding RNAs? exactly vignette shows ! can time lives finding non-coding RNAs, must first train models examples known RNAs. case study, tutorial focuses finding known non-coding RNAs genome Chlamydia trachomatis, intracellular bacterial pathogen known causing chlamydia. genome chosen relatively small (~1 Mbp) examples run quickly. Chlamydia harbors standard non-coding RNAs date back near origin life (.e., rRNAs, tRNAs, etc.). also one small RNA (sRNA), named IhtA, found Chlamydiae believed play role regulating life stages. going find IhtA genome C. trachomatis, going use approach find standard non-coding RNAs conserved across many forms life.","code":""},{"path":[]},{"path":"/articles/FindingNonCodingRNAs.html","id":"startup","dir":"Articles","previous_headings":"Getting Started","what":"Startup","title":"The Double Life of RNA: Uncovering Non-Coding RNAs","text":"get started need load DECIPHER package, automatically loads required packages. Searches non-coding RNAs performed function FindNonCoding. Help can accessed via: DECIPHER installed, code tutorial can obtained via:","code":"library(DECIPHER) ## Loading required package: Biostrings ## Loading required package: BiocGenerics ##  ## Attaching package: 'BiocGenerics' ## The following objects are masked from 'package:stats': ##  ##     IQR, mad, sd, var, xtabs ## The following objects are masked from 'package:base': ##  ##     anyDuplicated, aperm, append, as.data.frame, basename, cbind, ##     colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ##     get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply, ##     match, mget, order, paste, pmax, pmax.int, pmin, pmin.int, ##     Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort, ##     table, tapply, union, unique, unsplit, which.max, which.min ## Loading required package: S4Vectors ## Loading required package: stats4 ##  ## Attaching package: 'S4Vectors' ## The following object is masked from 'package:utils': ##  ##     findMatches ## The following objects are masked from 'package:base': ##  ##     expand.grid, I, unname ## Loading required package: IRanges ## Loading required package: XVector ## Loading required package: GenomeInfoDb ##  ## Attaching package: 'Biostrings' ## The following object is masked from 'package:base': ##  ##     strsplit ## Loading required package: RSQLite ## Loading required package: parallel > ? FindNonCoding > browseVignettes(\"DECIPHER\")"},{"path":"/articles/FindingNonCodingRNAs.html","id":"building-a-non-coding-rna-model","dir":"Articles","previous_headings":"","what":"Building a Non-Coding RNA Model","title":"The Double Life of RNA: Uncovering Non-Coding RNAs","text":"can find non-coding RNA, need create multiple sequence alignment sequence representatives. alignment input LearnNonCoding.","code":""},{"path":"/articles/FindingNonCodingRNAs.html","id":"importing-the-sequences","dir":"Articles","previous_headings":"Building a Non-Coding RNA Model","what":"Importing the sequences","title":"The Double Life of RNA: Uncovering Non-Coding RNAs","text":"first step set filepaths sequences (FASTA format). case going use IhtA sequences included DECIPHER, follow along set homologous sequences. sure change path names system replacing text inside quotes labeled “\\(<<\\)path …\\(>>\\)” actual path system. Ideally start thousand diverse sequence representatives, yet 27 representatives IhtA known. ’s life, make due available.","code":"# specify the path to your genome: fas_path <- \"<<path to FASTA file>>\" # OR use the example genome: fas_path <- system.file(\"extdata\",     \"IhtA.fas\",     package=\"DECIPHER\")  # read the sequences into memory rna <- readRNAStringSet(fas_path) rna ## RNAStringSet object of length 27: ##      width seq                                              names                ##  [1]   103 AAGAUGAUAUUCUGCGCCAUGGA...UGAUUGUUGUUUUCUUGGCUUU KE360988.1/6443-6... ##  [2]   105 AAGAUGAUAUUCUCCGCCGUGGA...AACUUUAUGUUUUCUUGGCUUU AE002161.1/54676-... ##  [3]   107 AAGUUGGUAUUCUAACGCCAUGG...UAUCUCCGGUUCUCUUGGCUUU AE001273.1/773281... ##  [4]   107 AAGUUGGUAUUCUAACGCCAUGG...UGUCUCCAGUUCUCUUGGCUUU AE002160.2/53054-... ##  [5]   103 AAGAUGAUAUUCUACGCCAUGGA...UGAUUGUUGUUUUCUUGGCUUU AE015925.1/52097-... ##  ...   ... ... ## [23]   107 AAGUUGGUAUUCUAACGCCAUGG...UAUCUCCGGUUCUCUUGGCUUU CP006674.1 Chlamy... ## [24]   103 AAGAUGAUAUUCUGCGCCAUGGA...UGAUUGUUGUUUUCUUGGCUUU KE356008.1 Chlamy... ## [25]   108 AAGUUGGUAUUCUAACGCCAUGG...UAUCUCCGGUUCUCUUGGCUUU CVNC01000001.1 Ch... ## [26]   103 AAGAUGAUAUUCUGCGCCAUGGA...UGAUUGUUGUUUUCUUGGCUUU AP006861.1 Chlamy... ## [27]   101 AAGAUGAUAUUCUACGCCAUGGA...AUGAUGUUGUUUUCUUGGCUUU CP015840.1 Chlamy..."},{"path":"/articles/FindingNonCodingRNAs.html","id":"aligning-the-sequences","dir":"Articles","previous_headings":"Building a Non-Coding RNA Model","what":"Aligning the sequences","title":"The Double Life of RNA: Uncovering Non-Coding RNAs","text":"Next need align sequences AlignSeqs. Note non-coding RNA alignments accurate provide sequences RNAStringSet rather equivalent DNAStringSet, AlignSeqs use conserved secondary structure improve alignment. Alignment fast, hold dear life! (Consider adding processors=NULL want go even faster multiple processors.) can see alignment sequences conserved variable regions. really want bring sequences life need look predicted secondary structures. IhtA believed form three back--back hairpin loops based minimum free energy structure. can use PredictDBN predict secondary structures sequences. color scheme, blue regions pair green regions red regions unpaired. clear evidence hairpin loop near 3’-end IhtA, weaker evidence conserved secondary structure elsewhere sequences (Fig. @ref(f1)). can also visualize secondary structure dot plot (Fig. @ref(f2)). One half dot plot shows probabilities pairing, half shows predicted structure. view reveals level ambiguity secondary structure based (low) amount available information. Two considerations important stage: () clearly defined boundary representing true beginning end every sequence, (ii) sequences diverse sample hope find. don’t partial sequences, identified counting gaps (“-”) ends TerminalChar. partial sequences removed proceeding, example using: Rather remove partial sequences, possible shorten alignment region shared sequences using subseq.","code":"RNA <- AlignSeqs(rna) ## Determining distance matrix based on shared 7-mers: ## ================================================================================ ##  ## Time difference of 0 secs ##  ## Clustering into groups by similarity: ## ================================================================================ ##  ## Time difference of 0 secs ##  ## Aligning Sequences: ## ================================================================================ ##  ## Time difference of 0.05 secs ##  ## Iteration 1 of 2: ##  ## Determining distance matrix based on alignment: ## ================================================================================ ##  ## Time difference of 0 secs ##  ## Reclustering into groups by similarity: ## ================================================================================ ##  ## Time difference of 0 secs ##  ## Realigning Sequences: ## ================================================================================ ##  ## Time difference of 0.02 secs ##  ## Iteration 2 of 2: ##  ## Determining distance matrix based on alignment: ## ================================================================================ ##  ## Time difference of 0 secs ##  ## Reclustering into groups by similarity: ## ================================================================================ ##  ## Time difference of 0 secs ##  ## Realigning Sequences: ## ================================================================================ ##  ## Time difference of 0 secs RNA ## RNAStringSet object of length 27: ##      width seq                                              names                ##  [1]   113 AAGAUGAUAUUCUG-CGCCAUGG...GAUUGU-UGUUUUCUUGGCUUU KE360988.1/6443-6... ##  [2]   113 AAGAUGAUAUUCUC-CGCCGUGG...AACUUUAUGUUUUCUUGGCUUU AE002161.1/54676-... ##  [3]   113 AAGUUGGUAUUCUAACGCCAUGG...--UCUCCGGUUCUCUUGGCUUU AE001273.1/773281... ##  [4]   113 AAGUUGGUAUUCUAACGCCAUGG...--UCUCCAGUUCUCUUGGCUUU AE002160.2/53054-... ##  [5]   113 AAGAUGAUAUUCUA-CGCCAUGG...GAUUGU-UGUUUUCUUGGCUUU AE015925.1/52097-... ##  ...   ... ... ## [23]   113 AAGUUGGUAUUCUAACGCCAUGG...--UCUCCGGUUCUCUUGGCUUU CP006674.1 Chlamy... ## [24]   113 AAGAUGAUAUUCUG-CGCCAUGG...GAUUGU-UGUUUUCUUGGCUUU KE356008.1 Chlamy... ## [25]   113 AAGUUGGUAUUCUAACGCCAUGG...--UCUCCGGUUCUCUUGGCUUU CVNC01000001.1 Ch... ## [26]   113 AAGAUGAUAUUCUG-CGCCAUGG...GAUUGU-UGUUUUCUUGGCUUU AP006861.1 Chlamy... ## [27]   113 AAGAUGAUAUUCUA-CGCCAUGG...GAU-GU-UGUUUUCUUGGCUUU CP015840.1 Chlamy... p <- PredictDBN(RNA, type=\"structures\") ## Determining distance matrix based on alignment: ## ================================================================================ ##  ## Time difference of 0 secs ##  ## Determining sequence weights: ## ================================================================================ ##  ## Time difference of 0 secs ##  ## Computing Free Energies: ## ================================================================================ ##  ## Time difference of 0.19 secs ##  ## Predicting RNA Secondary Structures: ## ================================================================================ ##  ## Time difference of 0 secs BrowseSeqs(RNA, patterns=p) RNA <- unique(RNA) t <- TerminalChar(RNA) w <- which(t[, \"leadingChar\"] <= median(t[, \"leadingChar\"]) &     t[, \"trailingChar\"] <= median(t[, \"trailingChar\"])) RNA <- RemoveGaps(RNA[w], \"common\")"},{"path":"/articles/FindingNonCodingRNAs.html","id":"learning-sequence-patterns","dir":"Articles","previous_headings":"Building a Non-Coding RNA Model","what":"Learning sequence patterns","title":"The Double Life of RNA: Uncovering Non-Coding RNAs","text":"Now need build model capturing essential characteristics non-coding RNA. function LearnNonCoding takes alignment input outputs object class NonCoding describes sequences. output object list containing patterns three types: “motifs”, “hairpins”, “kmers”. Motifs short regions sequence can used identify sequences: Note motifs contain ambiguity codes (see IUPAC_CODE_MAP) represent multiple nucleotides. Motifs defined distance end non-coding RNA, prevalence across sequence representatives allowing certain degree distance. Hairpins defined similarly, allow ambiguity form varying free energy (dG). saw predicted structures, IhtA sequences end prominent hairpin long low free energy. Finally, sequences identifiable k-mer frequencies. general, non-coding RNAs higher GC-content protein coding regions genomes. Note value “k” set automatically depending amount information input sequence alignment.","code":"y <- LearnNonCoding(RNA) y ## NonCoding object with 17 motifs, 5 hairpins, and 2-mer frequencies. y[[\"motifs\"]] ##    begin_low begin_high end_low end_high         motif          pwm ## 1          0          0      96      100       AAGATGr 0.945907.... ## 2          7          7      89       93       TATTCTA 0.018030.... ## 3         14         15      82       86       CGCCATG 0.018361.... ## 4         21         22      81       85             G 0.018030.... ## 5         22         23      72       76     AATAGCTTC 0.911521.... ## 6         31         33      59       63  rACTCTGkTGyw 0.455021.... ## 7         44         45      57       61             T 0.042112.... ## 8         45         50      48       52     tCAGGGGGA 0.215551.... ## 9         54         59      39       43     AAGCCAAGA 0.945907.... ## 10        64         70      34       38           rwr 0.583125.... ## 11        68         74      20       24 rdmGTydGCCGTA 0.549315.... ## 12        82         86      19       20             A 0.945907.... ## 13        84         87      18       19             y 0.018361.... ## 14        85         88      17       18             T 0.018361.... ## 15        86         89      15       16            kT 0.018361.... ## 16        88         92       8        8       tGTTTTC 0.168051.... ## 17        95         99       0        0      TTGGCTTT 0.018030.... ##        minscore   prevalence   background ## 1  0, 2.084.... 0.035714.... 0.969625.... ## 2  0, 5.945.... 0.035714.... 0.977719.... ## 3  0, 5.985.... 0.035714.... 0.983537.... ## 4        0, Inf 0.053728.... 0.548870.... ## 5  0, 7.982.... 0.053728.... 0.981393.... ## 6  0, 7.010.... 0.035714.... 0.975258.... ## 7        0, Inf 0.021524.... 0.449935.... ## 8  0, 4.568.... 0.115007.... 0.961752.... ## 9  0, 9.438.... 0.069671.... 0.978789.... ## 10 1.165281.... 0.122610.... 0.549385.... ## 11 0, 7.108.... 0.035714.... 0.971548.... ## 12       0, Inf 0.119267.... 0.582877.... ## 13 0.377645.... 0.069671.... 0.449935.... ## 14       0, Inf 0.035714.... 0.449935.... ## 15 0, 0.743.... 0.076484.... 0.436916.... ## 16 0, 4.681.... 0.035714.... 0.949261.... ## 17       0, Inf 0.035714.... 0.990777.... y[[\"hairpins\"]] ##   begin_low begin_high end_low end_high width_low width_high length_low ## 1        -4          1      63       72        31         44          6 ## 2         7          7      77       81        19         20          8 ## 3        25         31      42       52        24         40          5 ## 4        31         35      48       54        19         24          5 ## 5        49         58      -4        0        49         61         13 ##   length_high           dG   prevalence   background ## 1          12 -Inf, -2.... 0.296145.... 0.212328.... ## 2           8 -Inf, -3.... 0.753849.... 0.008085.... ## 3           8 -Inf, -5.... 0.238152.... 0.086002.... ## 4           9 -Inf, -9.... 0.231175.... 0.003465.... ## 5          26 -Inf, -2.... 0.142687.... 0.000105.... head(y[[\"kmers\"]]) ## [1] 185 109 183 162  78  83 tail(y[[\"kmers\"]]) ## [1] 237 221 216 218 155 339"},{"path":"/articles/FindingNonCodingRNAs.html","id":"finding-non-coding-rnas","dir":"Articles","previous_headings":"","what":"Finding Non-Coding RNAs","title":"The Double Life of RNA: Uncovering Non-Coding RNAs","text":"Now captured life force sequences, next goal find homologous non-coding RNAs genome. can either use genome follow along example C. trachomatis genome. function FindNonCoding finds matches NonCoding models genome. Let’s search IhtA model Chlamydia genome: ! output tells us IhtA gene found forward strand first sequence (\"Index\") genome. match high score first () model y (.e., \"Gene\" -1). Values \"Gene\" column negative signify non-coding RNAs protein coding genes. Life’s short build models every non-coding RNA, can load set pre-built models bacterial genome. Replace “Bacteria” “Archaea” “Eukarya” genomes organisms belonging domains life. life saver! new dataset (x) list models, including tRNAs (amino acid), transfer-messenger RNA, RNase P, SsrS (6S RNA), group II introns, signal recognition particle, three rRNAs (5S, 16S, 23S). Let’s add model built IhtA list: Now can search FindNonCoding: Wow! one life’s simplest pleasures. FindNonCoding returned object class Genes. convention, starting position non-coding RNAs forward (0) Strand Begin, reverse (1) Strand start End. can take look RNAs found: see C. trachomatis genome multiple tRNA genes, two copies ribosomal RNA gene, RNaseP tmRNA genes. Finally, possible extract non-coding RNAs genome: ’ll life party now know build models non-coding RNAs find genome.","code":"# specify the path to your genome: genome_path <- \"<<path to genome FASTA file>>\" # OR use the example genome: genome_path <- system.file(\"extdata\",     \"Chlamydia_trachomatis_NC_000117.fas.gz\",     package=\"DECIPHER\")  # read the sequences into memory genome <- readDNAStringSet(genome_path) genome ## DNAStringSet object of length 1: ##       width seq                                             names                ## [1] 1042519 GCGGCCGCCCGGGAAATTGCTA...GTTGGCTGGCCCTGACGGGGTA NC_000117.1 Chlam... FindNonCoding(y, genome) ## ================================================================================ ##  ## Time difference of 1.09 secs ## Genes object of size 1 specifying: ## 1 non-coding RNA of 107 nucleotides. ##  ##   Index Strand  Begin    End TotalScore Gene ## 1     1      0 773281 773387      96.13   -1 data(NonCodingRNA_Bacteria) x <- NonCodingRNA_Bacteria names(x) ##  [1] \"tRNA-Ala\"                             ##  [2] \"tRNA-Arg\"                             ##  [3] \"tRNA-Asn\"                             ##  [4] \"tRNA-Asp\"                             ##  [5] \"tRNA-Cys\"                             ##  [6] \"tRNA-Gln\"                             ##  [7] \"tRNA-Glu\"                             ##  [8] \"tRNA-Gly\"                             ##  [9] \"tRNA-His\"                             ## [10] \"tRNA-Ile\"                             ## [11] \"tRNA-Leu\"                             ## [12] \"tRNA-Lys\"                             ## [13] \"tRNA-Met\"                             ## [14] \"tRNA-Phe\"                             ## [15] \"tRNA-Pro\"                             ## [16] \"tRNA-Ser\"                             ## [17] \"tRNA-Thr\"                             ## [18] \"tRNA-Trp\"                             ## [19] \"tRNA-Tyr\"                             ## [20] \"tRNA-Val\"                             ## [21] \"tRNA-Sec\"                             ## [22] \"rRNA_5S-RF00001\"                      ## [23] \"rRNA_16S-RF00177\"                     ## [24] \"rRNA_23S-RF02541\"                     ## [25] \"tmRNA-RF00023\"                        ## [26] \"tmRNA_Alpha-RF01849\"                  ## [27] \"RNase_P_class_A-RF00010\"              ## [28] \"RNase_P_class_B-RF00011\"              ## [29] \"SsrS-RF00013\"                         ## [30] \"Intron_Gp_I-RF00028\"                  ## [31] \"Intron_Gp_II-RF00029\"                 ## [32] \"SmallSRP-RF00169\"                     ## [33] \"Cyclic-di-GMP_Riboswitch-RF01051\"     ## [34] \"Cyclic-di-AMP_Riboswitch-RF00379\"     ## [35] \"T-box_Leader-RF00230\"                 ## [36] \"Ribosomal_Protein_L10_Leader-RF00557\" ## [37] \"Cobalamin_Riboswitch-RF00174\"         ## [38] \"TPP_Riboswitch-RF00059\"               ## [39] \"SAM_Riboswitch-RF00162\"               ## [40] \"Fluoride_Riboswitch-RF01734\"          ## [41] \"FMN_Riboswitch-RF00050\"               ## [42] \"Glycine_Riboswitch-RF00504\"           ## [43] \"HEARO-RF02033\"                        ## [44] \"Flavo_1-RF01705\"                      ## [45] \"Acido_Lenti_1-RF01687\"                ## [46] \"5'_ureB-RF02514\" x[[length(x) + 1]] <- y names(x)[length(x)] <- \"IhtA\" rnas <- FindNonCoding(x, genome) ## ================================================================================ ##  ## Time difference of 38.96 secs rnas ## Genes object of size 47 specifying: ## 47 non-coding RNAs from 72 to 2,938 nucleotides. ##  ##   Index Strand  Begin    End TotalScore Gene ## 1     1      1  20663  21082      88.33  -25 ## 2     1      1  42727  42801      69.94   -3 ## 3     1      1  68920  68995      78.62  -15 ## 4     1      0 158662 158736      55.75  -17 ## 5     1      0 158744 158827      52.31  -19 ## 6     1      1 202339 202414      68.64  -10 ## ... with 41 more rows. class(rnas) ## [1] \"Genes\" annotations <- attr(rnas, \"annotations\") m <- match(rnas[, \"Gene\"], annotations) sort(table(names(annotations)[m])) ##  ##                    IhtA RNase_P_class_A-RF00010        SmallSRP-RF00169  ##                       1                       1                       1  ##           tmRNA-RF00023                tRNA-Asn                tRNA-Asp  ##                       1                       1                       1  ##                tRNA-Cys                tRNA-Gln                tRNA-Glu  ##                       1                       1                       1  ##                tRNA-His                tRNA-Ile                tRNA-Lys  ##                       1                       1                       1  ##                tRNA-Phe                tRNA-Trp                tRNA-Tyr  ##                       1                       1                       1  ##        rRNA_16S-RF00177        rRNA_23S-RF02541         rRNA_5S-RF00001  ##                       2                       2                       2  ##                tRNA-Ala                tRNA-Gly                tRNA-Pro  ##                       2                       2                       2  ##                tRNA-Val                tRNA-Arg                tRNA-Met  ##                       2                       3                       3  ##                tRNA-Thr                tRNA-Ser                tRNA-Leu  ##                       3                       4                       5 ExtractGenes(rnas, genome, type=\"RNAStringSet\") ## RNAStringSet object of length 47: ##      width seq ##  [1]   420 GGGGGUGUAAAGGUUUCGACUUAGAAAUGAAGC...AGGACGAGAGUUCGACUCUCUCCACCUCCAUAG ##  [2]    75 UCCGGAGUAGCUCAGCGGUAGAGCAGUGGACUG...UGGUCGUUGGUUCGAACCCAUCCUCCGGAGUCU ##  [3]    76 CGGAGUAUAGCGCAGCCUGGUUAGCGCGGUUGC...AUAGGUCGGGGGUUCGAAUCCCUCUACUCCGAU ##  [4]    75 GCUGGAGUAGCUCAAUUGGCAGAGCAUUCGAUU...ACGGUUGAGGGUUCAAUUCCUUUCUCCAGCAUC ##  [5]    84 GGGGGUGUCGCAUAGCGGUCAAUUGCAUCGGAC...CGGAUACGUUGGUUCAAAUCCAGCCACCCCCAG ##  ...   ... ... ## [43]    72 GGUGGCAUCGCCAAGCGGUAAGGCCGAGGCCUG...CUCUAUCCCCGGUUCGAUUCCGGGUGCCACCUU ## [44]    74 UGGGGUGUGGCCAAGCGGUAAGGCAGCGGUUUU...CGCAUCGGAGGUUCGAAUCCUUCCACCCCAGAG ## [45]    75 GGGGUAUUAGCUCAGUUGGUUAGAGCGUCACGU...GAAGGUCAGCUGUUCAAGUCAGCUAUAUCCCAA ## [46]    88 GGAAGAAUGGCAGAGCGGUUUAAUGCACCUGUC...GGUCCGGGGGUUCGAAUCCCUCUUCUUCCGCAU ## [47]    85 GCCCAGGUGGUGAAAUUGGUAGACACGCUGGAU...GGCAUGUAGGUUCAAGUCCUAUCCUGGGCAUAG"},{"path":"/articles/GrowingTrees.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Growing phylogenetic trees with TreeLine","text":"document describes grow phylogenetic trees using TreeLine function DECIPHER package. TreeLine takes input set aligned nucleotide amino acid sequences returns phylogenetic tree (.e., dendrogram object) output. vignette focuses building maximum likelihood (ML) maximum parsimony (MP) phylogenetic trees starting sequences, TreeLine can also used build additive trees distance matrix. function called TreeLine? goal TreeLine find likely/parsimonious tree given sequence alignment. often many trees nearly maximal likelihood/parsimony. Therefore, TreeLine seeks find tree close possible treeline, analogous trees can grow treeline mountain. use TreeLine versus programs? TreeLine function designed return excellent phylogenetic tree minimal user intervention. Many tree building programs large set complex options niche applications. contrast, TreeLine simply builds great tree relying defaults. vignette intended get started introduce additional options/functions might useful. TreeLine uses multi-start optimization followed hill-climbing find highest trees likelihood parsimony landscapes. Since TreeLine stochastic optimizer, optimizes many trees prevent luck influencing final result. main difference approaches tree optimization TreeLine heavily uses past trees generate new trees optimizes. luck ’ll find treeline!","code":""},{"path":"/articles/GrowingTrees.html","id":"performance-considerations","dir":"Articles","previous_headings":"","what":"Performance Considerations","title":"Growing phylogenetic trees with TreeLine","text":"Finding tree high likelihood/parsimony easy feat. TreeLine systematically optimizes hundreds thousands candidate trees returning best one. takes time, things can make go faster. use sequences need: TreeLine scales bit worse quadratically number sequences. Hence, limiting number sequences worthwhile consideration. particular, always eliminate redundant sequences, shown , remove sequences necessary. concern shared tree building programs, TreeLine exception. Set timeout: maxTime argument specifies (approximate) maximum number hours willing let TreeLine run. concerned code running long simply specify argument. Compile OpenMP support: Significant speed-ups can achieved multi-threading using OpenMP. See “Getting Started DECIPHERing” vignette computer platform. need set argument processors=NULL TreeLine use available processors.","code":""},{"path":"/articles/GrowingTrees.html","id":"growing-a-phylogenetic-tree","dir":"Articles","previous_headings":"","what":"Growing a Phylogenetic Tree","title":"Growing phylogenetic trees with TreeLine","text":"TreeLine takes input multiple sequence alignment constructing maximum likelihood maximum parsimony phylogenetic tree. Multiple sequence alignments can constructed set (unaligned) sequences using AlignSeqs related functions. TreeLine optimize trees amino acid (.e., AAStringSet) nucleotide (.e., DNAStringSet RNAStringSet) sequences. , going use set sequences included DECIPHER. sequences internal transcribed spacer () 16S 23S ribosomal RNA genes several Streptomyces species. Many sequences redundant genome. can de-replicate sequences accelerate tree building: Now, ’s time try luck finding likely tree. , set stringent time limit (0.05 hours) make example faster, although longer time limits (e.g., 24 hours) advised setting short time limits leaves result luck. Note TreeLine automatically selects substitution model based Akaike information criterion (default). possible specify specific model(s) (e.g., model=\"GTR+G4\") limit possible selections test luck fewer models. Also, since TreeLine stochastic optimizer, critical always set random number seed reproducibility. can pick lucky number, every wonder much pushed luck, can try running different random number seed see much result came luck draw. {#f1} Maximum likelihood tree showing relationships Streptomyces species.","code":"library(DECIPHER) ## Loading required package: Biostrings ## Loading required package: BiocGenerics ##  ## Attaching package: 'BiocGenerics' ## The following objects are masked from 'package:stats': ##  ##     IQR, mad, sd, var, xtabs ## The following objects are masked from 'package:base': ##  ##     anyDuplicated, aperm, append, as.data.frame, basename, cbind, ##     colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ##     get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply, ##     match, mget, order, paste, pmax, pmax.int, pmin, pmin.int, ##     Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort, ##     table, tapply, union, unique, unsplit, which.max, which.min ## Loading required package: S4Vectors ## Loading required package: stats4 ##  ## Attaching package: 'S4Vectors' ## The following object is masked from 'package:utils': ##  ##     findMatches ## The following objects are masked from 'package:base': ##  ##     expand.grid, I, unname ## Loading required package: IRanges ## Loading required package: XVector ## Loading required package: GenomeInfoDb ##  ## Attaching package: 'Biostrings' ## The following object is masked from 'package:base': ##  ##     strsplit ## Loading required package: RSQLite ## Loading required package: parallel # specify the path to your sequence file: fas <- \"<<path to FASTA file>>\" # OR find the example sequence file used in this tutorial: fas <- system.file(\"extdata\", \"Streptomyces_ITS_aligned.fas\", package=\"DECIPHER\")  seqs <- readDNAStringSet(fas) # use readAAStringSet for amino acid sequences seqs # the aligned sequences ## DNAStringSet object of length 88: ##      width seq                                              names                ##  [1]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTTTCCGAATGGGGAAACC supercont3.1 of S... ##  [2]   627 NNNNCACACCGCCCGTCA-CGTC...GGGGTTTCCGAATGGGGAAACC supercont3.1 of S... ##  [3]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTTTCCGAATGGGGAAACC supercont1.1 of S... ##  [4]   627 CGTACACACCGCCCGTCA-CGTC...GGGGTTTCCGAATGGGGAAACC supercont1.1 of S... ##  [5]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTTTCCGAATGGGGAAACC supercont1.1 of S... ##  ...   ... ... ## [84]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTTTCCGAATGGGGAAACC gi|297189896|ref|... ## [85]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTGTCCGAATGGGGAAACC gi|224581106|ref|... ## [86]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTGTCCGAATGGGGAAACC gi|224581106|ref|... ## [87]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTGTCCGAATGGGGAAACC gi|224581106|ref|... ## [88]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTTTCCGAATGGGGAAACC gi|224581108|ref|... seqs <- unique(seqs) # remove duplicated sequences  ns <- gsub(\"^.*Streptomyces( subsp\\\\. | sp\\\\. | | sp_)([^ ]+).*$\", \"\\\\2\", names(seqs)) names(seqs) <- ns # name by species seqs <- seqs[!duplicated(ns)] # remove redundant sequences from the same species seqs ## DNAStringSet object of length 19: ##      width seq                                              names                ##  [1]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTTTCCGAATGGGGAAACC albus ##  [2]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTTTCCGAATGGGGAAACC clavuligerus ##  [3]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTGTCCGAATGGGGAAACC ghanaensis ##  [4]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTTTCCGAATGGGGAAACC griseoflavus ##  [5]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTGTCCGAATGGGGAAACC lividans ##  ...   ... ... ## [15]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTGTCCGAATGGGGAAACC cattleya ## [16]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTTTCCGAATGGGGAAACC bingchenggensis ## [17]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTTTCCGAATGGGGAAACC avermitilis ## [18]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTGTCCGAATGGGGAAACC C ## [19]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTGTCCGAATGGGGAAACC Tu6071 set.seed(123) # set the random number seed  tree <- TreeLine(seqs, reconstruct=TRUE, maxTime=0.05) # default is method=\"ML\" ## Optimizing model parameters: JC69     -ln(L) = 5039, AICc = 10152, BIC = 10300 JC69+G4  -ln(L) = 4723, AICc = 9523, BIC = 9675 K80      -ln(L) = 4983, AICc = 10042, BIC = 10194 K80+G4   -ln(L) = 4413, AICc = 8905, BIC = 9061 F81      -ln(L) = 5020, AICc = 10121, BIC = 10281 F81+G4   -ln(L) = 4464, AICc = 9012, BIC = 9176 HKY85    -ln(L) = 4953, AICc = 9989, BIC = 10154 HKY85+G4 -ln(L) = 4371, AICc = 8829, BIC = 8997 T92      -ln(L) = 4965, AICc = 10010, BIC = 10166 T92+G4   -ln(L) = 4394, AICc = 8869, BIC = 9029 TN93     -ln(L) = 4942, AICc = 9969, BIC = 10138 TN93+G4  -ln(L) = 4371, AICc = 8831, BIC = 9004 SYM      -ln(L) = 4954, AICc = 9995, BIC = 10163 SYM+G4   -ln(L) = 4406, AICc = 8900, BIC = 9072 GTR      -ln(L) = 4929, AICc = 9951, BIC = 10132 GTR+G4   -ln(L) = 4368, AICc = 8832, BIC = 9017 ##  ## The selected model was:  HKY85+G4 ##  ## PHASE 1 OF 3: INITIAL TREES ##  ## 1/3. Optimizing initial tree #1 of 10 to 100: ## -ln(L) = 4369.3 (-0.048%), 1 Climb   ## 1/3. Optimizing initial tree #2 of 10 to 100: ## -ln(L) = 4403.7 (+0.781%), 2 Climbs   ## 1/3. Optimizing initial tree #3 of 11 to 100: ## -ln(L) = 4367.8 (-0.033%), 6 Climbs   ##  ## PHASE 2 OF 3: REGROW GENERATION 1 OF 10 TO 20 ##  ## 2/3. Optimizing regrown tree #1 of 10 to 100: ## -ln(L) = 4367.8 (-0.001%), 1 Climb   ## 2/3. Optimizing regrown tree #2 of 10 to 100: ## -ln(L) = 4367.8 (~0.000%), 1 Climb   ## 2/3. Optimizing regrown tree #3 of 10 to 100: ## -ln(L) = 4367.8 (0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #4 of 10 to 100: ## -ln(L) = 4369.3 (+0.035%), 0 Climbs   ## 2/3. Optimizing regrown tree #5 of 10 to 100: ## -ln(L) = 4367.8 (~0.000%), 1 Climb   ## 2/3. Optimizing regrown tree #6 of 10 to 100: ## -ln(L) = 4369.3 (+0.035%), 0 Climbs   ## 2/3. Optimizing regrown tree #7 of 10 to 100: ## -ln(L) = 4369.3 (+0.035%), 0 Climbs   ## 2/3. Optimizing regrown tree #8 of 10 to 100: ## -ln(L) = 4369.3 (+0.035%), 0 Climbs   ## 2/3. Optimizing regrown tree #9 of 10 to 100: ## -ln(L) = 4369.3 (+0.035%), 0 Climbs   ## 2/3. Optimizing regrown tree #10 of 10 to 100: ## -ln(L) = 4369.3 (+0.035%), 1 Climb   ##  ## PHASE 2 OF 3: REGROW GENERATION 2 OF 10 TO 20 ##  ## 2/3. Optimizing regrown tree #1 of 10 to 100: ## -ln(L) = 4369.3 (+0.033%), 0 Climbs   ## 2/3. Optimizing regrown tree #2 of 10 to 100: ## -ln(L) = 4367.8 (-0.001%), 1 Climb   ## 2/3. Optimizing regrown tree #3 of 10 to 100: ## -ln(L) = 4369.3 (+0.035%), 1 Climb   ## 2/3. Optimizing regrown tree #4 of 10 to 100: ## -ln(L) = 4367.8 (~0.000%), 1 Climb   ## 2/3. Optimizing regrown tree #5 of 10 to 100: ## -ln(L) = 4367.3 (-0.011%), 2 Climbs   ## 2/3. Optimizing regrown tree #6 of 15 to 100: ## -ln(L) = 4367.8 (+0.011%), 0 Climbs   ## 2/3. Optimizing regrown tree #7 of 15 to 100: ## -ln(L) = 4367.8 (+0.011%), 0 Climbs   ## 2/3. Optimizing regrown tree #8 of 15 to 100: ## -ln(L) = 4367.8 (+0.012%), 2 Climbs   ## 2/3. Optimizing regrown tree #9 of 15 to 100: ## -ln(L) = 4367.8 (+0.011%), 0 Climbs   ## 2/3. Optimizing regrown tree #10 of 15 to 100: ## -ln(L) = 4369.3 (+0.045%), 1 Climb   ## 2/3. Optimizing regrown tree #11 of 15 to 100: ## -ln(L) = 4367.8 (+0.011%), 0 Climbs   ## 2/3. Optimizing regrown tree #12 of 15 to 100: ## -ln(L) = 4367.8 (+0.011%), 1 Climb   ## 2/3. Optimizing regrown tree #13 of 15 to 100: ## -ln(L) = 4369.3 (+0.045%), 0 Climbs   ## 2/3. Optimizing regrown tree #14 of 15 to 100: ## -ln(L) = 4367.8 (+0.011%), 0 Climbs   ## 2/3. Optimizing regrown tree #15 of 15 to 100: ## -ln(L) = 4367.8 (+0.011%), 0 Climbs   ##  ## PHASE 2 OF 3: REGROW GENERATION 3 OF 11 TO 20 ##  ## 2/3. Optimizing regrown tree #1 of 11 to 100: ## -ln(L) = 4367.8 (-0.001%), 1 Climb   ## 2/3. Optimizing regrown tree #2 of 12 to 100: ## -ln(L) = 4369.3 (+0.035%), 0 Climbs   ## 2/3. Optimizing regrown tree #3 of 13 to 100: ## -ln(L) = 4369.3 (+0.035%), 0 Climbs   ## 2/3. Optimizing regrown tree #4 of 14 to 100: ## -ln(L) = 4369.3 (+0.035%), 0 Climbs   ## 2/3. Optimizing regrown tree #5 of 15 to 100: ## -ln(L) = 4369.3 (+0.035%), 1 Climb   ## 2/3. Optimizing regrown tree #6 of 16 to 100: ## -ln(L) = 4367.8 (0.000%), 1 Climb   ## 2/3. Optimizing regrown tree #7 of 17 to 100: ## -ln(L) = 4369.3 (+0.035%), 0 Climbs   ## 2/3. Optimizing regrown tree #8 of 18 to 100: ## -ln(L) = 4367.8 (0.000%), 1 Climb   ## 2/3. Optimizing regrown tree #9 of 19 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #10 of 20 to 100: ## -ln(L) = 4367.8 (+0.001%), 2 Climbs   ## 2/3. Optimizing regrown tree #11 of 21 to 100: ## -ln(L) = 4369.3 (+0.035%), 0 Climbs   ## 2/3. Optimizing regrown tree #12 of 22 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #13 of 23 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #14 of 24 to 100: ## -ln(L) = 4367.3 (-0.011%), 0 Climbs   ## 2/3. Optimizing regrown tree #15 of 24 to 100: ## -ln(L) = 4367.8 (+0.011%), 0 Climbs   ## 2/3. Optimizing regrown tree #16 of 24 to 100: ## -ln(L) = 4367.8 (+0.011%), 0 Climbs   ## 2/3. Optimizing regrown tree #17 of 24 to 100: ## -ln(L) = 4369.3 (+0.045%), 0 Climbs   ## 2/3. Optimizing regrown tree #18 of 24 to 100: ## -ln(L) = 4369.3 (+0.045%), 1 Climb   ## 2/3. Optimizing regrown tree #19 of 24 to 100: ## -ln(L) = 4367.8 (+0.011%), 1 Climb   ## 2/3. Optimizing regrown tree #20 of 24 to 100: ## -ln(L) = 4367.8 (+0.011%), 0 Climbs   ## 2/3. Optimizing regrown tree #21 of 24 to 100: ## -ln(L) = 4369.3 (+0.045%), 0 Climbs   ## 2/3. Optimizing regrown tree #22 of 24 to 100: ## -ln(L) = 4369.3 (+0.045%), 0 Climbs   ## 2/3. Optimizing regrown tree #23 of 24 to 100: ## -ln(L) = 4369.3 (+0.045%), 0 Climbs   ## 2/3. Optimizing regrown tree #24 of 24 to 100: ## -ln(L) = 4367.8 (+0.012%), 2 Climbs   ##  ## PHASE 2 OF 3: REGROW GENERATION 4 OF 11 TO 20 ##  ## 2/3. Optimizing regrown tree #1 of 11 to 100: ## -ln(L) = 4367.8 (-0.001%), 1 Climb   ## 2/3. Optimizing regrown tree #2 of 12 to 100: ## -ln(L) = 4367.8 (~0.000%), 1 Climb   ## 2/3. Optimizing regrown tree #3 of 13 to 100: ## -ln(L) = 4367.8 (+0.001%), 2 Climbs   ## 2/3. Optimizing regrown tree #4 of 14 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #5 of 15 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #6 of 16 to 100: ## -ln(L) = 4367.8 (0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #7 of 17 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #8 of 18 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #9 of 19 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #10 of 20 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #11 of 21 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #12 of 22 to 100: ## -ln(L) = 4367.8 (0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #13 of 23 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #14 of 24 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #15 of 25 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #16 of 26 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #17 of 27 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #18 of 28 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #19 of 29 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #20 of 30 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #21 of 31 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #22 of 32 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #23 of 33 to 100: ## -ln(L) = 4367.8 (~0.000%), 0 Climbs   ## 2/3. Optimizing regrown tree #24 of 34 to 100: ## -ln(L) = 4367.3 (-0.011%), 0 Climbs   ## 2/3. Optimizing regrown tree #25 of 34 to 100: ## -ln(L) = 4367.8 (+0.011%), 0 Climbs   ## 2/3. Optimizing regrown tree #26 of 34 to 100: ## -ln(L) = 4367.8 (+0.011%), 0 Climbs   ## 2/3. Optimizing regrown tree #27 of 34 to 100: ## -ln(L) = 4367.8 (+0.011%), 0 Climbs   ## 2/3. Optimizing regrown tree #28 of 34 to 100: ## -ln(L) = 4367.8 (+0.011%), 0 Climbs   ## 2/3. Optimizing regrown tree #29 of 34 to 100: ## -ln(L) = 4367.8 (+0.011%), 0 Climbs   ## 2/3. Optimizing regrown tree #30 of 34 to 100: ## -ln(L) = 4367.8 (+0.011%), 0 Climbs   ## 2/3. Optimizing regrown tree #31 of 34 to 100: ## -ln(L) = 4367.8 (+0.011%), 0 Climbs   ## 2/3. Optimizing regrown tree #32 of 34 to 100: ## -ln(L) = 4367.8 (+0.011%), 0 Climbs   ## 2/3. Optimizing regrown tree #33 of 34 to 100: ## -ln(L) = 4367.8 (+0.011%), 0 Climbs   ## 2/3. Optimizing regrown tree #34 of 34 to 100: ## -ln(L) = 4367.8 (+0.011%), 0 Climbs   ##  ## PHASE 2 OF 3: REGROW GENERATION 5 OF 11 TO 20 ##  ## 2/3. Optimizing regrown tree #1 of 11 to 100: ## -ln(L) = 4369.3 (+0.033%), 0 Climbs   ##  ## PHASE 3 OF 3: SHAKEN TREES ##  ## Grafting 9 trees to the best tree: ## -ln(L) = 4367.3 (0.000%), 0 Grafts of 6   ##  ## 3/3. Optimizing shaken tree #1 of 3 to 1000: ## -ln(L) = 4368.6 (+0.029%), 4 Climbs   ## 3/3. Optimizing shaken tree #2 of 3 to 1000: ## -ln(L) = 4370.7 (+0.079%), 4 Climbs   ## 3/3. Optimizing shaken tree #3 of 3 to 1000: ## -ln(L) = 4367.9 (+0.015%), 4 Climbs   ##  ## Grafting 3 trees to the best tree: ## -ln(L) = 4367.3 (0.000%), 0 Grafts of 0   ##  ## Model parameters: ## Frequency(A) = 0.179 ## Frequency(C) = 0.234 ## Frequency(G) = 0.344 ## Frequency(T) = 0.243 ## Transition rates = 3.673 ## Transversion rates = 1 ## Alpha = 0.193 ##  ## Time difference of 149.12 secs set.seed(NULL) # reset seed  plot(tree)"},{"path":"/articles/GrowingTrees.html","id":"plotting-branch-support-values","dir":"Articles","previous_headings":"","what":"Plotting Branch Support Values","title":"Growing phylogenetic trees with TreeLine","text":"Maybe just beginner’s luck, already reasonable looking starting tree! TreeLine automatically returns variety information tree can accessed attributes attr functions: tree (virtually) rooted midpoint default. maximum likelihood trees, internal nodes include aBayes branch support values [@Anisimova:2011]. given probabilities can used plotting top edge. can also italicize species names. lucked maximum likelihood maximum parsimony trees provide branch supports form fraction optimized trees contained given partition (branch). accessible “support” attribute. luck , support values (aBayes) probabilities correlated, support tends conservative.","code":"attributes(tree) # view all attributes ## $members ## [1] 19 ##  ## $height ## [1] 2.411835 ##  ## $state ## [1] \"------CACCGCCCGTCA-CGTCACGAAAGTCGGTAACACCCGAAGCCGGTGGCCCAACCCGTAA-GGGAGGGAGCTGTCGAAGGTGGGACCAGCGATTGGGACGAAGTCGTAACAAGGTAGCCGTACCGGAAGGTGCGGCTGGATCACCTCCTTTCTAAGGAGCACGTCGGGCCGGGGGGGTGGG------------AGGACCCAGGACGTCGGCGAATGTTCGGGACCGGTTAGCTCATGGGTGGAACGTTGACTAGTTGGCACG---GGGGGGGGGGGGGTCAGGAGTACTGCTTCTTGGGGGCGTGGAAGGT---GGGGGGGGGGGGCGGGGGGGGGGGCTGGCACGTTGTTG-GGTGTCTGAGGGGACGGCCGG-----GGGCGGGGGGTCGGT-------CCGGCCCCGGTGGA-------------GGGGGGGGGGTGAGGGGTG------CGTTGTTTGAGAACTGCACAGTGGACGCGAGCATCT--GTGGCCAAGTTTTTAAGGGCGCACGGTGGATGCCTTGGCACCAGGAACCGATGAAGGACGTGGGAGGCCGCGATAGGCCCCGGGGAGGTGTCAACCGAGCTTTGATCCGGGGGTGTCCGAATGGGGAAACC\" ##  ## $class ## [1] \"dendrogram\" ##  ## $siteLnLs ##   [1]  -1.977113  -1.587972  -1.977113  -2.326699  -2.019363  -2.326699 ##   [7]  -2.168049  -2.479464  -2.168049  -2.168049  -1.723300  -2.168049 ##  [13]  -2.168049  -2.168049  -1.723300  -2.124848  -2.168049  -2.479464 ##  [19]   0.000000  -2.168049  -1.723300  -2.124848  -2.168049  -2.479464 ##  [25]  -4.666359  -1.723300  -2.479464  -2.479464  -2.479464  -1.723300 ##  [31]  -2.124848  -2.168049  -1.723300  -1.723300  -2.124848  -2.479464 ##  [37]  -5.937161  -4.666359  -5.937161  -2.168049  -2.168049  -2.168049 ##  [43]  -1.723300  -2.479464  -2.479464  -1.723300  -2.168049  -2.168049 ##  [49]  -4.966449  -4.451503  -2.124848  -1.723300  -1.723300  -2.168049 ##  [55]  -2.168049  -2.168049  -2.479464  -2.479464  -2.168049  -2.168049 ##  [61]  -2.168049 -12.146498  -7.998052 -15.851731 -13.692810  -6.797030 ##  [67]  -1.723300  -1.723300  -1.723300  -2.479464  -1.723300  -1.723300 ##  [73]  -1.723300  -2.479464  -1.723300  -8.789295 -11.925221  -1.723300 ##  [79]  -2.124848  -2.168049  -1.723300  -2.479464  -2.479464  -1.723300 ##  [85]  -1.723300  -2.124848  -1.723300  -1.723300  -1.723300  -2.479464 ##  [91]  -2.168049 -13.778149 -12.804177  -1.723300  -2.168049  -1.723300 ##  [97]  -2.479464  -2.124848  -2.124848  -1.723300  -1.723300  -1.723300 ## [103]  -2.479464  -2.168049  -1.723300  -2.479464  -2.479464  -1.723300 ## [109]  -2.124848  -2.168049  -1.723300  -2.124848  -2.479464  -2.479464 ## [115]  -2.168049  -2.479464  -2.479464  -1.723300  -1.723300  -2.124848 ## [121]  -2.479464  -1.723300  -2.168049  -2.168049  -1.723300  -2.124848 ## [127]  -2.479464  -2.168049  -2.168049  -1.723300  -1.723300  -2.479464 ## [133]  -2.479464  -1.723300  -1.723300  -2.124848  -1.723300  -2.168049 ## [139]  -1.723300  -1.723300  -2.168049  -2.124848  -1.723300  -1.723300 ## [145]  -2.479464  -2.124848  -2.168049  -2.479464  -2.168049  -2.168049 ## [151]  -2.124848  -2.168049  -2.168049  -2.124848  -2.124848  -2.124848 ## [157]  -2.168049  -2.124848  -2.479464  -2.479464  -1.723300  -1.723300 ## [163]  -2.479464  -1.723300  -2.168049  -2.479464 -14.732917 -19.615030 ## [169]  -5.518313 -12.100597 -12.353051 -13.635931 -17.266480 -13.345413 ## [175] -11.490028 -17.630518  -7.703991  -9.253026  -8.315014 -15.815134 ## [181] -22.520178 -19.600292  -8.211880 -12.247678 -11.206825 -10.941765 ## [187]  -8.696218 -12.805962  -9.780842 -11.362024 -14.352340 -11.159366 ## [193]  -7.031107  -7.287198  -6.028996 -10.171280  -9.308607  -8.605126 ## [199] -14.012723 -11.035972 -13.786568 -11.868379  -7.912659  -2.150732 ## [205]  -8.169436  -6.624085 -17.654315 -15.496431 -16.595056  -8.700226 ## [211] -15.629645 -10.103375 -14.406553 -14.368867  -6.740934  -2.168049 ## [217] -15.289691 -10.437372 -13.350917 -16.554796  -1.723300 -15.452191 ## [223] -17.499492 -15.823027 -16.641644 -14.862440 -18.674446 -12.159241 ## [229] -15.726458  -9.517112  -1.723300  -4.928890  -2.124848 -15.498133 ## [235]  -2.383962  -4.451503  -2.168049  -5.733283  -2.168049  -5.974720 ## [241] -11.586576  -1.723300  -4.966449  -4.451503  -4.649954  -1.723300 ## [247]  -4.966449  -4.750471  -4.750471  -4.666359  -1.723300  -2.124848 ## [253]  -2.124848  -1.723300  -5.974720 -17.321552  -5.080160  -4.750471 ## [259] -15.839943  -4.649954  -7.180210  -4.928890  -1.723300  -7.346673 ## [265] -11.028594 -15.345043 -19.046793 -19.277958 -13.257427 -21.892966 ## [271] -20.452506 -21.931954 -24.528516 -23.532232 -20.519953 -19.027676 ## [277] -22.506220 -25.264236 -23.212277 -26.976309 -21.408742 -24.188293 ## [283] -17.643961 -11.347287 -18.478331 -13.031446 -19.454679 -21.580305 ## [289]  -4.750471  -1.723300  -2.124848  -5.937161  -5.790126  -2.124848 ## [295]  -7.071851  -5.137003 -11.519011 -14.334006 -13.725841  -6.228586 ## [301]  -5.295591  -7.154994 -10.640117 -10.231013  -8.310779  -1.723300 ## [307] -13.745599  -7.313986  -9.675439  -1.723300 -10.747014  -9.212303 ## [313]  -8.982248 -25.444776 -17.504134 -15.814190  -1.453974  -1.416416 ## [319]  -1.416416  -7.406719 -21.301101 -23.703755 -21.871524 -22.437483 ## [325] -26.745995 -24.329741 -22.913663 -21.523092 -22.435055 -19.641231 ## [331] -12.714091  -3.775371 -19.057293 -23.767989 -23.646468 -18.484818 ## [337] -21.272376 -23.548214 -17.468276 -12.781908 -17.459656  -9.257525 ## [343] -16.895149  -5.137003  -8.501423  -1.723300  -1.723300  -5.790126 ## [349]  -8.391581  -2.168049  -7.635636 -12.512827  -4.649954  -1.723300 ## [355]  -5.733283  -5.080160  -1.723300  -1.453974  -1.723300  -1.723300 ## [361]  -5.733283 -13.636412 -11.763600  -2.168049  -2.124848  -1.723300 ## [367]  -4.750471 -10.697606  -1.723300  -1.723300 -23.759735 -12.354940 ## [373]  -7.512183  -1.723300 -11.152159 -17.215601  -4.549063 -16.971173 ## [379] -17.621380  -4.519910  -1.630734  -1.416416 -21.449224 -21.289464 ## [385] -23.463300  -8.540068 -20.373091 -12.582422 -22.948447 -14.851864 ## [391] -20.718664 -16.347484 -15.385052 -17.392105  -9.771097 -17.321675 ## [397] -24.322328 -16.330846  -1.893505  -1.453974  -1.416416  -1.416416 ## [403] -10.001481 -19.329461 -12.251406  -7.937739  -4.666359  -5.137003 ## [409]  -1.723300 -12.839594  -9.483141  -2.168049  -6.608074  -4.666359 ## [415] -17.972685  -8.232799  -7.537957 -17.291707 -32.966795  -2.479464 ## [421]   0.000000  -9.465364  -9.319381 -14.224099 -21.200973 -28.812282 ## [427] -21.134679 -20.021614 -21.698694 -17.378210 -18.040867 -17.756721 ## [433] -21.428010 -30.178889 -14.965928 -24.942753 -23.493116 -23.871653 ## [439] -22.576312 -13.605092 -19.663046 -16.591773  -1.723300  -7.412730 ## [445]  -8.502509 -15.820949 -18.977054  -4.928890  -1.723300  -1.723300 ## [451]  -7.412730  -1.723300  -5.617459 -15.706286  -6.665338  -1.587972 ## [457]  -1.587972  -1.977113  -4.666359  -1.723300  -5.080160  -2.124848 ## [463]  -1.723300 -13.075485  -2.124848  -2.124848  -1.723300  -2.479464 ## [469]  -1.723300  -2.479464  -2.479464  -2.168049  -9.690941 -10.729635 ## [475]  -4.666359  -2.479464 -12.010138  -2.479464  -1.723300  -2.124848 ## [481]  -1.723300  -1.723300  -2.479464  -4.666359  -1.723300  -2.168049 ## [487]  -8.750700  -2.479464  -1.723300  -2.168049  -2.479464  -2.124848 ## [493]  -2.168049  -2.124848  -1.416416  -1.416416  -1.723300  -2.124848 ## [499]  -1.723300  -1.723300  -4.666359  -2.168049  -2.479464  -2.479464 ## [505]  -1.723300  -2.124848  -2.124848  -5.080160  -2.124848  -2.124848 ## [511]  -2.479464  -2.479464  -1.723300  -1.723300  -1.723300  -2.168049 ## [517]  -4.451503  -2.168049  -2.479464  -4.666359  -1.723300  -1.723300 ## [523]  -2.124848  -1.723300  -1.723300  -2.479464  -2.124848  -1.723300 ## [529]  -4.666359  -2.168049  -2.124848  -2.124848  -1.723300  -1.723300 ## [535] -11.234000  -5.937161  -4.666359  -2.168049  -2.479464  -1.723300 ## [541]  -1.723300  -2.479464  -4.750471  -2.168049  -2.168049  -1.723300 ## [547]  -2.479464  -2.124848  -1.723300  -2.479464  -2.479464  -1.723300 ## [553]  -1.723300  -2.479464  -2.168049  -1.723300  -2.124848  -1.723300 ## [559]  -6.740934  -1.723300  -2.479464  -1.723300  -1.723300  -2.168049 ## [565]  -4.666359 -10.160604  -2.168049  -1.723300  -2.479464  -2.124848 ## [571]  -2.479464  -4.928890 -18.004244  -2.168049  -2.168049  -4.666359 ## [577]  -2.168049  -1.723300  -1.723300  -1.723300  -1.723300  -2.479464 ## [583]  -1.723300 -18.162933 -10.696155  -1.723300  -7.189917  -2.168049 ## [589]  -2.479464  -2.479464  -2.168049  -7.232653 -10.160604 -11.156210 ## [595]  -1.723300  -2.168049  -2.124848 -12.003954  -2.124848  -1.723300 ## [601]  -2.479464  -2.124848  -2.168049  -2.168049  -1.723300  -4.451503 ## [607]  -1.723300  -1.723300  -4.451503  -2.124848 -18.378773  -2.124848 ## [613]  -2.168049  -2.168049  -1.723300  -2.479464  -2.479464  -2.124848 ## [619]  -1.723300  -1.723300  -1.723300  -1.723300  -2.479464  -2.479464 ## [625]  -2.479464  -2.168049  -2.168049 ##  ## $method ## [1] \"ML\" ##  ## $model ## [1] \"HKY85+G4\" ##  ## $parameters ##     FreqA     FreqC     FreqG     FreqT     FreqI       A/G       C/T       A/C  ## 0.1791570 0.2334275 0.3449375        NA        NA 3.6791536        NA        NA  ##       A/T       C/G    Indels     alpha  ##        NA        NA        NA 0.1933609  ##  ## $score ## [1] 4367.286 ##  ## $midpoint ## [1] 9.969238 attr(tree, \"score\") # best score ## [1] 4367.286"},{"path":"/articles/GrowingTrees.html","id":"ancestral-state-reconstruction","dir":"Articles","previous_headings":"","what":"Ancestral State Reconstruction","title":"Growing phylogenetic trees with TreeLine","text":"’re luck one advantages maximum likelihood maximum parsimony tree building methods automatically predict states internal node tree [@Joy:2016]. feature enabled reconstruct set TRUE. character states can used function MapCharacters determine state transitions along edge tree.","code":""},{"path":"/articles/GrowingTrees.html","id":"exporting-the-tree","dir":"Articles","previous_headings":"","what":"Exporting the Tree","title":"Growing phylogenetic trees with TreeLine","text":"’ve run good luck tree, ’d better save luck runs ! functions ReadDendrogram WriteDendrogram import export trees Newick file format. leave file argument blank print output console viewing: keep lucky streak, probably include model parameters output along tree. Luckily, Newick format supports square brackets (.e., “[]”) comments, can append end file good luck:","code":"WriteDendrogram(tree, file=\"\") ## (((\"Mg1\":0.02576825,\"C\":0.03192499):0.1660582,(\"Tu6071\":0.006348737,(\"SPB78\":0.01135088,(\"SPB74\":0.06688365,((\"griseus\":0.02878721,\"SirexAA-E\":0.1148471):0.08502283,((((\"coelicolor\":2.618e-07,\"lividans\":0.04163606):0.06461245,\"griseoflavus\":0.05622295):0.02426656,(\"clavuligerus\":0.1014992,(\"pristinaespiralis\":0.1116758,(\"bingchenggensis\":0.09915409,\"cattleya\":0.4795029):0.04033009):0.004399801):0.07055895):0.05806301,((\"scabiei\":0.1903115,\"ghanaensis\":0.2260006):0.1223492,(\"avermitilis\":0.03043229,\"albus\":0.06766567):0.004792927):0.04471756):0.0936877):0.09408172):0.08130094):0.005214737):0.1804796):1.304215,\"AA4\":2.411835); params <- attr(tree, \"parameters\") cat(\"[\", paste(names(params), params, sep=\"=\", collapse=\",\"), \"]\", sep=\"\", append=TRUE, file=\"\") ## [FreqA=0.179156981275164,FreqC=0.23342748652929,FreqG=0.344937474694546,FreqT=NA,FreqI=NA,A/G=3.67915362965464,C/T=NA,A/C=NA,A/T=NA,C/G=NA,Indels=NA,alpha=0.193360888024673]"},{"path":[]},{"path":"/articles/RepeatRepeat.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Repeat, Repeat!","text":"Jacques Monod famously penned essay 1977 likening evolutionary process tinkering boldly claiming “evolution produce novelties scratch.” cites molecular evidence: now know proteins can, regularly , evolve de novo. Yet, repetition existing sequence, followed divergence (.e., tinkering), still major source evolutionary innovation. DNA slippage replication one mechanism can result repeated sequences, particular adjacent repeats DNA. tandem repeats, especially form short microsatellites, underly several human diseases including fragile X syndrome Huntington’s disease. Microsatellites easy spot eye, contain repetitive stretches nucleotides repeated many times row (e.g., CAG CAG CAG CAG CAG […] protein Huntintin). Harder detect tandem repeats evolved considerably since origin, repeated copies longer look anything like shared ancestral sequence. estimated half human proteome contains tandem repeats, many share ancient origin undetectable eye. Obscurin one human protein containing several repeats difficult spot eye. contains 68 Ig (Immunoglobin) domains, contain multiple antiparallel \\(\\beta\\)-sheets (Fig. @ref(f1)). Many Ig domains found adjacent likely arose common ancestor. vignette describes detect obscure repeats using DetectRepeats function package DECIPHER.","code":""},{"path":[]},{"path":"/articles/RepeatRepeat.html","id":"startup","dir":"Articles","previous_headings":"Getting Started","what":"Startup","title":"Repeat, Repeat!","text":"get started need load DECIPHER package, automatically loads required packages. Detecting repeats performed DetectRepeats function. help page can accessed : DECIPHER installed, code tutorial can obtained via:","code":"library(DECIPHER) ## Loading required package: Biostrings ## Loading required package: BiocGenerics ##  ## Attaching package: 'BiocGenerics' ## The following objects are masked from 'package:stats': ##  ##     IQR, mad, sd, var, xtabs ## The following objects are masked from 'package:base': ##  ##     anyDuplicated, aperm, append, as.data.frame, basename, cbind, ##     colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ##     get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply, ##     match, mget, order, paste, pmax, pmax.int, pmin, pmin.int, ##     Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort, ##     table, tapply, union, unique, unsplit, which.max, which.min ## Loading required package: S4Vectors ## Loading required package: stats4 ##  ## Attaching package: 'S4Vectors' ## The following object is masked from 'package:utils': ##  ##     findMatches ## The following objects are masked from 'package:base': ##  ##     expand.grid, I, unname ## Loading required package: IRanges ## Loading required package: XVector ## Loading required package: GenomeInfoDb ##  ## Attaching package: 'Biostrings' ## The following object is masked from 'package:base': ##  ##     strsplit ## Loading required package: RSQLite ## Loading required package: parallel > ? DetectRepeats > browseVignettes(\"DECIPHER\")"},{"path":"/articles/RepeatRepeat.html","id":"taking-a-first-look-at-obscurin","dir":"Articles","previous_headings":"","what":"Taking a first look at Obscurin","title":"Repeat, Repeat!","text":", take deep dive human protein Obscurin, expressed muscle tissue. Obscurin large protein primarily composed Ig domains, example looks like: Since know form repeat, can find others like sequence aligning repeat sliding window along entire protein sequence. First, load sequences : Although DetectRepeats works nucleotide protein sequences, generally easier find tandem repeats amino acid sequences find DNA sequences. can easily translate proteins: see Obscurin second protein AAStringSet. others related human proteins containing Ig domains. possible analyze many proteins time, vignette focuses single protein examples run quickly. detect repeats different protein, multiple proteins, simply change value index . can find repeated sequence using pairwise alignment aligning windows along sequence Ig domain plot scores. alignment score quantifies well window along protein matches Ig domain. Windows matching Ig domains show peaks score. {#f2} Peaks marking start Ig domains human protein Obscurin. can make couple observations plot. First, many Ig domains located adjacent , likely result tandem repeats, although isolated parts protein. Second, tandem repeats around main peak higher scores, suggesting orthologous repeats share recent evolutionary ancestor. Many repeats negative scores even though also Ig domains.","code":"Ig <- AAStringSet(\"VRALPARFTEGLRNEEAMEGATATLQCELSKAAPVEWRKGLEALRDGDKYSLRQDGAVCELQIHGLAMADNGVYSCVCGQERTSATLT\") Ig ## AAStringSet object of length 1: ##     width seq ## [1]    88 VRALPARFTEGLRNEEAMEGATATLQCELSKAAP...GAVCELQIHGLAMADNGVYSCVCGQERTSATLT # specify the path to your file of sequences: fas <- \"<<path to training FASTA file>>\" # OR use the example DNA sequences: fas <- system.file(\"extdata\",     \"LongHumanProteins.fas.gz\",     package=\"DECIPHER\") # read the sequences into memory DNA <- readDNAStringSet(fas) DNA ## DNAStringSet object of length 11: ##       width seq                                             names                ##  [1] 107976 ATGACAACTCAAGCACCGACGT...TATACATATTCGATCCATTTAA titin isoform IC ##  [2]  26778 ATGGATCAGCCACAGTTCAGCG...CAACCTGGCCCAGGTGCGCTGA obscurin isoform c ##  [3]  16908 ATGATTTCCTGGGAAGTTGTCC...TGTGTCCGCCTATCCATACTAA hemicentin-1 prec... ##  [4]   5847 ATGGCGCCCACCTGGGGCCCTG...CTTTGACCACTATGCAACCTAA receptor-type tyr... ##  [5]   5745 ATGGGGGATGTGAAGCTGGTTG...AGGGGAAGAGGAAGAAGAGTGA myosin light chai... ##  ...    ... ... ##  [7]   3825 ATGCCTGAGCCGGGGAAGAAGC...GGAGGTGCGAGTGCCTCAGTGA myosin-binding pr... ##  [8]   1497 ATGTTTAACTACGAACGTCCAA...CTATGAAAGTGAAGAACTTTAA myotilin isoform a ##  [9]   1263 ATGCTCAAAGCGGTGATCCTGA...CACCAACCAGATCATCCTCTGA mannose-1-phospha... ## [10]   1101 ATGGTGCTGCACCTACTGCTCT...GCAGCACTGTGCTTGTATCTAA inhibin alpha cha... ## [11]    717 ATGTCTAAAGCAGCTCCTGCCA...CGCTCGCGTCGACGTGGCCTGA SPEG neighbor pro... AA <- translate(DNA) AA ## AAStringSet object of length 11: ##      width seq                                              names                ##  [1] 35992 MTTQAPTFTQPLQSVVVLEGSTA...LSLGNEFGSDSATVNIHIRSI* titin isoform IC ##  [2]  8926 MDQPQFSGAPRFLTRPKAFVVSV...VRNREKRRALLYKRHNLAQVR* obscurin isoform c ##  [3]  5636 MISWEVVHTVFLFALLYSSLAQD...NGTIEYQTTFIVYIAVSAYPY* hemicentin-1 prec... ##  [4]  1949 MAPTWGPGMVSVVGPMGLLVVLL...EYQFCYQAALEYLGSFDHYAT* receptor-type tyr... ##  [5]  1915 MGDVKLVASSHISKTSLSVDPSR...TAELIVETMEEGEGEGEEEEE* myosin light chai... ##  ...   ... ... ##  [7]  1275 MPEPGKKPVSAFSKKPRSVEVAA...RATNLQGEARCECRLEVRVPQ* myosin-binding pr... ##  [8]   499 MFNYERPKHFIQSQNPCGSRLQP...NPEGEFQRLAAQSGLYESEEL* myotilin isoform a ##  [9]   421 MLKAVILIGGPQKGTRFRPLSFE...LNSIVLPHKELSRSFTNQIIL* mannose-1-phospha... ## [10]   367 MVLHLLLFLLLTPQGGHSCQGLE...GGYSFKYETVPNLLTQHCACI* inhibin alpha cha... ## [11]   239 MSKAAPAKKPVAVAPAPGCTLDI...YEVYVENSLGMDQSFARVDVA* SPEG neighbor pro... names(AA) ##  [1] \"titin isoform IC\"                                                 ##  [2] \"obscurin isoform c\"                                               ##  [3] \"hemicentin-1 precursor\"                                           ##  [4] \"receptor-type tyrosine-protein phosphatase S isoform 1 precursor\" ##  [5] \"myosin light chain kinase, smooth muscle isoform 1\"               ##  [6] \"roundabout homolog 1 isoform a precursor\"                         ##  [7] \"myosin-binding protein C, cardiac-type\"                           ##  [8] \"myotilin isoform a\"                                               ##  [9] \"mannose-1-phosphate guanyltransferase alpha\"                      ## [10] \"inhibin alpha chain preproprotein\"                                ## [11] \"SPEG neighbor protein\" index <- 2 AA <- AA[index] windows <- extractAt(AA[[1]],     IRanges(seq_len(width(AA[1]) - width(Ig)),         width=width(Ig))) p <- pairwiseAlignment(windows, Ig) plot(score(p), ylab=\"Score\", xlab=\"Amino acid position\", type=\"l\")"},{"path":"/articles/RepeatRepeat.html","id":"detecting-repeats-automatically-with-detectrepeats","dir":"Articles","previous_headings":"","what":"Detecting repeats automatically with DetectRepeats","title":"Repeat, Repeat!","text":"Obscurin advantage already know look repeated Ig domains. can find tandem repeats don’t know expect? comes handy use DetectRepeats function find tandem repeats. takes sequences input outputs predicted tandem repeats associated scores. Let’s take look Obscurin: result data.frame giving beginning ending positions tandem repeat, well every repeat within . top scoring repeat spans Ig domains found earlier. Since asked allScores, output contains repeats scores minScore, even overlapping. allows us easily plot different repeats identified Obscurin: {#f3} different repeats detected human protein Obscurin. adjacent Ig domains identified multiple times different beginning ending positions. set allScores FALSE (default) obtain top scoring repeat region.","code":"reps <- DetectRepeats(AA, allScores=TRUE) ## ================================================================================ ##  ## Time difference of 26.7 secs reps[which.max(reps[, \"Score\"]),] ##    Index Begin  End         Left        Right    Score ## 94     1   771 5455 771, 863.... 862, 954.... 2604.364 plot(NA,     xlim=c(0, max(width(AA))),     ylim=range(0, reps[, \"Score\"]),     xlab=\"Position in protein\",     ylab=\"Tandem repeat score\") for (i in seq_len(nrow(reps)))     segments(reps[[i, \"Left\"]],         reps[i, \"Score\"],         reps[[i, \"Right\"]],         reps[i, \"Score\"],         col=seq_along(reps[[i, \"Left\"]]))"},{"path":"/articles/RepeatRepeat.html","id":"inferring-the-history-of-repeats-in-obscurin","dir":"Articles","previous_headings":"","what":"Inferring the History of Repeats in Obscurin","title":"Repeat, Repeat!","text":"feasible infer order repeats phylogeny built repeat sequences. Repeats duplicated recently presumably closely related phylogenetic tree. construct tree, first must extract repeats. Note repeats numbered leftmost rightmost tandem repeat. can infer phylogenetic tree using TreeLine function DECIPHER: {#f4} Inferred phylogeny Ig domain repeats detected Obscurin. signal adjacent repeats branching later phylogeny. possible hypothesize set duplication events resulted observed set locations repeats Obscurin.","code":"i <- which.max(reps[, \"Score\"]) seqs <- extractAt(AA[[reps[i, \"Index\"]]],     IRanges(reps[[i, \"Left\"]], reps[[i, \"Right\"]])) seqs <- AlignSeqs(seqs, verbose=FALSE) # align the repeats names(seqs) <- seq_along(seqs) # number from left to right seqs ## AAStringSet object of length 52: ##      width seq                                              names                ##  [1]   105 DDAGLYECVSRGGRIAYQLSVQG...RFLQE--DVGTRHRLVAATVTR 1 ##  [2]   105 QDEGTYSCRVGEDSVDFRLRVSE...KVHVE--AVGCMRRLVVQQVGQ 2 ##  [3]   105 ADSGEYSCEARGQRVSFRLDVAE...KVCME--ATGCTRRLVVQQAGQ 3 ##  [4]   105 ADAGEYSCEAGGQRLSFHLDVKE...KVHVE--AKGCRRRLVVQQAGK 4 ##  [5]   105 TDAGDYSCEARGQRVSFRLHITE...KVGME--VKGCTRRLVLPQAGK 5 ##  ...   ... ... ## [48]   105 EDAGDYTCDTGHTQSMASLSVRV...KYEMR--SQGATRELLIHQLEA 48 ## [49]   105 KDTGEYACVTGGQKTAASLRVTE...VTEVA-VRDGRIHTLRLKGVTP 49 ## [50]   105 EDAGTVSFHLGNHASSAQLTVRA...MNDIT-VEQGTLHLLTLHKVTL 50 ## [51]   105 EDAGTVSFHVGTCSSEAQLKVTA...NAEVVFFENGLRHLLLLKNLRP 51 ## [52]   105 QDSCRVTFLAGDMVTSAFLTVRG...DWTVT--ADGSHHALLLRSAQP 52 par(mar=c(4.1, 4.1, 0.3, 0.2)) d <- DistanceMatrix(seqs) ## ================================================================================ ##  ## Time difference of 0 secs dend <- TreeLine(myDistMatrix=d, method=\"NJ\", verbose=FALSE) dend <- reorder(dend, seq_along(seqs)) layout(matrix(1:2)) plot(dend) plot(unlist(dend), xlab=\"Position on tree\", ylab=\"Repeat number\") abline(a=0, b=1)"},{"path":"/articles/RepeatRepeat.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session Information","title":"Repeat, Repeat!","text":"output vignette produced following conditions:","code":"## R version 4.3.1 (2023-06-16) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.3 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0  ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0 ##  ## locale: ##  [1] LC_CTYPE=zh_CN.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=zh_CN.UTF-8        LC_COLLATE=zh_CN.UTF-8     ##  [5] LC_MONETARY=zh_CN.UTF-8    LC_MESSAGES=zh_CN.UTF-8    ##  [7] LC_PAPER=zh_CN.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=zh_CN.UTF-8 LC_IDENTIFICATION=C        ##  ## time zone: Asia/Shanghai ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] parallel  stats4    stats     graphics  grDevices utils     datasets  ## [8] methods   base      ##  ## other attached packages: ## [1] DECIPHER_2.29.1     RSQLite_2.3.1       Biostrings_2.68.1   ## [4] GenomeInfoDb_1.36.1 XVector_0.40.0      IRanges_2.34.1      ## [7] S4Vectors_0.38.1    BiocGenerics_0.46.0 ##  ## loaded via a namespace (and not attached): ##  [1] bit_4.0.5               jsonlite_1.8.7          highr_0.10              ##  [4] crayon_1.5.2            compiler_4.3.1          blob_1.2.4              ##  [7] stringr_1.5.0           bitops_1.0-7            jquerylib_0.1.4         ## [10] systemfonts_1.0.4       textshaping_0.3.6       yaml_2.3.7              ## [13] fastmap_1.1.1           R6_2.5.1                knitr_1.43              ## [16] desc_1.4.2              rprojroot_2.0.3         DBI_1.1.3               ## [19] GenomeInfoDbData_1.2.10 bslib_0.5.1             rlang_1.1.1             ## [22] cachem_1.0.8            stringi_1.7.12          xfun_0.40               ## [25] fs_1.6.3                sass_0.4.7              bit64_4.0.5             ## [28] memoise_2.0.1           cli_3.6.1               pkgdown_2.0.7           ## [31] magrittr_2.0.3          zlibbioc_1.46.0         digest_0.6.33           ## [34] rstudioapi_0.15.0       lifecycle_1.0.3         vctrs_0.6.3             ## [37] evaluate_0.21           glue_1.6.2              ragg_1.2.5              ## [40] RCurl_1.98-1.12         rmarkdown_2.24          purrr_1.0.2             ## [43] tools_4.3.1             htmltools_0.5.6"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Erik Wright. Maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wright ES (2016). “Using DECIPHER v2.0 Analyze Big Biological Sequence Data R.” R Journal, 8(1), 352-359.","code":"@Article{,   title = {Using DECIPHER v2.0 to Analyze Big Biological Sequence Data in R},   author = {Erik S. Wright},   journal = {The R Journal},   year = {2016},   volume = {8},   number = {1},   pages = {352-359}, }"},{"path":"/reference/AA_REDUCED.html","id":null,"dir":"Reference","previous_headings":"","what":"Reduced amino acid alphabets — AA_REDUCED","title":"Reduced amino acid alphabets — AA_REDUCED","text":"AA_REDUCED list contains reductions standard amino acid alphabet (AA_STANDARD).","code":""},{"path":"/reference/AA_REDUCED.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reduced amino acid alphabets — AA_REDUCED","text":"","code":"AA_REDUCED"},{"path":"/reference/AA_REDUCED.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Reduced amino acid alphabets — AA_REDUCED","text":"object class list length 160.","code":""},{"path":"/reference/AA_REDUCED.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reduced amino acid alphabets — AA_REDUCED","text":"Reduced amino alphabets can sometimes improve sensitivity specificity finding homologous matches amino acid sequences.  first 12 AA_REDUCED alphabets optimized finding synteny genomic sequences.  next 113 alphabets review published amino acid alphabets (Solis, 2015). following 17 alphabets optimized amino acid classification. final 18 alphabets progressive mergers based average similarities PFASUM.","code":""},{"path":"/reference/AA_REDUCED.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Reduced amino acid alphabets — AA_REDUCED","text":"Solis, . (2015). Amino acid alphabet reduction preserves fold information contained contact interactions proteins. Proteins: Structure, Function, Genetics, 83(12), 2198-2216.","code":""},{"path":[]},{"path":"/reference/AA_REDUCED.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reduced amino acid alphabets — AA_REDUCED","text":"","code":"str(AA_REDUCED) #> List of 160 #>  $ : chr [1:16] \"A\" \"C\" \"D\" \"E\" ... #>  $ : chr [1:14] \"AG\" \"C\" \"DE\" \"FY\" ... #>  $ : chr [1:14] \"AG\" \"C\" \"DN\" \"E\" ... #>  $ : chr [1:17] \"A\" \"C\" \"D\" \"E\" ... #>  $ : chr [1:15] \"AG\" \"C\" \"D\" \"E\" ... #>  $ : chr [1:14] \"AG\" \"C\" \"D\" \"E\" ... #>  $ : chr [1:16] \"A\" \"C\" \"D\" \"E\" ... #>  $ : chr [1:17] \"A\" \"C\" \"D\" \"E\" ... #>  $ : chr [1:14] \"AG\" \"C\" \"D\" \"EQ\" ... #>  $ : chr [1:13] \"AG\" \"C\" \"DN\" \"EQ\" ... #>  $ : chr [1:16] \"AS\" \"C\" \"D\" \"E\" ... #>  $ : chr [1:16] \"A\" \"C\" \"D\" \"E\" ... #>  $ : chr [1:8] \"AGILV\" \"CM\" \"DE\" \"FWY\" ... #>  $ : chr [1:4] \"AFILMPVW\" \"CGNQSTY\" \"DE\" \"HKR\" #>  $ : chr [1:3] \"ACGPSTWY\" \"DEHKNQR\" \"FILMV\" #>  $ : chr [1:10] \"ACGS\" \"DE\" \"FWY\" \"HKR\" ... #>  $ : chr [1:2] \"ACFILMVWY\" \"DEGHKNPQRST\" #>  $ : chr [1:3] \"AFILMVWY\" \"C\" \"DEGHKNPQRST\" #>  $ : chr [1:4] \"AFILMVWY\" \"C\" \"DEKR\" \"GHNPQST\" #>  $ : chr [1:5] \"AFILMVWY\" \"C\" \"DE\" \"GHNPQST\" ... #>  $ : chr [1:6] \"A\" \"C\" \"DE\" \"FILMVWY\" ... #>  $ : chr [1:7] \"A\" \"C\" \"DE\" \"FILMVWY\" ... #>  $ : chr [1:8] \"A\" \"C\" \"DE\" \"FILMV\" ... #>  $ : chr [1:9] \"A\" \"C\" \"DE\" \"FILMV\" ... #>  $ : chr [1:10] \"A\" \"C\" \"DE\" \"FILMV\" ... #>  $ : chr [1:10] \"AST\" \"C\" \"DEN\" \"FY\" ... #>  $ : chr [1:2] \"ACFGILMPSTVWY\" \"DEHKNQR\" #>  $ : chr [1:4] \"AGPST\" \"CILMV\" \"DEHKNQR\" \"FWY\" #>  $ : chr [1:8] \"AG\" \"CILMV\" \"DENQ\" \"FWY\" ... #>  $ : chr [1:10] \"A\" \"C\" \"DENQ\" \"FWY\" ... #>  $ : chr [1:2] \"ADEGHKNPQRST\" \"CFILMVWY\" #>  $ : chr [1:3] \"ADEGHKNPQRST\" \"CFILMVY\" \"W\" #>  $ : chr [1:4] \"ADEGHKNQRST\" \"CFILMVY\" \"P\" \"W\" #>  $ : chr [1:5] \"ADEGKNQRST\" \"CFILMVY\" \"H\" \"P\" ... #>  $ : chr [1:6] \"ADEGKNQRST\" \"C\" \"FILMVY\" \"H\" ... #>  $ : chr [1:7] \"ADEKNQRST\" \"C\" \"FILMVY\" \"G\" ... #>  $ : chr [1:8] \"AEKQRST\" \"C\" \"DN\" \"FILMVY\" ... #>  $ : chr [1:4] \"ADEGKNPQRST\" \"C\" \"FILMVWY\" \"H\" #>  $ : chr [1:5] \"ADEGKNPQRST\" \"C\" \"FILMVY\" \"H\" ... #>  $ : chr [1:6] \"ADEGKNQRST\" \"C\" \"FILMVY\" \"H\" ... #>  $ : chr [1:7] \"ADEKNQRST\" \"C\" \"FILMVY\" \"G\" ... #>  $ : chr [1:8] \"ADEKNQRST\" \"C\" \"FILMV\" \"G\" ... #>  $ : chr [1:9] \"ADNST\" \"C\" \"EKQR\" \"FILVY\" ... #>  $ : chr [1:2] \"ACDEGHKNPQRST\" \"FILMVWY\" #>  $ : chr [1:3] \"ADEGHKNPQRST\" \"C\" \"FILMVWY\" #>  $ : chr [1:4] \"ADEGHKNPQRST\" \"C\" \"FILMVY\" \"W\" #>  $ : chr [1:5] \"AGPST\" \"C\" \"DEHKNQR\" \"FILMVY\" ... #>  $ : chr [1:6] \"AGPST\" \"C\" \"DEKNQR\" \"FILMVY\" ... #>  $ : chr [1:7] \"ADGNST\" \"C\" \"EKQR\" \"FILMVY\" ... #>  $ : chr [1:8] \"ADGNST\" \"C\" \"EKQR\" \"FY\" ... #>  $ : chr [1:9] \"AGST\" \"C\" \"DN\" \"EKQR\" ... #>  $ : chr [1:10] \"AGST\" \"C\" \"DN\" \"EQ\" ... #>  $ : chr [1:5] \"ADEGHKNPQRST\" \"C\" \"FY\" \"ILMV\" ... #>  $ : chr [1:2] \"ADEGHKNPQRST\" \"CFILMVWY\" #>  $ : chr [1:5] \"APST\" \"CFWY\" \"DEHKNQR\" \"G\" ... #>  $ : chr [1:8] \"AST\" \"CFWY\" \"DEQ\" \"G\" ... #>  $ : chr [1:10] \"AST\" \"C\" \"DEQ\" \"FWY\" ... #>  $ : chr [1:10] \"AC\" \"DE\" \"FWY\" \"G\" ... #>  $ : chr [1:6] \"AST\" \"CP\" \"DEHKNQR\" \"FWY\" ... #>  $ : chr [1:8] \"AST\" \"C\" \"DHN\" \"EKQR\" ... #>  $ : chr [1:10] \"AST\" \"C\" \"DN\" \"EQ\" ... #>  $ : chr [1:10] \"AST\" \"C\" \"DEN\" \"FY\" ... #>  $ : chr [1:2] \"ADEGHKNPQRST\" \"CFILMVWY\" #>  $ : chr [1:3] \"ACGPST\" \"DEHKNQR\" \"FILMVWY\" #>  $ : chr [1:4] \"ACGST\" \"DEHKNQR\" \"FPWY\" \"ILMV\" #>  $ : chr [1:5] \"ACST\" \"DEKNQR\" \"FHWY\" \"GP\" ... #>  $ : chr [1:6] \"ACST\" \"DEKNQR\" \"FHWY\" \"G\" ... #>  $ : chr [1:7] \"ACST\" \"DEN\" \"FWY\" \"G\" ... #>  $ : chr [1:8] \"AST\" \"C\" \"DEN\" \"FWY\" ... #>  $ : chr [1:9] \"AST\" \"C\" \"DEN\" \"FWY\" ... #>  $ : chr [1:10] \"AST\" \"C\" \"DEN\" \"FY\" ... #>  $ : chr [1:5] \"AG\" \"C\" \"DEKNPQRST\" \"FILMVWY\" ... #>  $ : chr [1:2] \"ACEFHIKLMQRVWY\" \"DGNPST\" #>  $ : chr [1:3] \"AEHKQR\" \"CFILMVWY\" \"DGNPST\" #>  $ : chr [1:4] \"AEHKQR\" \"CFILMVWY\" \"DNST\" \"GP\" #>  $ : chr [1:5] \"AEHKQR\" \"CST\" \"DN\" \"FILMVWY\" ... #>  $ : chr [1:6] \"AEKQR\" \"CHST\" \"DN\" \"FIV\" ... #>  $ : chr [1:7] \"ACH\" \"DN\" \"EKQR\" \"FIV\" ... #>  $ : chr [1:8] \"AM\" \"CF\" \"DNS\" \"EKQR\" ... #>  $ : chr [1:9] \"AMW\" \"CY\" \"DNS\" \"EKQR\" ... #>  $ : chr [1:10] \"AM\" \"C\" \"DNS\" \"EKQR\" ... #>  $ : chr [1:2] \"ACDEFHIKLMNQRSTVWY\" \"GP\" #>  $ : chr [1:3] \"ACDEFHIKLMNQRSTVWY\" \"G\" \"P\" #>  $ : chr [1:4] \"ADEKNQRST\" \"CFHILMVWY\" \"G\" \"P\" #>  $ : chr [1:5] \"AEHKQRST\" \"CFILMVWY\" \"DN\" \"G\" ... #>  $ : chr [1:6] \"AEFHIKLMQRVWY\" \"CT\" \"DN\" \"G\" ... #>  $ : chr [1:7] \"AEFIKLMQRVWY\" \"CH\" \"DN\" \"G\" ... #>  $ : chr [1:8] \"AEFIKLMQRVWY\" \"CH\" \"D\" \"G\" ... #>  $ : chr [1:9] \"AEFIKLMQRVWY\" \"C\" \"D\" \"G\" ... #>  $ : chr [1:10] \"AEFIKLMQRVW\" \"C\" \"D\" \"G\" ... #>  $ : chr [1:2] \"AFILMVWY\" \"CDEGHKNPQRST\" #>  $ : chr [1:3] \"AFILMVWY\" \"CDEHKNQRST\" \"GP\" #>  $ : chr [1:4] \"ALM\" \"CDEHKNQRST\" \"FIVWY\" \"GP\" #>  $ : chr [1:5] \"ALM\" \"CDHNST\" \"EKQR\" \"FIVWY\" ... #>  $ : chr [1:6] \"ALM\" \"CHT\" \"DNS\" \"EKQR\" ... #>  $ : chr [1:7] \"A\" \"CHT\" \"DNS\" \"EKQR\" ... #>  $ : chr [1:8] \"A\" \"CHT\" \"DNS\" \"EKQR\" ... #>  $ : chr [1:9] \"A\" \"CHT\" \"DNS\" \"EKQR\" ... #>  $ : chr [1:10] \"A\" \"CH\" \"DNS\" \"EKQR\" ... #>   [list output truncated] AA_REDUCED[[1]] #>  [1] \"A\"    \"C\"    \"D\"    \"E\"    \"FY\"   \"G\"    \"H\"    \"ILMV\" \"K\"    \"N\"    #> [11] \"P\"    \"Q\"    \"R\"    \"S\"    \"T\"    \"W\""},{"path":"/reference/Add2DB.html","id":null,"dir":"Reference","previous_headings":"","what":"Add Data to a Database — Add2DB","title":"Add Data to a Database — Add2DB","text":"Adds data.frame database table row.names.","code":""},{"path":"/reference/Add2DB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add Data to a Database — Add2DB","text":"","code":"Add2DB(myData, dbFile, tblName = \"Seqs\", clause = \"\", verbose = TRUE)"},{"path":"/reference/Add2DB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add Data to a Database — Add2DB","text":"myData Data frame containing information added dbFile. dbFile SQLite connection object character string specifying path database file. tblName Character string specifying table add data. clause optional character string append query part ``clause''. verbose Logical indicating whether display query sent database.","code":""},{"path":"/reference/Add2DB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add Data to a Database — Add2DB","text":"Returns TRUE data added successfully, FALSE otherwise.","code":""},{"path":"/reference/Add2DB.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add Data to a Database — Add2DB","text":"Data contained myData added tblName respective row.names.","code":""},{"path":"/reference/Add2DB.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add Data to a Database — Add2DB","text":"ES Wright (2016) \"Using DECIPHER v2.0 Analyze Big Biological Sequence Data R\". R Journal, 8(1), 352-359.","code":""},{"path":[]},{"path":"/reference/Add2DB.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add Data to a Database — Add2DB","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/Add2DB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add Data to a Database — Add2DB","text":"","code":"if (FALSE) { # Create a sequence database gen <- system.file(\"extdata\", \"Bacteria_175seqs.gen\", package=\"DECIPHER\") dbConn <- dbConnect(SQLite(), \":memory:\") Seqs2DB(gen, \"GenBank\", dbConn, \"Bacteria\")  # Identify the sequence lengths l <- IdLengths(dbConn)  # Add lengths to the database Add2DB(l, dbConn)  # View the added lengths BrowseDB(dbConn)  # Change the value of existing columns ids <- data.frame(identifier=rep(\"Bacteroidetes\", 18), stringsAsFactors=FALSE) rownames(ids) <- 10:27 Add2DB(ids, dbConn) BrowseDB(dbConn)  # Add data to a subset of rows using a clause ids[[1]][] <- \"Changed\" nrow(ids) # 18 rows Add2DB(ids, dbConn, clause=\"accession like 'EU808318%'\") BrowseDB(dbConn) # only 1 row effected  dbDisconnect(dbConn) }"},{"path":"/reference/AdjustAlignment.html","id":null,"dir":"Reference","previous_headings":"","what":"Improve An Existing Alignment By Adjusting Gap Placements — AdjustAlignment","title":"Improve An Existing Alignment By Adjusting Gap Placements — AdjustAlignment","text":"Makes small adjustments shifting groups gaps left right find optimal positioning multiple sequence alignment.","code":""},{"path":"/reference/AdjustAlignment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Improve An Existing Alignment By Adjusting Gap Placements — AdjustAlignment","text":"","code":"AdjustAlignment(   myXStringSet,   perfectMatch = 5,   misMatch = 0,   gapLetter = -3,   gapOpening = -0.1,   gapExtension = 0,   substitutionMatrix = NULL,   shiftPenalty = -0.2,   threshold = 0.1,   weight = 1,   processors = 1 )"},{"path":"/reference/AdjustAlignment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Improve An Existing Alignment By Adjusting Gap Placements — AdjustAlignment","text":"myXStringSet AAStringSet, DNAStringSet, RNAStringSet object aligned sequences. perfectMatch Numeric giving reward aligning two matching nucleotides alignment.  used DNAStringSet RNAStringSet inputs. misMatch Numeric giving cost aligning two mismatched nucleotides alignment.  used DNAStringSet RNAStringSet inputs. gapLetter Numeric giving cost aligning gaps letters.  lower value (negative) encourages overlapping gaps across different sequences alignment. gapOpening Numeric giving cost opening closing gap alignment. gapExtension Numeric giving cost extending open gap alignment. substitutionMatrix Either substitution matrix representing substitution scores alignment name amino acid substitution matrix use alignment.  latter may one following: BLOSUM45'', BLOSUM50'', BLOSUM62'', BLOSUM80'', BLOSUM100'', PAM30'', PAM40'', PAM70'', PAM120'', PAM250'', ``MIQS''.  default (NULL) use perfectMatch misMatch penalties DNA/RNA PFASUM50 AA. shiftPenalty Numeric giving cost every additional position group gaps shifted. threshold Numeric specifying improvement score required permanently apply adjustment alignment. weight numeric vector weights sequence, single number implying equal weights. processors number processors use, NULL automatically detect use available processors.","code":""},{"path":"/reference/AdjustAlignment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Improve An Existing Alignment By Adjusting Gap Placements — AdjustAlignment","text":"XStringSet aligned sequences.","code":""},{"path":"/reference/AdjustAlignment.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Improve An Existing Alignment By Adjusting Gap Placements — AdjustAlignment","text":"process multiple sequence alignment often results integration small imperfections final alignment.  errors obvious -eye, encourages manual refinement automatically generated alignments.  However, manual refinement process inherently subjective time consuming.  AdjustAlignment refines existing alignment process similar might applied manually, repeatable must faster fashion.  function shifts gaps alignment left right find optimal positioning.  optimal position defined position maximizes alignment ``score'', determined input parameters.  resulting alignment similar input alignment many imperfections eliminated.  Note affine gap penalties different flexible penalties used AlignProfiles, optimized independently.","code":""},{"path":"/reference/AdjustAlignment.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Improve An Existing Alignment By Adjusting Gap Placements — AdjustAlignment","text":"Wright, E. S. (2015). DECIPHER: harnessing local sequence context improve protein multiple sequence alignment. BMC Bioinformatics, 16, 322. http://doi.org/10.1186/s12859-015-0749-z Wright, E. S. (2020). RNAconTest: comparing tools noncoding RNA multiple sequence alignment based structural consistency. RNA 2020, 26, 531-540.","code":""},{"path":[]},{"path":"/reference/AdjustAlignment.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Improve An Existing Alignment By Adjusting Gap Placements — AdjustAlignment","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/AdjustAlignment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Improve An Existing Alignment By Adjusting Gap Placements — AdjustAlignment","text":"","code":"if (FALSE) { # a trivial example aa <- AAStringSet(c(\"ARN-PK\", \"ARRP-K\")) aa # input alignment AdjustAlignment(aa) # output alignment  # specifying an alternative substitution matrix AdjustAlignment(aa, substitutionMatrix=\"BLOSUM62\")  # a real example fas <- system.file(\"extdata\", \"Streptomyces_ITS_aligned.fas\", package=\"DECIPHER\") dna <- readDNAStringSet(fas) dna # input alignment adjustedDNA <- AdjustAlignment(dna) # output alignment BrowseSeqs(adjustedDNA, highlight=1) adjustedDNA==dna # most sequences were adjusted (those marked FALSE) }"},{"path":"/reference/AlignDB.html","id":null,"dir":"Reference","previous_headings":"","what":"Align Two Sets of Aligned Sequences in a Sequence Database — AlignDB","title":"Align Two Sets of Aligned Sequences in a Sequence Database — AlignDB","text":"Merges two separate sequence alignments database.  aligned sequences must separate identifiers table located different database tables.","code":""},{"path":"/reference/AlignDB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Align Two Sets of Aligned Sequences in a Sequence Database — AlignDB","text":"","code":"AlignDB(   dbFile,   tblName = \"Seqs\",   identifier = \"\",   type = \"DNAStringSet\",   add2tbl = \"Seqs\",   batchSize = 10000,   perfectMatch = 5,   misMatch = 0,   gapOpening = -14,   gapExtension = -2,   gapPower = -1,   terminalGap = 0,   normPower = c(1, 0),   standardize = TRUE,   substitutionMatrix = NULL,   processors = 1,   verbose = TRUE,   ... )"},{"path":"/reference/AlignDB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Align Two Sets of Aligned Sequences in a Sequence Database — AlignDB","text":"dbFile SQLite connection object character string specifying path database file. tblName Character string specifying table(s) sequences located.  two tblNames provided sequences tables aligned. identifier Optional character string used narrow search results matching specific identifier.  \"\" identifiers selected.  two identifiers provided set sequences matching identifier aligned. type type XStringSet processed.  (abbreviation ) one \"AAStringSet\", \"DNAStringSet\", \"RNAStringSet\". add2tbl Character string specifying table name add aligned sequences. batchSize Integer specifying number sequences process time. perfectMatch Numeric giving reward aligning two matching nucleotides alignment.  used type DNAStringSet RNAStringSet. misMatch Numeric giving cost aligning two mismatched nucleotides alignment.  used type DNAStringSet RNAStringSet. gapOpening Numeric giving cost opening gap alignment. gapExtension Numeric giving cost extending open gap alignment. gapPower Numeric specifying exponent use gap cost function. terminalGap Numeric giving cost allowing leading trailing gaps (\"-\" \".\" characters) alignment.  Either two numbers, first leading gaps second trailing gaps, single number . normPower Numeric giving exponent controls degree normalization applied scores column occupancy.  two numerics provided, first controls normalization power terminal gaps, second controls internal gaps.  normPower 0 normalize scores, results columns profiles weighted equally, optimal value aligning fragmentary sequences.  normPower 1 normalizes score aligning two positions column occupancy (1 - fraction gaps).  normPower greater 1 strongly discourages aligning ``gappy'' regions alignment. standardize Logical determining whether scores standardized units per matching site. Standardization effectively divides score possible alignment length scores relative rather absolute. substitutionMatrix Either substitution matrix representing substitution scores alignment name amino acid substitution matrix use alignment.  latter may one following: BLOSUM45'', BLOSUM50'', BLOSUM62'', BLOSUM80'', BLOSUM100'', PAM30'', PAM40'', PAM70'', PAM120'', PAM250'', ``MIQS''.  default (NULL) use perfectMatch misMatch penalties DNA/RNA PFASUM50 AA. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display progress. ... arguments passed directly Codec.","code":""},{"path":"/reference/AlignDB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Align Two Sets of Aligned Sequences in a Sequence Database — AlignDB","text":"Returns number newly aligned sequences added database.","code":""},{"path":"/reference/AlignDB.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Align Two Sets of Aligned Sequences in a Sequence Database — AlignDB","text":"Sometimes useful align two large sets sequences, set sequences already aligned two sets aligned .  AlignDB first builds profile sequence set increments batchSize entire sequence set required fit memory.  Next two profiles aligned using dynamic programming.  Finally, new alignment applied sequences incrementally added add2tbl. Two identifiers tblNames must provided, indicating two sets sequences align.  sequences corresponding first identifier tblName aligned second identifier tblName.  aligned sequences added add2tbl new identifier formed concatenation two identifiers tblNames.  (See examples section .)","code":""},{"path":"/reference/AlignDB.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Align Two Sets of Aligned Sequences in a Sequence Database — AlignDB","text":"Wright, E. S. (2015). DECIPHER: harnessing local sequence context improve protein multiple sequence alignment. BMC Bioinformatics, 16, 322. http://doi.org/10.1186/s12859-015-0749-z Wright, E. S. (2020). RNAconTest: comparing tools noncoding RNA multiple sequence alignment based structural consistency. RNA 2020, 26, 531-540.","code":""},{"path":[]},{"path":"/reference/AlignDB.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Align Two Sets of Aligned Sequences in a Sequence Database — AlignDB","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/AlignDB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Align Two Sets of Aligned Sequences in a Sequence Database — AlignDB","text":"","code":"gen <- system.file(\"extdata\", \"Bacteria_175seqs.gen\", package=\"DECIPHER\") fas <- system.file(\"extdata\", \"Bacteria_175seqs.fas\", package=\"DECIPHER\")  # Align two tables and place result into a third dbConn <- dbConnect(SQLite(), \":memory:\") Seqs2DB(gen, \"GenBank\", dbConn, \"Seqs1\", tblName=\"Set1\") #>  Reading GenBank file chunk 1 #>  #> 175 total sequences in table Set1. #> Time difference of 0.05 secs #>  Seqs2DB(fas, \"FASTA\", dbConn, \"Seqs2\", tblName=\"Set2\") #>  Reading FASTA file chunk 1 #>  #> 175 total sequences in table Set2. #> Time difference of 0.02 secs #>  AlignDB(dbConn, tblName=c(\"Set1\", \"Set2\"), add2tbl=\"AlignedSets\") #> ================================================================================ #> Added 350 aligned sequences to table AlignedSets with identifier 'Set1_Set2'. l <- IdLengths(dbConn, \"AlignedSets\", add2tbl=TRUE) #> ================================================================================ #> Lengths counted for 350 sequences. #> Added to AlignedSets:  \"standard\", \"nonstandard\", and \"width\". #>  #> Time difference of 0.01 secs #>  BrowseDB(dbConn, tblName=\"AlignedSets\") # all sequences have the same width dbDisconnect(dbConn)  # Align two identifiers and place the result in the same table dbConn <- dbConnect(SQLite(), \":memory:\") Seqs2DB(gen, \"GenBank\", dbConn, \"Seqs1\") #>  Reading GenBank file chunk 1 #>  #> 175 total sequences in table Seqs. #> Time difference of 0.02 secs #>  Seqs2DB(fas, \"FASTA\", dbConn, \"Seqs2\") #>  Reading FASTA file chunk 1 #>  #> Added 175 new sequences to table Seqs. #> 350 total sequences in table Seqs. #> Time difference of 0.02 secs #>  AlignDB(dbConn, identifier=c(\"Seqs1\", \"Seqs2\")) #> ================================================================================ #> Added 350 aligned sequences to table Seqs with identifier 'Seqs1_Seqs2'. l <- IdLengths(dbConn, add2tbl=TRUE) #> ================================================================================ #> Lengths counted for 700 sequences. #> Added to Seqs:  \"standard\", \"nonstandard\", and \"width\". #>  #> Time difference of 0.02 secs #>  BrowseDB(dbConn) # note the sequences with a new identifier dbDisconnect(dbConn)"},{"path":"/reference/AlignProfiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Align Two Sets of Aligned Sequences — AlignProfiles","title":"Align Two Sets of Aligned Sequences — AlignProfiles","text":"Aligns two sets one aligned sequences first generating representative profiles, aligning profiles dynamic programming, finally merging two aligned sequence sets.","code":""},{"path":"/reference/AlignProfiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Align Two Sets of Aligned Sequences — AlignProfiles","text":"","code":"AlignProfiles(   pattern,   subject,   p.weight = 1,   s.weight = 1,   p.struct = NULL,   s.struct = NULL,   perfectMatch = 5,   misMatch = 0,   gapOpening = -14,   gapExtension = -2,   gapPower = -1,   terminalGap = 0,   restrict = c(-1000, 2, 10),   anchor = 0.7,   normPower = c(1, 0),   standardize = TRUE,   substitutionMatrix = NULL,   structureMatrix = NULL,   processors = 1 )"},{"path":"/reference/AlignProfiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Align Two Sets of Aligned Sequences — AlignProfiles","text":"pattern AAStringSet, DNAStringSet, RNAStringSet object aligned sequences use pattern. subject XStringSet object aligned sequences use subject.  Must match type pattern. p.weight numeric vector weights sequence pattern use generating profile, single number implying equal weights. s.weight numeric vector weights sequence subject use generating profile, single number implying equal weights. p.struct Either NULL (default), matrix, list matrices one list element per sequence pattern.  (See details section .) s.struct Either NULL (default), matrix, list matrices one list element per sequence subject.  (See details section .) perfectMatch Numeric giving reward aligning two matching nucleotides alignment.  applicable DNAStringSet RNAStringSet inputs. misMatch Numeric giving cost aligning two mismatched nucleotides alignment.  applicable DNAStringSet RNAStringSet inputs. gapOpening Numeric giving cost opening gap alignment. gapExtension Numeric giving cost extending open gap alignment. gapPower Numeric specifying exponent use gap cost function.  (See details section .) terminalGap Numeric giving cost allowing leading trailing gaps (\"-\" \".\" characters) alignment.  Either two numbers, first leading gaps second trailing gaps, single number . restrict Numeric vector length three controlling degree restriction around ridge lines dynamic programming matrix.  first element determines span region around ridge considered alignment.  default (-1000) align inputs can reasonably globally aligned without loss accuracy.  Input sequences high similarity restricted (e.g., -500), whereas pattern subject little overlap less restricted (e.g., -10000).  second element sets minimum slope either side ridge required allow restriction point.  third element sets minimum duration ridge required begin restricting matrix around ridge.  duration ridge defined number consecutive positions meeting first two conditions restriction.  (See details section .) anchor Numeric giving fraction sequences identical k-mers required become anchor point, NA use anchors. Alternatively, matrix specifying anchor regions.  (See details section .) normPower Numeric giving exponent controls degree normalization applied scores column occupancy.  two numerics provided, first controls normalization power terminal gaps, second controls internal gaps.  normPower 0 normalize scores, results columns profiles weighted equally, optimal value aligning fragmentary sequences.  normPower 1 normalizes score aligning two positions column occupancy (1 - fraction gaps).  normPower greater 1 strongly discourages aligning ``gappy'' regions alignment.  (See details section .) standardize Logical determining whether scores standardized units per matching site. Standardization effectively divides score possible alignment length scores relative rather absolute. substitutionMatrix Either substitution matrix representing substitution scores alignment name amino acid substitution matrix use alignment.  latter may one following: BLOSUM45'', BLOSUM50'', BLOSUM62'', BLOSUM80'', BLOSUM100'', PAM30'', PAM40'', PAM70'', PAM120'', PAM250'', ``MIQS''.  default (NULL) use perfectMatch misMatch penalties DNA/RNA PFASUM50 AA.  (See examples section .) structureMatrix structure matrix p.struct s.struct supplied, NULL otherwise. processors number processors use, NULL automatically detect use available processors.","code":""},{"path":"/reference/AlignProfiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Align Two Sets of Aligned Sequences — AlignProfiles","text":"XStringSet aligned sequences.","code":""},{"path":"/reference/AlignProfiles.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Align Two Sets of Aligned Sequences — AlignProfiles","text":"Profiles aligned using dynamic programming, variation Needleman-Wunsch algorithm global alignment.  dynamic programming method requires order N*M time memory space N M width pattern subject.  method works filling matrix possible ``alignment space'' considering matches, insertions, deletions two sequence profiles.  highest scoring alignment used add gaps input sequence sets. Heuristics can useful improve performance long input sequences. restrict parameter can used dynamically constrain possible ``alignment space'' paths likely include final alignment, best case can improve speed quadratic time nearly linear time.  degree restriction important, default value restrict reasonable vast majority cases.  also possible prevent restriction setting restrict extreme values requirements never met (e.g., c(-1e10, 1e10, 1e10)). argument anchor can used split global alignment multiple sub-alignments.  can greatly decrease memory requirement long sequences appropriate anchor points can found.  Anchors 15-mer (DNA/RNA) 7-mer (AA) subsequences shared least anchor fraction pattern(s) subject(s). Anchored ranges extended along length sequence manner designed split alignment sub-alignments can separately solved.  input sequences, default anchoring effect accuracy, anchoring can disabled setting anchor=NA. Alternatively, anchor can matrix 4 rows one column per anchor.  first two rows correspond anchor start end positions pattern sequence(s), second two rows equivalent anchor region subject sequence(s).  Anchors specified manner must strictly increasing (non-overlapping) sequences, anchor width least two positions.  Note anchors equal length, case anchor regions also aligned.  Manually splitting alignment subtasks can sometimes make efficient, typically automatic anchoring effective. argument normPower determines distribution information treated alignment.  Higher values normPower encourage alignment columns higher occupancy (1 - fraction gaps), de-emphasize alignment columns containing many gaps.  normPower 0 treat columns equally regardless occupancy, can useful pattern subject contain many incomplete (fragment) sequences.  example, normPower set 0 aligning many short reads longer reference sequence. arguments p.struct s.struct may used provide secondary structure probabilities form list containing matrices single matrix.  input list, list element must contain matrix dimensions q*w, q number possible secondary structure states, w width unaligned pattern sequence.  Values matrix represent probability given state position sequence.  Alternatively, single matrix can used input w width entire pattern subject alignment.  structureMatrix must supplied along structures.  functions PredictHEC PredictDBN can used predict secondary structure probabilities format required AlignProfiles (amino acid RNA sequences, respectively). gap cost function based observation gap lengths best approximated Zipfian distribution (Chang & Benner, 2004).  cost inserting gap length L equal : gapOpening + gapExtension*sum(seq_len(L - 1)^gapPower) L > 1, gapOpen L = 1.  function effectively penalizes shorter gaps significantly longer gaps gapPower < 0, equivalent affine gap penalty gapPower 0.","code":""},{"path":"/reference/AlignProfiles.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Align Two Sets of Aligned Sequences — AlignProfiles","text":"Chang, M. S. S., & Benner, S. . (2004). Empirical Analysis Protein Insertions Deletions Determining Parameters Correct Placement Gaps Protein Sequence Alignments. Journal Molecular Biology, 341(2), 617-631. Needleman, S., & Wunsch, C. (1970). general method applicable search similarities amino acid sequence two proteins. Journal Molecular Biology, 48(3), 443-453. Wright, E. S. (2015). DECIPHER: harnessing local sequence context improve protein multiple sequence alignment. BMC Bioinformatics, 16, 322. http://doi.org/10.1186/s12859-015-0749-z Wright, E. S. (2020). RNAconTest: comparing tools noncoding RNA multiple sequence alignment based structural consistency. RNA 2020, 26, 531-540. Yu, Y.-K., et al. (2015). Log-odds sequence logos. Bioinformatics, 31(3), 324-331. http://doi.org/10.1093/bioinformatics/btu634","code":""},{"path":[]},{"path":"/reference/AlignProfiles.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Align Two Sets of Aligned Sequences — AlignProfiles","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/AlignProfiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Align Two Sets of Aligned Sequences — AlignProfiles","text":"","code":"# align two sets of sequences db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") dna1 <- SearchDB(db, remove=\"common\", limit=100) # the first 100 sequences #> Search Expression: #> select row_names, sequence from _Seqs where row_names in (select row_names #> from Seqs) limit 100 #>  #> DNAStringSet of length: 100 #> Time difference of 0 secs #>  dna2 <- SearchDB(db, remove=\"common\", limit=\"100,100\") # the rest #> Search Expression: #> select row_names, sequence from _Seqs where row_names in (select row_names #> from Seqs) limit 100,100 #>  #> DNAStringSet of length: 75 #> Time difference of 0 secs #>  alignedDNA <- AlignProfiles(dna1, dna2) BrowseSeqs(alignedDNA, highlight=1)  # specify a DNA substitution matrix subMatrix <- matrix(0,                     nrow=4, ncol=4,                     dimnames=list(DNA_BASES, DNA_BASES)) diag(subMatrix) <- 5 # perfectMatch alignedDNA.defaultSubM <- AlignProfiles(dna1, dna2, substitutionMatrix=subMatrix) all(alignedDNA.defaultSubM==alignedDNA) #> [1] TRUE  # specify a different DNA substitution matrix subMatrix2 <- matrix(c(12, 3, 5, 3, 3, 12, 3, 6, 5, 3, 11, 3, 3, 6, 3, 9),                     nrow=4, ncol=4,                     dimnames=list(DNA_BASES, DNA_BASES)) alignedDNA.alterSubM <- AlignProfiles(dna1, dna2, substitutionMatrix=subMatrix2) all(alignedDNA.alterSubM==alignedDNA) #> [1] TRUE  # anchors are found automatically by default, but it is also # possible to specify anchor regions between the sequences anchors <- matrix(c(774, 788, 752, 766), nrow=4) anchors #>      [,1] #> [1,]  774 #> [2,]  788 #> [3,]  752 #> [4,]  766 subseq(dna1, anchors[1, 1], anchors[2, 1]) #> DNAStringSet object of length 100: #>       width seq                                             names                #>   [1]    15 CCTGGTAGTCCACGC                                 1 #>   [2]    15 CCTGGTAGTCCACGC                                 2 #>   [3]    15 CCTGGTAGTCCACGC                                 3 #>   [4]    15 CCTGGTAGTCCACGC                                 4 #>   [5]    15 CCTGGTAGTCCACGC                                 5 #>   ...   ... ... #>  [96]    15 CCTGGTAGTCCACGC                                 96 #>  [97]    15 CCTGGTAGTCCACGC                                 97 #>  [98]    15 CCTGGTAGTCCACGC                                 98 #>  [99]    15 CCTGGTAGTCCACGC                                 99 #> [100]    15 CCTGGTAGTCCACGC                                 100 subseq(dna2, anchors[3, 1], anchors[4, 1]) #> DNAStringSet object of length 75: #>      width seq                                              names                #>  [1]    15 CCTGGTAGTCCACGC                                  101 #>  [2]    15 CCTGGTAGTCCACGC                                  102 #>  [3]    15 CCTGGTAGTCCACGC                                  103 #>  [4]    15 CCTGGTAGTCCACGC                                  104 #>  [5]    15 CCTGGTAGTCCACGC                                  105 #>  ...   ... ... #> [71]    15 CCTGGTAGTCCACGC                                  171 #> [72]    15 CCTGGTAGTCCACGC                                  172 #> [73]    15 CCAGGTAGTCTACGC                                  173 #> [74]    15 CCCTGTAGTCCTGGC                                  174 #> [75]    15 CCCTGTAGTCCTGGC                                  175 alignedDNA2 <- AlignProfiles(dna1, dna2, anchor=anchors)"},{"path":"/reference/AlignSeqs.html","id":null,"dir":"Reference","previous_headings":"","what":"Align a Set of Unaligned Sequences — AlignSeqs","title":"Align a Set of Unaligned Sequences — AlignSeqs","text":"Performs profile--profile alignment multiple unaligned sequences following guide tree.","code":""},{"path":"/reference/AlignSeqs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Align a Set of Unaligned Sequences — AlignSeqs","text":"","code":"AlignSeqs(   myXStringSet,   guideTree = NULL,   iterations = 2,   refinements = 1,   gapOpening = c(-18, -14),   gapExtension = c(-3, -2),   useStructures = TRUE,   structures = NULL,   FUN = AdjustAlignment,   levels = c(0.9, 0.7, 0.7, 0.4, 10, 5, 5, 2),   alphabet = AA_REDUCED[[1]],   processors = 1,   verbose = TRUE,   ... )"},{"path":"/reference/AlignSeqs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Align a Set of Unaligned Sequences — AlignSeqs","text":"myXStringSet AAStringSet, DNAStringSet, RNAStringSet object unaligned sequences. guideTree Either NULL dendrogram giving ordered tree structure align profiles.  NULL guide tree automatically constructed based order shared k-mers. iterations Number iteration steps perform.  iteration step guide tree regenerated based alignment sequences realigned. refinements Number refinement steps perform.  refinement step groups sequences realigned rest sequences, best two alignments (realignment) kept. gapOpening Single numeric giving cost opening gap alignment, two numbers giving minimum maximum costs.  latter case cost varied depending upon whether groups sequences aligned nearly identical maximally distant. gapExtension Single numeric giving cost extending open gap alignment, two numbers giving minimum maximum costs.  latter case cost varied depending upon whether groups sequences aligned nearly identical maximally distant. useStructures Logical indicating whether use secondary structure predictions alignment.  TRUE (default), secondary structure probabilities automatically calculated amino acid RNA sequences provided (.e., structures NULL). structures Either list secondary structure probabilities matching structureMatrix, output PredictHEC PredictDBN, NULL generate structures automatically.  applicable myXStringSet AAStringSet RNAStringSet. FUN function applied profile--profile alignment. (See details section .) levels Numeric eight elements specifying levels trigger events.  (See details section .) alphabet Character vector amino acid groupings used reduce 20 standard amino acids smaller groups.  Alphabet reduction helps find distant homologies sequences.  non-reduced amino acid alphabet can used setting alphabet equal AA_STANDARD. applicable myXStringSet AAStringSet. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display progress. ... arguments passed directly AlignProfiles, including perfectMatch, misMatch, gapPower, terminalGap, restrict, anchor, normPower, standardize, substitutionMatrix, structureMatrix.","code":""},{"path":"/reference/AlignSeqs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Align a Set of Unaligned Sequences — AlignSeqs","text":"XStringSet aligned sequences.","code":""},{"path":"/reference/AlignSeqs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Align a Set of Unaligned Sequences — AlignSeqs","text":"profile--profile method aligns sequence set merging profiles along guide tree input sequences aligned.  process three main steps: (1) guideTree=NULL, initial single-linkage guide tree constructed based distance matrix shared k-mers.  Alternatively, dendrogram can provided initial guideTree.  (2) iterations greater zero, UPGMA guide tree built based initial alignment sequences re-aligned along tree.  process repeated iterations times convergence.  (3) refinements greater zero, subsets alignment re-aligned remainder alignment.  process generates two alignments, best chosen based sum--pairs score.  refinement process repeated refinements times, convergence. purpose levels speed-alignment process running time consuming processes unlikely change outcome.  first four levels control refinements occur function FUN run alignment.  default levels specify events happen 0.9 (AA; levels[1]) 0.7 (DNA/RNA; levels[3]) average dissimilarity initial tree, 0.7 (AA; levels[2]) 0.4 (DNA/RNA; levels[4]) average dissimilarity iterative tree(s), every tenth improvement made refinement.  sixth element levels (levels[6]) prevents FUN applied point less 5 sequences. FUN function always applied returning alignment long least levels[6] sequences.  default FUN AdjustAlignment, FUN can function takes XStringSet first argument, well weights, processors, substitutionMatrix optional arguments.  example, default FUN altered perform changes setting equal function(x, ...) return(x), x XStringSet. Secondary structures automatically computed amino acid RNA sequences unless structures provided useStructures FALSE.  default structureMatrix used unless alternative provided.  RNA sequences, secondary structures computed total length initial guide tree least 5 (levels[7]) length subsequent trees least 2 (levels[8]).","code":""},{"path":"/reference/AlignSeqs.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Align a Set of Unaligned Sequences — AlignSeqs","text":"Wright, E. S. (2015). DECIPHER: harnessing local sequence context improve protein multiple sequence alignment. BMC Bioinformatics, 16, 322. http://doi.org/10.1186/s12859-015-0749-z Wright, E. S. (2020). RNAconTest: comparing tools noncoding RNA multiple sequence alignment based structural consistency. RNA 2020, 26, 531-540.","code":""},{"path":[]},{"path":"/reference/AlignSeqs.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Align a Set of Unaligned Sequences — AlignSeqs","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/AlignSeqs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Align a Set of Unaligned Sequences — AlignSeqs","text":"","code":"db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") dna <- SearchDB(db, remove=\"all\") #> Search Expression: #> select row_names, sequence from _Seqs where row_names in (select row_names #> from Seqs) #>  #> DNAStringSet of length: 175 #> Time difference of 0.01 secs #>  alignedDNA <- AlignSeqs(dna) #> Determining distance matrix based on shared 9-mers: #> ================================================================================ #>  #> Time difference of 1.52 secs #>  #> Clustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.01 secs #>  #> Aligning Sequences: #> ================================================================================ #>  #> Time difference of 1.4 secs #>  #> Iteration 1 of 2: #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.07 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.02 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 1.05 secs #>  #> Iteration 2 of 2: #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.07 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.01 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 0.37 secs #>  BrowseSeqs(alignedDNA, highlight=1)  # use secondary structure with RNA sequences alignedRNA <- AlignSeqs(RNAStringSet(dna)) #> Determining distance matrix based on shared 9-mers: #> ================================================================================ #>  #> Time difference of 1.52 secs #>  #> Clustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.01 secs #>  #> Aligning Sequences: #> ================================================================================ #>  #> Time difference of 1.76 secs #>  #> Iteration 1 of 2: #> Predicting RNA Secondary Structures: #> ================================================================================ #>  #> Time difference of 1.49 secs #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.07 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.01 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 1.67 secs #>  #> Iteration 2 of 2: #> Predicting RNA Secondary Structures: #> ================================================================================ #>  #> Time difference of 1.51 secs #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.07 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.01 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 0.59 secs #>  BrowseSeqs(alignedRNA, highlight=1)"},{"path":"/reference/AlignSynteny.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise Aligns Syntenic Blocks — AlignSynteny","title":"Pairwise Aligns Syntenic Blocks — AlignSynteny","text":"Performs pairwise alignment blocks synteny sets sequences.","code":""},{"path":"/reference/AlignSynteny.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise Aligns Syntenic Blocks — AlignSynteny","text":"","code":"AlignSynteny(   synteny,   dbFile,   tblName = \"Seqs\",   identifier = \"\",   processors = 1,   verbose = TRUE,   ... )"},{"path":"/reference/AlignSynteny.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise Aligns Syntenic Blocks — AlignSynteny","text":"synteny object class ``Synteny''. dbFile SQLite connection object character string specifying path database file. tblName Character string specifying table sequences located used create object synteny. identifier Optional character string used narrow search results matching specific identifier, integer sequence corresponding indices rownames(synteny).  \"\" (default), identifiers selected synteny. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display progress. ... arguments passed directly AlignProfiles, including perfectMatch, misMatch, gapPower, terminalGap, restrict, normPower, substitutionMatrix.","code":""},{"path":"/reference/AlignSynteny.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pairwise Aligns Syntenic Blocks — AlignSynteny","text":"list elements pair identifiers synteny.  list element contains DNAStringSetList one pairwise alignment per syntenic block.","code":""},{"path":"/reference/AlignSynteny.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pairwise Aligns Syntenic Blocks — AlignSynteny","text":"AlignSynteny extract sequence regions belonging syntenic blocks synteny, perform pairwise alignment AlignProfiles.  Hits used anchor alignment regions anchors aligned.","code":""},{"path":[]},{"path":"/reference/AlignSynteny.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Pairwise Aligns Syntenic Blocks — AlignSynteny","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/AlignSynteny.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pairwise Aligns Syntenic Blocks — AlignSynteny","text":"","code":"db <- system.file(\"extdata\", \"Influenza.sqlite\", package=\"DECIPHER\") synteny <- FindSynteny(db, minScore=50) #> ================================================================================ #>  #> Time difference of 0.43 secs #>  DNA <- AlignSynteny(synteny, db) #> ================================================================================ #>  #> Time difference of 0.5 secs #>  names(DNA) #>  [1] \"H9N2/H5N1\" \"H9N2/H2N2\" \"H9N2/H7N9\" \"H9N2/H1N1\" \"H5N1/H2N2\" \"H5N1/H7N9\" #>  [7] \"H5N1/H1N1\" \"H2N2/H7N9\" \"H2N2/H1N1\" \"H7N9/H1N1\" DNA[[1]] # the first set of pairwise alignments #> DNAStringSetList of length 8 #> [[\"1\"]] H9N2=GCAAAAGCAGGCAAACCATTTGAATGGATGTCAATCCGACTTTACTTTTCTTAAAAGTGCCAGC... #> [[\"2\"]] H9N2=CAAAAGCAGGTCAATTATATTCAATATGGAAAGAATAAAAGAACTAAGAAATTTGATGTCGCAA... #> [[\"3\"]] H9N2=AAAGCAGGTACTGATCCAAAATGGAAGACTTTGTGCGACAGTGCTTCAATCCAATGATTGTCGA... #> [[\"4\"]] H9N2=AGCAGGGTTAATAATCACTCACTGAGTGACATCAACATCATGGCGTCGCAAGGCACCAAACGAT... #> [[\"5\"]] H9N2=CAAAAGCAGGTAGATATTGAAAGATGAGTCTTCTAACCGAGGTCGAAACGTACGTTCTCTCTAT... #> [[\"6\"]] H9N2=GTGACAAAGACATAATGGATTCCAACACTGTGTCAAGCTTTCAGGTAGACTGCTTTCTTTGGCA... #> [[\"7\"]] H9N2=GAATGGTCCTACATCGTCGAAAGATCATCAGCTGTAAATGGAACGTGTTACCCTGGGAATGTAG... #> [[\"8\"]] H9N2=ATGAATCCAAATCAAAAGATAATAGCACTTGGCTCTGTTTCTATAACTATTGCGACAATATGTT... DNA[[1]][[1]] # the first block of synteny between H9N2 & H5N1 #> DNAStringSet object of length 2: #>     width seq                                               names                #> [1]  2328 GCAAAAGCAGGCAAACCATTTGA...GCTTGTCCTTCATGAAAAAATGC H9N2 #> [2]  2328 GCAAAAGCAGGCAAACCATTTGA...GCTTGTCCTTCATGAAAAAATGC H5N1 unlist(DNA[[2]]) # a DNAStringSet of synteny between H9N2 & H2N2 #> DNAStringSet object of length 16: #>      width seq                                              names                #>  [1]  2328 GCAAAAGCAGGCAAACCATTTGA...CTTGTCCTTCATGAAAAAATGC 1.H9N2 #>  [2]  2328 GCAAAAGCAGGCAAACCATTTGA...CTTGTCCTTCATGAAAAAATGC 1.H2N2 #>  [3]  2339 CAAAAGCAGGTCAATTATATTCA...TAAAAACGACCTTGTTTCTACT 2.H9N2 #>  [4]  2339 CAAAAGCAGGTCAATTATATTCA...TAAAAACGACCTTGTTTCTACT 2.H2N2 #>  [5]  2225 AAAGCAGGTACTGATCCAAAATG...GTCCAAAAAAGTACCTTGTTTC 3.H9N2 #>  ...   ... ... #> [12]  1007 CAAAAGCAGGTAGATATTGAAAG...TCAGCATAGAGTTGGAGTAAAA 6.H2N2 #> [13]   890 AGCAAAAGCAGGGTGACAAAGAC...AAAAAACACCCTTGTTTCTACT 7.H9N2 #> [14]   890 AGCAAAAGCAGGGTGACAAAGAC...AAAAAACACCCTTGTTTCTACT 7.H2N2 #> [15]  1129 CTTTTCGTGTGGGGCATACATCA...TGCAGATGCAACATTTGTATAT 8.H9N2 #> [16]  1129 CTGTACATTTGGGGGGTTCACCA...ATTAGGTGCAACATTTGCATTT 8.H2N2"},{"path":"/reference/AlignTranslation.html","id":null,"dir":"Reference","previous_headings":"","what":"Align Sequences By Their Amino Acid Translation — AlignTranslation","title":"Align Sequences By Their Amino Acid Translation — AlignTranslation","text":"Performs alignment set DNA RNA sequences aligning corresponding amino acid sequences.","code":""},{"path":"/reference/AlignTranslation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Align Sequences By Their Amino Acid Translation — AlignTranslation","text":"","code":"AlignTranslation(   myXStringSet,   sense = \"+\",   direction = \"5' to 3'\",   readingFrame = NA,   type = class(myXStringSet),   geneticCode = GENETIC_CODE,   ... )"},{"path":"/reference/AlignTranslation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Align Sequences By Their Amino Acid Translation — AlignTranslation","text":"myXStringSet DNAStringSet RNAStringSet object unaligned sequences. sense Single character specifying sense input sequences, either positive (\"+\") coding strand negative (\"-\") non-coding strand. direction Direction input sequences, either \"5' 3'\" \"3' 5'\". readingFrame Numeric vector giving single reading frame sequences, individual reading frame sequence myXStringSet.  readingFrame can either 1, 2, 3 begin translating first, second, third nucleotide position, NA (default) guess reading frame. (See details section .) type Character string indicating type output desired.  (abbreviation ) one \"DNAStringSet\", \"RNAStringSet\", \"AAStringSet\", \"\".  (See value section .) geneticCode Either character vector giving genetic code format GENETIC_CODE (default), list containing one genetic code sequence myXStringSet. ... arguments passed directly AlignSeqs, including gapOpening, gapExtension, gapPower, terminalGap, restrict, anchor, normPower, substitutionMatrix, structureMatrix, standardize, alphabet, guideTree, iterations, refinements, useStructures, structures, FUN, levels.","code":""},{"path":"/reference/AlignTranslation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Align Sequences By Their Amino Acid Translation — AlignTranslation","text":"XStringSet class specified type, list two components (nucleotides amino acids) type \"\".  Note incomplete starting ending codons translated mask character (\"+\") result includes AAStringSet.","code":""},{"path":"/reference/AlignTranslation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Align Sequences By Their Amino Acid Translation — AlignTranslation","text":"Alignment proteins often accurate alignment coding nucleic acid sequences.  function aligns input nucleic acid sequences via aligning translated amino acid sequences.  First, input sequences translated according specified sense, direction, readingFrame.  resulting amino acid sequences aligned using AlignSeqs, alignment (conceptually) reverse translated original sequence type, sense, direction.  alignment protein sequences generally accurate, aligning translations ensure reading frame maintained nucleotide sequences. readingFrame NA (default) attempt made guess reading frame sequence based number stop codons translated amino acids.  sequence, first reading frame chosen (either 1, 2, 3) without stop codons, except final position.  number stop codons inconclusive sequence reading frame default 1. entire length sequence translated spite stop codons identified.  Note method constructive circumstances substantially long coding sequence single stop codon expected final position, therefore preferable specify reading frame sequence known.","code":""},{"path":"/reference/AlignTranslation.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Align Sequences By Their Amino Acid Translation — AlignTranslation","text":"Wright, E. S. (2015). DECIPHER: harnessing local sequence context improve protein multiple sequence alignment. BMC Bioinformatics, 16, 322. http://doi.org/10.1186/s12859-015-0749-z","code":""},{"path":[]},{"path":"/reference/AlignTranslation.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Align Sequences By Their Amino Acid Translation — AlignTranslation","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/AlignTranslation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Align Sequences By Their Amino Acid Translation — AlignTranslation","text":"","code":"# first three sequences translate to  MFITP* # and the last sequence translates as MF-TP* rna <- RNAStringSet(c(\"AUGUUCAUCACCCCCUAA\", \"AUGUUCAUAACUCCUUGA\",   \"AUGUUCAUUACACCGUAG\", \"AUGUUUACCCCAUAA\")) RNA <- AlignSeqs(rna, verbose=FALSE) RNA #> RNAStringSet object of length 4: #>     width seq #> [1]    18 AUGUUCAUCACCCCCUAA #> [2]    18 AUGUUCAUAACUCCUUGA #> [3]    18 AUGUUCAUUACACCGUAG #> [4]    18 AUGU---UUACCCCAUAA  RNA <- AlignTranslation(rna, verbose=FALSE) RNA #> RNAStringSet object of length 4: #>     width seq #> [1]    18 AUGUUCAUCACCCCCUAA #> [2]    18 AUGUUCAUAACUCCUUGA #> [3]    18 AUGUUCAUUACACCGUAG #> [4]    18 ---AUGUUUACCCCAUAA  AA <- AlignTranslation(rna, type=\"AAStringSet\", verbose=FALSE) AA #> AAStringSet object of length 4: #>     width seq #> [1]     6 MFITP* #> [2]     6 MFITP* #> [3]     6 MFITP* #> [4]     6 -MFTP*  BOTH <- AlignTranslation(rna, type=\"both\", verbose=FALSE) BOTH #> [[1]] #> RNAStringSet object of length 4: #>     width seq #> [1]    18 AUGUUCAUCACCCCCUAA #> [2]    18 AUGUUCAUAACUCCUUGA #> [3]    18 AUGUUCAUUACACCGUAG #> [4]    18 ---AUGUUUACCCCAUAA #>  #> [[2]] #> AAStringSet object of length 4: #>     width seq #> [1]     6 MFITP* #> [2]     6 MFITP* #> [3]     6 MFITP* #> [4]     6 -MFTP* #>   # example of aligning many protein coding sequences: fas <- system.file(\"extdata\", \"50S_ribosomal_protein_L2.fas\", package=\"DECIPHER\") dna <- readDNAStringSet(fas) DNA <- AlignTranslation(dna) # align the translation then reverse translate #> Determining distance matrix based on shared 5-mers: #> ================================================================================ #>  #> Time difference of 0.73 secs #>  #> Clustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.02 secs #>  #> Aligning Sequences: #> ================================================================================ #>  #> Time difference of 0.82 secs #>  #> Iteration 1 of 2: #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.06 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.03 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 0.4 secs #>  #> Iteration 2 of 2: #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.06 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.03 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 0.04 secs #>  DNA #> DNAStringSet object of length 317: #>       width seq                                             names                #>   [1]  1011 ----------------------...---------------------- Rickettsia prowaz... #>   [2]  1011 ----------------------...---------------------- Porphyromonas gin... #>   [3]  1011 ----------------------...---------------------- Porphyromonas gin... #>   [4]  1011 ----------------------...---------------------- Porphyromonas gin... #>   [5]  1011 ----------------------...---------------------- Pasteurella multo... #>   ...   ... ... #> [313]  1011 ----------------------...---------------------- Pectobacterium at... #> [314]  1011 ----------------------...---------------------- Acinetobacter sp.... #> [315]  1011 ----------------------...GGGTCGCGGTGGTCGTCAGTCT Thermosynechococc... #> [316]  1011 ----------------------...---------------------- Bradyrhizobium ja... #> [317]  1011 ----------------------...AGGT------------------ Gloeobacter viola...  # using a mixture of standard and non-standard genetic codes gC1 <- getGeneticCode(id_or_name2=\"1\", full.search=FALSE, as.data.frame=FALSE) # Mollicutes use an alternative genetic code gC2 <- getGeneticCode(id_or_name2=\"4\", full.search=FALSE, as.data.frame=FALSE) w <- grep(\"Mycoplasma|Ureaplasma\", names(dna)) gC <- vector(\"list\", length(dna)) gC[-w] <- list(gC1) gC[w] <- list(gC2) AA <- AlignTranslation(dna, geneticCode=gC, type=\"AAStringSet\") #> Determining distance matrix based on shared 5-mers: #> ================================================================================ #>  #> Time difference of 0.73 secs #>  #> Clustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.02 secs #>  #> Aligning Sequences: #> ================================================================================ #>  #> Time difference of 0.82 secs #>  #> Iteration 1 of 2: #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.06 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.03 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 0.4 secs #>  #> Iteration 2 of 2: #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.06 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.03 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 0.05 secs #>  BrowseSeqs(AA)"},{"path":"/reference/AmplifyDNA.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Amplification of DNA by PCR — AmplifyDNA","title":"Simulate Amplification of DNA by PCR — AmplifyDNA","text":"Predicts amplification efficiency theoretical PCR products (amplicons) given one primer sequences.","code":""},{"path":"/reference/AmplifyDNA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Amplification of DNA by PCR — AmplifyDNA","text":"","code":"AmplifyDNA(   primers,   myDNAStringSet,   maxProductSize,   annealingTemp,   P,   ions = 0.2,   includePrimers = TRUE,   minEfficiency = 0.001,   ... )"},{"path":"/reference/AmplifyDNA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Amplification of DNA by PCR — AmplifyDNA","text":"primers DNAStringSet object character vector one unaligned primer sequences 5' 3' orientation. myDNAStringSet DNAStringSet object character vector unaligned template DNA sequences 5' 3' orientation. maxProductSize Integer specifying maximum length PCR products (amplicons) nucleotides. annealingTemp Numeric specifying annealing temperature used PCR reaction. P Numeric giving molar concentration primers reaction. ions Numeric giving molar sodium equivalent ionic concentration. Values may range 0.01M 1M. includePrimers Logical indicating whether include primer sequences theoretical PCR products.  (See details section .) ... Additional arguments passed directly CalculateEfficiencyPCR, including batchSize, taqEfficiency, maxDistance, maxGaps, processors.","code":""},{"path":"/reference/AmplifyDNA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Amplification of DNA by PCR — AmplifyDNA","text":"DNAStringSet object containing potential PCR products, sorted highest--lowest amplification efficiency.  sequences named predicted amplification efficiency followed index primer primers name (index names missing) amplified sequence myDNAStringSet.  (See examples section .)","code":""},{"path":"/reference/AmplifyDNA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Amplification of DNA by PCR — AmplifyDNA","text":"Exponential amplification PCR requires annealing elongation two primers target sites opposing strands template DNA.  template DNA sequence (e.g., chromosome) known predictions theoretical amplicons can obtained silico simulations amplification.  AmplifyDNA first searches primer target sites template DNA, calculates amplification efficiency target site using CalculateEfficiencyPCR.  Ambiguity codes (IUPAC_CODE_MAP) supported primers, myDNAStringSet prevent trivial matches (e.g., runs N's). taqEfficiency TRUE (default), amplification efficiency primer defined product hybridization efficiency elongation efficiency.  Amplification efficiency must least minEfficiency primer amplified silico.  Overall amplification efficiency PCR product calculated geometric mean two (.e., forward reverse) primers' efficiencies. Finally, amplicons generated two primers within maxProductSize nucleotides downstream . Potential PCR products returned, either without including primer sequences amplicon.  default (includePrimers=TRUE) incorporate primer sequences normally occur amplification.  alternative return complete template sequence including target sites, may exactly match primer sequences.  Note amplicons may duplicated different input primers can amplify region DNA.","code":""},{"path":"/reference/AmplifyDNA.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Simulate Amplification of DNA by PCR — AmplifyDNA","text":"program OligoArrayAux (http://www.unafold.org/Dinamelt/software/oligoarrayaux.php) must installed location accessible system.  example, following code print installed OligoArrayAux version executed R console: system(\"hybrid-min -V\")","code":""},{"path":"/reference/AmplifyDNA.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate Amplification of DNA by PCR — AmplifyDNA","text":"ES Wright et al. (2013) \"Exploiting Extension Bias PCR Improve Primer Specificity Ensembles Nearly Identical DNA Templates.\" Environmental Microbiology, doi:10.1111/1462-2920.12259.","code":""},{"path":[]},{"path":"/reference/AmplifyDNA.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate Amplification of DNA by PCR — AmplifyDNA","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/AmplifyDNA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Amplification of DNA by PCR — AmplifyDNA","text":"","code":"data(yeastSEQCHR1)  # not run (must have OligoArrayAux installed first):  # match a single primer that acts as both the forward and reverse primer1 <- \"TGGAAGCTGAAACG\" if (FALSE) AmplifyDNA(primer1, yeastSEQCHR1, annealingTemp=55, P=4e-7, maxProductSize=500)  # perform a typical amplification with two primer sequences: primer2 <- c(\"GGCTGTTGTTGGTGTT\", \"TGTCATCAGAACACCAA\") if (FALSE) AmplifyDNA(primer2, yeastSEQCHR1, annealingTemp=55, P=4e-7, maxProductSize=500)  # perform a multiplex PCR amplification with multiple primers: primers <- c(primer1, primer2) if (FALSE) AmplifyDNA(primers, yeastSEQCHR1, annealingTemp=55, P=4e-7, maxProductSize=500)"},{"path":"/reference/Array2Matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Matrix Representation of a Microarray — Array2Matrix","title":"Create a Matrix Representation of a Microarray — Array2Matrix","text":"Converts output DesignArray sparse matrix format used NNLS.","code":""},{"path":"/reference/Array2Matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Matrix Representation of a Microarray — Array2Matrix","text":"","code":"Array2Matrix(probes, verbose = TRUE)"},{"path":"/reference/Array2Matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Matrix Representation of a Microarray — Array2Matrix","text":"probes set microarray probes format output DesignArray. verbose Logical indicating whether display progress.","code":""},{"path":"/reference/Array2Matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Matrix Representation of a Microarray — Array2Matrix","text":"list specifying hybridization efficiency probe potential templates. Element's row index sparse matrix. j Element's column index sparse matrix. x Non-zero elements' values representing hybridization efficiencies. dimnames list two components: names probe, names template.","code":""},{"path":"/reference/Array2Matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Matrix Representation of a Microarray — Array2Matrix","text":"microarray can represented matrix hybridization efficiencies, rows represent probes columns represent possible templates.  matrix sparse since microarray probes designed target small subset possible templates.","code":""},{"path":"/reference/Array2Matrix.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create a Matrix Representation of a Microarray — Array2Matrix","text":"ES Wright et al. (2013) Identification Bacterial Archaeal Communities Source Tap. Water Research Foundation, Denver, CO. DR Noguera, et al. (2014). Mathematical tools optimize design oligonucleotide probes primers. Applied Microbiology Biotechnology. doi:10.1007/s00253-014-6165-x.","code":""},{"path":[]},{"path":"/reference/Array2Matrix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a Matrix Representation of a Microarray — Array2Matrix","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/Array2Matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Matrix Representation of a Microarray — Array2Matrix","text":"","code":"fas <- system.file(\"extdata\", \"Bacteria_175seqs.fas\", package=\"DECIPHER\") dna <- readDNAStringSet(fas) names(dna) <- 1:length(dna) probes <- DesignArray(dna) #> ================================================================================ #> Time difference of 3.64 secs #>  A <- Array2Matrix(probes) #> ================================================================================ #>  #> Time difference of 0.03 secs #>"},{"path":"/reference/BrowseDB.html","id":null,"dir":"Reference","previous_headings":"","what":"View a Database Table in a Web Browser — BrowseDB","title":"View a Database Table in a Web Browser — BrowseDB","text":"Opens html file web browser show contents table database.","code":""},{"path":"/reference/BrowseDB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"View a Database Table in a Web Browser — BrowseDB","text":"","code":"BrowseDB(   dbFile,   htmlFile = paste(tempdir(), \"/db.html\", sep = \"\"),   openURL = interactive(),   tblName = \"Seqs\",   identifier = \"\",   limit = -1,   orderBy = \"row_names\",   maxChars = 50,   clause = \"\" )"},{"path":"/reference/BrowseDB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"View a Database Table in a Web Browser — BrowseDB","text":"dbFile SQLite connection object character string specifying path database file. htmlFile Character string giving location html file written. openURL Logical indicating whether htmlFile opened web browser. tblName Character string specifying table view. identifier Optional character string used narrow search results matching specific identifier.  \"\" identifiers selected. limit Number results display.  default (-1) limit number results. orderBy Character string giving column name sorting results.  Defaults order entries database.  Optionally can followed \" ASC\" \" DESC\" specify ascending (default) descending order. maxChars Maximum number characters display column. clause optional character string append query part ``clause''.","code":""},{"path":"/reference/BrowseDB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"View a Database Table in a Web Browser — BrowseDB","text":"Creates html table containing fields database table (openURL TRUE) opens web browser viewing. Returns htmlFile html file written successfully.","code":""},{"path":"/reference/BrowseDB.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"View a Database Table in a Web Browser — BrowseDB","text":"viewing table containing sequences, sequences purposefully shown output.","code":""},{"path":"/reference/BrowseDB.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"View a Database Table in a Web Browser — BrowseDB","text":"ES Wright (2016) \"Using DECIPHER v2.0 Analyze Big Biological Sequence Data R\". R Journal, 8(1), 352-359.","code":""},{"path":[]},{"path":"/reference/BrowseDB.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"View a Database Table in a Web Browser — BrowseDB","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/BrowseDB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"View a Database Table in a Web Browser — BrowseDB","text":"","code":"db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") BrowseDB(db)"},{"path":"/reference/BrowseSeqs.html","id":null,"dir":"Reference","previous_headings":"","what":"View Sequences in a Web Browser — BrowseSeqs","title":"View Sequences in a Web Browser — BrowseSeqs","text":"Opens html file web browser show sequences XStringSet.","code":""},{"path":"/reference/BrowseSeqs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"View Sequences in a Web Browser — BrowseSeqs","text":"","code":"BrowseSeqs(   myXStringSet,   htmlFile = paste(tempdir(), \"/myXStringSet.html\", sep = \"\"),   openURL = interactive(),   colorPatterns = TRUE,   highlight = NA,   patterns = c(\"-\", alphabet(myXStringSet, baseOnly = TRUE)),   colors = substring(rainbow(length(patterns), v = 0.8, start = 0.9, end = 0.7), 1, 7),   colWidth = Inf,   ... )"},{"path":"/reference/BrowseSeqs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"View Sequences in a Web Browser — BrowseSeqs","text":"myXStringSet XStringSet object sequences. htmlFile Character string giving location html file written. openURL Logical indicating whether htmlFile opened web browser. colorPatterns Logical specifying whether color matched patterns, integer vector providing pairs start stop boundaries coloring. highlight Numeric specifying sequence set use comparison NA color sequences (default).  highlight 0 positions differing consensus sequence highlighted. patterns Either AAStringSet, DNAStringSet, RNAStringSet object, character vector containing regular expressions, list numeric matrices, NULL.  (See details section .) colors Character vector providing color matched patterns.  Typically character vector elements 7 characters: ``#'' followed red, blue, green values hexadecimal (rescaling 0 ... 255).  Ignored patterns list matrices. colWidth Integer giving maximum number nucleotides wide display can starting new page.  Must multiple 20 (e.g., 100), Inf (default) display sequences one set rows. ... Additional arguments adjust appearance consensus sequence base display.  Passed directly ConsensusSequence AAStringSet, DNAStringSet, RNAStringSet, consensusString BStringSet.","code":""},{"path":"/reference/BrowseSeqs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"View Sequences in a Web Browser — BrowseSeqs","text":"Creates html file containing sequence data (openURL TRUE) opens web browser viewing.  layout sequence name left, position legend top, cumulative number nucleotides right, consensus sequence bottom. Returns htmlFile html file written successfully.","code":""},{"path":"/reference/BrowseSeqs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"View Sequences in a Web Browser — BrowseSeqs","text":"BrowseSeqs converts XStringSet html format viewing web browser.  sequences colored accordance patterns provided, left uncolored colorPatterns FALSE patterns NULL.  Character XStringSet patterns matched regular expressions colored according colors.  patterns list matrices, must contain one element per sequence.  matrix interpreted providing fraction red, blue, green letter sequence. Thus, colors ignored patterns list.  (See examples section .) Patterns matched across column breaks, multi-character patterns carefully considered colWidth less maximum sequence length.  Patterns matched sequentially order provided, feasible use nested patterns c(\"ACCTG\", \"CC\").  case CC'' colored differently inside previously colored ACCTG''.  Note patterns overlapping boundaries previously matched pattern matched.  example, ``ACCTG'' matched patterns=c(\"CC\", \"ACCTG\"). web browsers quickly display large amount colored text, recommended use colorPatterns = FALSE highlight sequence viewing large XStringSet.  Highlighting show characters highlighted sequence, convert matching positions sequences dots without color. Also, note web browsers display small shifts fixed-width characters may become noticeable color offsets ends long sequences.","code":""},{"path":"/reference/BrowseSeqs.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"View Sequences in a Web Browser — BrowseSeqs","text":"web browsers display colored characters equal widths. positions align across sequences try opening htmlFile different web browser.","code":""},{"path":"/reference/BrowseSeqs.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"View Sequences in a Web Browser — BrowseSeqs","text":"ES Wright (2016) \"Using DECIPHER v2.0 Analyze Big Biological Sequence Data R\". R Journal, 8(1), 352-359. Kunzmann P., et al. (2020) \"Substitution matrix based color schemes sequence alignment visualization\". BMC Bioinformatics, 21(1):209.","code":""},{"path":[]},{"path":"/reference/BrowseSeqs.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"View Sequences in a Web Browser — BrowseSeqs","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/BrowseSeqs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"View Sequences in a Web Browser — BrowseSeqs","text":"","code":"# load the example DNA sequences db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") dna <- SearchDB(db) # non-coding ribosomal RNA gene sequences #> Search Expression: #> select row_names, sequence from _Seqs where row_names in (select row_names #> from Seqs) #>  #> DNAStringSet of length: 175 #> Time difference of 0.01 secs #>   # example of using the defaults with DNA sequences BrowseSeqs(dna) # view the XStringSet  # color only \"ACTG\" and \"CSC\" patterns (where S is C or G) BrowseSeqs(dna, patterns=DNAStringSet(c(\"ACTG\", \"CSC\")))  # highlight (i.e., only fully-color) the first sequence BrowseSeqs(dna, highlight=1) # other sequences are dots where matching  # highlight the consensus sequence at the bottom BrowseSeqs(dna, highlight=0) # other sequences are dots where matching  # split the wide view into multiple vertical pages (for printing) BrowseSeqs(dna, colWidth=100, highlight=1)  # specify an alternative color scheme for -, A, C, G, T BrowseSeqs(dna, colors=c(\"#1E90FF\", \"#32CD32\", \"#9400D3\", \"black\", \"#EE3300\"))  # only color the positions within certain positional ranges (100-200 & 250-500) BrowseSeqs(dna, colorPatterns=c(100, 200, 250, 500))  # example of calling attention to letters by coloring gaps black BrowseSeqs(dna, patterns=\"-\", colors=\"black\")  if (FALSE) { # color according to base-pairing by supplying the fraction RGB for every position dbn <- PredictDBN(dna, type=\"structures\") # calculate the secondary structures # dbn now contains the scores for whether a base is paired (left/right) or unpaired dbn[[1]][, 1] # the scores for the first position in the first sequence dbn[[2]][, 10] # the scores for the tenth position in the second sequence # these positional scores can be used as shades of red, green, and blue: BrowseSeqs(dna, patterns=dbn) # red = unpaired, green = left-pairing, blue = right # positions in black are not part of the consensus secondary structure }  # color all restriction sites data(RESTRICTION_ENZYMES) # load dataset containing restriction enzyme sequences sites <- RESTRICTION_ENZYMES sites <- gsub(\"[^A-Z]\", \"\", sites) # remove non-letters sites <- DNAStringSet(sites) # convert the character vector to a DNAStringSet rc_sites <- reverseComplement(DNAStringSet(sites)) w <- which(sites != rc_sites) # find non-palindromic restriction sites sites <- c(sites, rc_sites[w]) # append their reverse complement sites <- sites[order(nchar(sites))] # match shorter sites first BrowseSeqs(dna, patterns=sites)  # color bases by quality score fastq <- system.file(\"extdata\", \"s_1_sequence.txt\", package=\"Biostrings\") reads <- readQualityScaledDNAStringSet(fastq, quality.scoring=\"solexa\") #> Warning: metadata columns on input DNAStringSet object were dropped colors <- colorRampPalette(c(\"red\", \"yellow\", \"green\"))(42) colors <- col2rgb(colors)/255 quals <- as(quality(reads), \"IntegerList\") quals <- lapply(quals, function(x) colors[, x]) BrowseSeqs(DNAStringSet(reads), patterns=quals) # green = high quality, red = low quality  # load the example protein coding sequences fas <- system.file(\"extdata\", \"50S_ribosomal_protein_L2.fas\", package=\"DECIPHER\") dna <- readDNAStringSet(fas)  # example of using the defaults with amino acid sequences aa <- unique(translate(dna)) # the unique amino acid sequences BrowseSeqs(aa)  # example of highlighting the consensus amino acid sequence AA <- AlignSeqs(aa) #> Determining distance matrix based on shared 5-mers: #> ================================================================================ #>  #> Time difference of 0.08 secs #>  #> Clustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.01 secs #>  #> Aligning Sequences: #> ================================================================================ #>  #> Time difference of 0.44 secs #>  #> Iteration 1 of 2: #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.01 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.01 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 0.29 secs #>  #> Iteration 2 of 2: #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.01 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.01 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 0.1 secs #>  BrowseSeqs(AA, highlight=0)  # example of highlighting positions that differ from the majority consensus BrowseSeqs(AA, highlight=0, threshold=0.5)  # specify an alternative color scheme for amino acids (from Kunzmann et al.) colors <- c(`-`=\"#000000\", `A`=\"#BDB1E8\", `R`=\"#EFA2C5\", `N`=\"#F6602F\",     `D`=\"#FD5559\", `C`=\"#12C7FE\", `Q`=\"#DDACB4\", `E`=\"#FEA097\", `G`=\"#F46802\",     `H`=\"#FCA708\", `I`=\"#369BD9\", `L`=\"#2E95EC\", `K`=\"#CF7690\", `M`=\"#4B8EFE\",     `F`=\"#76997D\", `P`=\"#FD2AE3\", `S`=\"#A08A9A\", `T`=\"#9A84D5\", `W`=\"#74C80D\",     `Y`=\"#9BB896\", `V`=\"#89B9F9\") BrowseSeqs(AA, colors=colors, patterns=names(colors))  # example of coloring in a reduced amino acid alphabet alpha <- AA_REDUCED[[15]] alpha # clustering of amino acids based on similarity #> [1] \"ACGPSTWY\" \"DEHKNQR\"  \"FILMV\"    BrowseSeqs(AA, patterns=c(\"-\", paste(\"[\", alpha, \"]\", sep=\"\")))  # color amino acids according to their predicted secondary structure hec <- PredictHEC(AA, type=\"probabilities\") # calculate the secondary structures # hec now contains the probability that a base is in an alpha-helix or beta-sheet hec[[3]][, 18] # the 18th position in sequence 3 is likely part of a beta-sheet (E) #>          H          E          C  #> 0.10249191 0.80619493 0.09131316  # the positional probabilities can be used as shades of red, green, and blue: BrowseSeqs(AA, patterns=hec) # red = alpha-helix, green = beta-sheet, blue = coil  # color codons according to their corresponding amino acid DNA <- AlignTranslation(dna) # align the translation then reverse translate #> Determining distance matrix based on shared 5-mers: #> ================================================================================ #>  #> Time difference of 0.73 secs #>  #> Clustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.03 secs #>  #> Aligning Sequences: #> ================================================================================ #>  #> Time difference of 0.81 secs #>  #> Iteration 1 of 2: #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.06 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.03 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 0.39 secs #>  #> Iteration 2 of 2: #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.06 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.03 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 0.04 secs #>  colors <- rainbow(21, v=0.8, start=0.9, end=0.7) # codon colors m <- match(GENETIC_CODE, unique(GENETIC_CODE)) # corresponding amino acid codonBounds <- matrix(c(seq(1, width(DNA)[1], 3), # start of codons   seq(3, width(DNA)[1], 3)), # end of codons   nrow=2,   byrow=TRUE) BrowseSeqs(DNA,   colorPatterns=codonBounds,   patterns=c(\"---\", names(GENETIC_CODE)), # codons to color   colors=c(\"black\", substring(colors[m], 1, 7)))"},{"path":"/reference/CalculateEfficiencyArray.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict the Hybridization Efficiency of Probe/Target Sequence Pairs — CalculateEfficiencyArray","title":"Predict the Hybridization Efficiency of Probe/Target Sequence Pairs — CalculateEfficiencyArray","text":"Calculates Gibbs free energy hybridization efficiency probe/target pairs varying concentrations denaturant formamide.","code":""},{"path":"/reference/CalculateEfficiencyArray.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict the Hybridization Efficiency of Probe/Target Sequence Pairs — CalculateEfficiencyArray","text":"","code":"CalculateEfficiencyArray(   probe,   target,   FA = 0,   dGini = 1.96,   Po = 10^-2.0021,   m = 0.1731,   temp = 42,   deltaGrules = NULL )"},{"path":"/reference/CalculateEfficiencyArray.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict the Hybridization Efficiency of Probe/Target Sequence Pairs — CalculateEfficiencyArray","text":"probe DNAStringSet object character vector pairwise-aligned probe sequences 5' 3' orientation. target DNAStringSet object character vector pairwise-aligned target sequences 5' 3' orientation. FA vector one formamide concentrations (percent v/v). dGini initiation free energy.  default 1.96 kcal/mol. Po effective probe concentration. m m-value defining linear relationship denaturation presence formamide. temp Equilibrium temperature degrees Celsius. deltaGrules Free energy rules possible base pairings quadruplets.  NULL, defaults parameters obtained using NimbleGen microarrays Linear Free Energy Model developed Yilmaz et al.","code":""},{"path":"/reference/CalculateEfficiencyArray.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict the Hybridization Efficiency of Probe/Target Sequence Pairs — CalculateEfficiencyArray","text":"matrix predicted Gibbs free energy (dG) hybridization efficiency () concentration formamide (FA).","code":""},{"path":"/reference/CalculateEfficiencyArray.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict the Hybridization Efficiency of Probe/Target Sequence Pairs — CalculateEfficiencyArray","text":"function calculates free energy hybridization efficiency () given formamide concentration (FA) using linear free energy model given : $$= Po*exp[-(dG_0 + m*FA)/RT]/(1+Po*exp[-(dG_0 + m*FA)/RT])$$ probe target input sequences must aligned pairs, first probe aligned first target, second--second, .  Ambiguity codes IUPAC_CODE_MAP accepted probe target sequences.  ambiguities default perfect match pairings inheriting nucleotide position opposite sequence whenever possible.  ambiguity results mismatch T'', G'', C'', '' substituted, order.  example, probe nucleotide S'' (C'' G'') considered C'' target nucleotide position C'', otherwise ambiguity interpreted G''. deltaGrules NULL rules defined data(deltaGrules) used.  Note deltaGrules format may customized application specified input.","code":""},{"path":"/reference/CalculateEfficiencyArray.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Predict the Hybridization Efficiency of Probe/Target Sequence Pairs — CalculateEfficiencyArray","text":"Yilmaz LS, Loy , Wright ES, Wagner M, Noguera DR (2012) Modeling Formamide Denaturation Probe-Target Hybrids Improved Microarray Probe Design Microbial Diagnostics. PLoS ONE 7(8): e43862. doi:10.1371/journal.pone.0043862.","code":""},{"path":[]},{"path":"/reference/CalculateEfficiencyArray.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Predict the Hybridization Efficiency of Probe/Target Sequence Pairs — CalculateEfficiencyArray","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/CalculateEfficiencyArray.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict the Hybridization Efficiency of Probe/Target Sequence Pairs — CalculateEfficiencyArray","text":"","code":"probes <- c(\"AAAAACGGGGAGCGGGGGGATACTG\", \"AAAAACTCAACCCGAGGAGCGGGGG\") targets <- c(\"CAACCCGGGGAGCGGGGGGATACTG\", \"TCGGGCTCAACCCGAGGAGCGGGGG\") result <- CalculateEfficiencyArray(probes, targets, FA=0:40) dG0 <- result[, \"dG_0\"] HE0 <- result[, \"HybEff_0\"] plot(result[1, 1:40], xlab=\"[FA]\", ylab=\"HE\", main=\"Probe/Target # 1\", type=\"l\")"},{"path":"/reference/CalculateEfficiencyFISH.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict Thermodynamic Parameters of Probe/Target Sequence Pairs — CalculateEfficiencyFISH","title":"Predict Thermodynamic Parameters of Probe/Target Sequence Pairs — CalculateEfficiencyFISH","text":"Calculates Gibbs free energy, formamide melt point, hybridization efficiency probe/target (DNA/RNA) pairs.","code":""},{"path":"/reference/CalculateEfficiencyFISH.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict Thermodynamic Parameters of Probe/Target Sequence Pairs — CalculateEfficiencyFISH","text":"","code":"CalculateEfficiencyFISH(probe, target, temp, P, ions, FA, batchSize = 1000)"},{"path":"/reference/CalculateEfficiencyFISH.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict Thermodynamic Parameters of Probe/Target Sequence Pairs — CalculateEfficiencyFISH","text":"probe DNAStringSet object character vector unaligned probe sequences 5' 3' orientation. target DNAStringSet object, RNAStringSet, character vector unaligned target non-target sequences 5' 3' orientation.  DNA base Thymine treated Uracil. temp Numeric specifying hybridization temperature, typically 46 degrees Celsius. P Numeric giving molar concentration probes hybridization. ions Numeric giving molar sodium equivalent ionic concentration. Values may range 0.01M 1M.  Note salt correction available thermodynamic rules RNA/RNA interactions, determined 1 molar concentration. FA Numeric concentration (percent v/v) denaturant formamide hybridization buffer. batchSize Integer specifying number probes simulate hybridization per batch.  See Description section .","code":""},{"path":"/reference/CalculateEfficiencyFISH.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict Thermodynamic Parameters of Probe/Target Sequence Pairs — CalculateEfficiencyFISH","text":"matrix predicted hybridization efficiency (HybEff), formamide melt point (FAm), free energy (ddG1 dG1) probe/target pair sequences.","code":""},{"path":"/reference/CalculateEfficiencyFISH.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict Thermodynamic Parameters of Probe/Target Sequence Pairs — CalculateEfficiencyFISH","text":"Hybridization pairwise probe/target (DNA/RNA) pairs simulated silico.  Gibbs free energies obtained system calls OligoArrayAux, must properly installed (see Notes section ).  Probe/target pairs sent OligoArrayAux batches batchSize, prevents systems calls many characters.  Note OligoArrayAux support degeneracy codes (non-base letters), although accepted without error.  sequences ambiguity expanded multiple permutations Disambiguate input.","code":""},{"path":"/reference/CalculateEfficiencyFISH.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Predict Thermodynamic Parameters of Probe/Target Sequence Pairs — CalculateEfficiencyFISH","text":"program OligoArrayAux (http://www.unafold.org/Dinamelt/software/oligoarrayaux.php) must installed location accessible system.  example, following code print installed OligoArrayAux version executed R console: system(\"hybrid-min -V\")","code":""},{"path":"/reference/CalculateEfficiencyFISH.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Predict Thermodynamic Parameters of Probe/Target Sequence Pairs — CalculateEfficiencyFISH","text":"ES Wright et al. (2014) \"Automated Design Probes rRNA-Targeted Fluorescence Situ Hybridization Reveals Advantages Using Dual Probes Accurate Identification.\" Applied Environmental Microbiology, doi:10.1128/AEM.01685-14.","code":""},{"path":[]},{"path":"/reference/CalculateEfficiencyFISH.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Predict Thermodynamic Parameters of Probe/Target Sequence Pairs — CalculateEfficiencyFISH","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/CalculateEfficiencyFISH.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict Thermodynamic Parameters of Probe/Target Sequence Pairs — CalculateEfficiencyFISH","text":"","code":"probe <- c(\"GGGCTTTCACATCAGACTTAAGAAACC\", \"CCCCACGCTTTCGCGCC\") target <- reverseComplement(DNAStringSet(probe)) # not run (must have OligoArrayAux installed first): if (FALSE) CalculateEfficiencyFISH(probe, target, temp=46, P=250e-9, ions=1, FA=35)"},{"path":"/reference/CalculateEfficiencyPCR.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict Amplification Efficiency of Primer Sequences — CalculateEfficiencyPCR","title":"Predict Amplification Efficiency of Primer Sequences — CalculateEfficiencyPCR","text":"Calculates amplification efficiency primers hybridization efficiency elongation efficiency target site.","code":""},{"path":"/reference/CalculateEfficiencyPCR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict Amplification Efficiency of Primer Sequences — CalculateEfficiencyPCR","text":"","code":"CalculateEfficiencyPCR(   primer,   target,   temp,   P,   ions,   batchSize = 1000,   taqEfficiency = TRUE,   maxDistance = 0.4,   maxGaps = 2,   processors = 1 )"},{"path":"/reference/CalculateEfficiencyPCR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict Amplification Efficiency of Primer Sequences — CalculateEfficiencyPCR","text":"primer DNAStringSet object character vector unaligned primer sequences 5' 3' orientation. target DNAStringSet object character vector unaligned target non-target sequences 5' 3' orientation. temp Numeric specifying annealing temperature used PCR reaction. P Numeric giving molar concentration primers reaction. ions Numeric giving molar sodium equivalent ionic concentration. Values may range 0.01M 1M. batchSize Integer specifying number primers simulate hybridization per batch.  See Description section . taqEfficiency Logical determining whether make use elongation efficiency maxDistance increase predictive accuracy Taq DNA Polymerase amplifying primers mismatches near 3' terminus. Note set FALSE using high-fidelity polymerase 3' 5' exonuclease activity. maxDistance Numeric specifying maximal fraction mismatched base pairings rolling basis beginning 3' end primer. used taqEfficiency TRUE. maxGaps Integer specifying maximum number insertions deletions (indels) primer/target alignment.  used taqEfficiency TRUE. processors number processors use, NULL automatically detect use available processors.","code":""},{"path":"/reference/CalculateEfficiencyPCR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict Amplification Efficiency of Primer Sequences — CalculateEfficiencyPCR","text":"vector predicted efficiencies amplifying primer/target pair sequences.","code":""},{"path":"/reference/CalculateEfficiencyPCR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict Amplification Efficiency of Primer Sequences — CalculateEfficiencyPCR","text":"Amplification pairwise primer/target pairs simulated silico.  complex model hybridization employed takes account side reactions resulting probe-folding, target-folding, primer-dimer formation.  resulting hybridization efficiency multiplied elongation efficiency predict overall efficiency amplification. Free energy obtained system calls OligoArrayAux, must properly installed (see Notes section ).  Primer/target pairs sent OligoArrayAux batches batchSize, prevents systems calls many characters.  Note OligoArrayAux support degeneracy codes (non-base letters), although accepted without error.  sequences ambiguity expanded multiple permutations Disambiguate input.","code":""},{"path":"/reference/CalculateEfficiencyPCR.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Predict Amplification Efficiency of Primer Sequences — CalculateEfficiencyPCR","text":"program OligoArrayAux (http://www.unafold.org/Dinamelt/software/oligoarrayaux.php) must installed location accessible system.  example, following code print installed OligoArrayAux version executed R console: system(\"hybrid-min -V\")","code":""},{"path":"/reference/CalculateEfficiencyPCR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Predict Amplification Efficiency of Primer Sequences — CalculateEfficiencyPCR","text":"ES Wright et al. (2013) \"Exploiting Extension Bias PCR Improve Primer Specificity Ensembles Nearly Identical DNA Templates.\" Environmental Microbiology, doi:10.1111/1462-2920.12259.","code":""},{"path":[]},{"path":"/reference/CalculateEfficiencyPCR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Predict Amplification Efficiency of Primer Sequences — CalculateEfficiencyPCR","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/CalculateEfficiencyPCR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict Amplification Efficiency of Primer Sequences — CalculateEfficiencyPCR","text":"","code":"primers <- c(\"AAAAACGGGGAGCGGGGGG\", \"AAAAACTCAACCCGAGGAGCGCGT\") targets <- reverseComplement(DNAStringSet(primers)) # not run (must have OligoArrayAux installed first): if (FALSE) CalculateEfficiencyPCR(primers, targets, temp=75, P=4e-7, ions=0.225)"},{"path":"/reference/Clusterize.html","id":null,"dir":"Reference","previous_headings":"","what":"Cluster Sequences By Distance — Clusterize","title":"Cluster Sequences By Distance — Clusterize","text":"Groups sequences approximate clusters similarity.","code":""},{"path":"/reference/Clusterize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cluster Sequences By Distance — Clusterize","text":"","code":"Clusterize(   myXStringSet,   cutoff = 0,   method = \"overlap\",   includeTerminalGaps = FALSE,   penalizeGapLetterMatches = NA,   minCoverage = 0.5,   maxPhase1 = 400,   maxPhase2 = 400,   maxPhase3 = 400,   maxAlignments = 100,   rareKmers = 50,   probability = 0.999,   invertCenters = FALSE,   singleLinkage = FALSE,   alphabet = AA_REDUCED[[152]],   processors = 1,   verbose = TRUE )"},{"path":"/reference/Clusterize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cluster Sequences By Distance — Clusterize","text":"myXStringSet (unaligned) DNAStringSet, RNAStringSet, AAStringSet cluster. cutoff vector maximum distances (approximately) separating sequences cluster (.e., 1 - similarities).  Multiple cutoffs may provided ascending descending order.  (See details section .) method Character string determining region distance calculated.  (unambiguous abbreviation ) one \"overlap\", \"shortest\", \"longest\".  default method (\"overlap\") calculates distance overlapping region terminal gaps includeTerminalGaps FALSE entire alignment otherwise.  Setting method \"shortest\" \"longest\" use region start end shortest longest sequence, respectively, pairwise distance.  method applicable includeTerminalGaps TRUE. includeTerminalGaps Logical specifying whether include terminal gaps (\"-\" characters) pairwise alignments calculation distance. penalizeGapLetterMatches Logical specifying whether consider gap--letter matches mismatches.  FALSE, gap--letter matches included total length used calculate distance, TRUE gaps--letter pairs considered mismatches.  default (NA) penalize gap--letter mismatches per insertion deletion, treats runs gaps (.e., indels) equivalent single mismatch. minCoverage Numeric zero one giving minimum fraction sequence positions (gap mask) shortest sequence must overlapping longer sequence sequences clustered. maxPhase1 integer specifying maximum number passes sequences perform initial partitioning sequences. maxPhase2 integer giving maximum number replicates perform ordering sequences based k-mer similarity. maxPhase3 integer determining number comparisons per sequence perform attempting find cluster centers. maxAlignments integer designating maximum number alignments perform attempting assign sequence existing cluster. rareKmers integer setting number rare k-mers record per sequence. Larger values require memory may improve accuracy diminishing returns. probability Numeric 0 1 (exclusive) defining approximate probability clustering sequences exactly cutoff distant. Typically near, always less , 1. Lower values result faster clustering expense effectiveness. invertCenters Logical controlling whether cluster center inverted (.e., multiplied -1), allows centers determined results.  default (FALSE) returns positive cluster numbers.  TRUE, center sequence(s) cluster negative. singleLinkage Logical specifying whether perform single-linkage clustering. default (FALSE) establishes linkage cluster center. Single-linkage clustering creates broader clusters may better correspond natural groups depending application. alphabet Character vector amino acid groupings used reduce 20 standard amino acids smaller groups.  Alphabet reduction helps find distant homologies sequences phase 1. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display progress.","code":""},{"path":"/reference/Clusterize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cluster Sequences By Distance — Clusterize","text":"data.frame returned dimensions \\(N*M\\), one \\(N\\) sequences assigned cluster \\(M\\)-level cutoff.  row.names data.frame correspond names myXStingSet.","code":""},{"path":"/reference/Clusterize.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cluster Sequences By Distance — Clusterize","text":"Clusterize groups input sequences approximate clusters using heuristic algorithm linear time memory complexity.  phase 1, sequences partitioned groups similarity.  phase 2, sequences ordered k-mer similarity relatedness sorting.  phase 3, sequences iteratively clustered order similarity surrounding sequences.  , first sequence becomes representative cluster #1.  second sequence within cutoff distance added cluster, otherwise becomes new cluster representative.  remaining sequences matched cluster representatives similar fashion sequences belong cluster.  majority cases, process results clusters members separated less cutoff distance, cluster members must within cutoff distance cluster representative. calculation distance can controlled multiple ways, parameterization distance advantages disadvantages.  default, distance fraction positions different, including gaps, within overlapping region pairwise alignment.  defaults handle partial-length sequences well, also cluster sequences high similarity opposite ends.  reason, important set minimumCoverage (default 0.5) distances based considerable overlap sequences pairwise alignment.  distance parameterization works well, reasonable alternatives. penalizeGapLetterMatches FALSE, distance exclude gap regions.  includeTerminalGaps TRUE, calculation distance use entire (global) alignment.  method \"shortest\" includeTerminalGaps set TRUE, distance calculated region encompassed shorter sequence pair, common definition distance used clustering programs.  common definition distance sometimes separate partly overlapping sequences, default. algorithm requires time proportional number input sequences myXStringSet.  phase 1, maxPhase1 passes sequences needed.  phase 2, sequences compared maxPhase2 passes take linear time.  Ordering sequences performed linear time using radix sorting.  phase 3, sequence compared maxPhase3 previous cluster representatives sequences sharing rareKmers nearby sequences relatedness ordering.  possible sequences sorted relatedness, recent cluster representatives similar.  Hence, complete algorithm scales linear time asymptotically returns clusters sequences within cutoff distance center sequence. Multiple cutoffs can provided sorted order, saves time phases 1 2 need performed .  cutoffs provided descending order clustering new value cutoff continued within prior cutoff's clusters.  way clusters lower values cutoff completely contained within ``umbrella'' clusters higher values cutoff.  slightly accelerates clustering process, subsequent group clustered within previous group.  multiple cutoffs provided ascending order clustering level cutoff independent prior level. Note, three phases algorithm stochastic.  Hence, clusters can vary run--run unless random number seed set repeatability (.e., set.seed).  Also, invertCenters can used determine center sequence cluster output.  Since identical sequences always assigned cluster numbers, possible one input sequence myXStringSet assigned center cluster identical.","code":""},{"path":[]},{"path":"/reference/Clusterize.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cluster Sequences By Distance — Clusterize","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/Clusterize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cluster Sequences By Distance — Clusterize","text":"","code":"fas <- system.file(\"extdata\", \"50S_ribosomal_protein_L2.fas\", package=\"DECIPHER\") dna <- readDNAStringSet(fas) aa <- translate(dna)  # typical usage (e.g., clustering at >= 90 percent similarity) clusters <- Clusterize(aa, cutoff=0.1) # set processors = NULL for max speed #> Partitioning sequences by 6-mer similarity: #>  iteration 8 of up to 400 (100.0% coverage) #>  #> Time difference of 0.01 secs #>  #> Sorting by relatedness within 1 group: #>  iteration 51 of up to 51 (100.0% stability)  #>  #> Time difference of 0.48 secs #>  #> Clustering sequences by 4-mer similarity: #> ================================================================================ #>  #> Clusters via relatedness sorting: 100% (0% exclusively) #> Clusters via rare 4-mers: 100% (0% exclusively) #> Estimated clustering effectiveness: 100% #> Time difference of 0.04 secs #>  head(clusters) #>                                     cluster #> Rickettsia prowazekii str. Dachau        77 #> Porphyromonas gingivalis W83             69 #> Porphyromonas gingivalis TDC60           69 #> Porphyromonas gingivalis ATCC 33277      69 #> Pasteurella multocida 671/90             76 #> Pasteurella multocida 36950              76  # typical usage (e.g., obtaining cluster representatives) clusters <- Clusterize(aa, cutoff=0.1, invertCenters=TRUE) #> Partitioning sequences by 6-mer similarity: #>  iteration 8 of up to 400 (100.0% coverage) #>  #> Time difference of 0.01 secs #>  #> Sorting by relatedness within 1 group: #>  iteration 51 of up to 51 (100.0% stability)  #>  #> Time difference of 0.47 secs #>  #> Clustering sequences by 4-mer similarity: #> ================================================================================ #>  #> Clusters via relatedness sorting: 100% (0% exclusively) #> Clusters via rare 4-mers: 100% (0% exclusively) #> Estimated clustering effectiveness: 100% #> Time difference of 0.04 secs #>  aa[clusters[[1]] < 0] #> AAStringSet object of length 268: #>       width seq                                             names                #>   [1]   274 MGIRKLKPTTPGQRHKVIGAFD...KGLKTRAPKKHSSKYIIERRKK Porphyromonas gin... #>   [2]   274 MGIRKLKPTTPGQRHKVIGAFD...KGLKTRAPKKHSSKYIIERRKK Porphyromonas gin... #>   [3]   274 MGIRKLKPTTPGQRHKVIGAFD...KGLKTRAPKKHSSKYIIERRKK Porphyromonas gin... #>   [4]   279 VGIKKYKPTTNGRRNMTASDFS...KTRNKKARSNKLIVRGRRPGKH Lactobacillus pla... #>   [5]   279 VGIKKYKPTTNGRRNMTASDFS...KTRNKKARSNKLIVRGRRPGKH Lactobacillus pla... #>   ...   ... ... #> [264]   281 MFKKYRPVTPGTRQLALPTNEQ...KGLVTRSNKKSNKLIVKRRRKK Candidatus Protoc... #> [265]   274 MPIQKCKPTSPGRRFVEKVVHS...KGYKTRTNKRTTKMIIRDRRVK Acinetobacter sp.... #> [266]   288 MGIRVYRPYTPGVRQKTVSDFA...SDALIVRRRKKSSKRGRGGRQS Thermosynechococc... #> [267]   277 MALKTFNPTTPGQRQLVMVDRS...KKTRSNKSTNKFILLSRHKRKK Bradyrhizobium ja... #> [268]   280 MGIRKYRPMTPGTRQRSGADFA...RKRRKPSSKFIIRRRKTASGRG Gloeobacter viola...  # cluster each cutoff within the previous cluster (slightly faster) clusters <- Clusterize(aa, cutoff=seq(0.7, 0, -0.1)) #> Partitioning sequences by 6-mer similarity: #>  iteration 8 of up to 400 (100.0% coverage) #>  #> Time difference of 0.01 secs #>  #> Sorting by relatedness within 1 group: #>  iteration 51 of up to 51 (100.0% stability)  #>  #> Time difference of 0.63 secs #>  #> Clustering sequences by 4-mer similarity: #> ================================================================================ #>  #> Clusters via relatedness sorting: 100% (0% exclusively) #> Clusters via rare 4-mers: 100% (0% exclusively) #> Estimated clustering effectiveness: 100% #> Time difference of 0.08 secs #>  head(clusters) #>                                     cluster_0_7 cluster_0_6 cluster_0_5 #> Rickettsia prowazekii str. Dachau             1           1           1 #> Porphyromonas gingivalis W83                  1           1           1 #> Porphyromonas gingivalis TDC60                1           1           1 #> Porphyromonas gingivalis ATCC 33277           1           1           1 #> Pasteurella multocida 671/90                  1           1           1 #> Pasteurella multocida 36950                   1           1           1 #>                                     cluster_0_4 cluster_0_3 cluster_0_2 #> Rickettsia prowazekii str. Dachau            19           3          64 #> Porphyromonas gingivalis W83                 12          20          35 #> Porphyromonas gingivalis TDC60               12          20          35 #> Porphyromonas gingivalis ATCC 33277          12          20          35 #> Pasteurella multocida 671/90                 15           8          56 #> Pasteurella multocida 36950                  15           8          56 #>                                     cluster_0_1 cluster_0 #> Rickettsia prowazekii str. Dachau             3       100 #> Porphyromonas gingivalis W83                 48        44 #> Porphyromonas gingivalis TDC60               48        44 #> Porphyromonas gingivalis ATCC 33277          48        44 #> Pasteurella multocida 671/90                 15        84 #> Pasteurella multocida 36950                  15        84 apply(clusters, 2, max) # number of clusters per cutoff #> cluster_0_7 cluster_0_6 cluster_0_5 cluster_0_4 cluster_0_3 cluster_0_2  #>           1           1           4          20          44          66  #> cluster_0_1   cluster_0  #>          88         102   # cluster each cutoff independently (possibly fewer clusters per cutoff) clusters <- Clusterize(aa, cutoff=seq(0, 0.7, 0.1)) #> Partitioning sequences by 6-mer similarity: #>  iteration 8 of up to 400 (100.0% coverage) #>  #> Time difference of 0.01 secs #>  #> Sorting by relatedness within 1 group: #>  iteration 51 of up to 51 (100.0% stability)  #>  #> Time difference of 0.64 secs #>  #> Clustering sequences by 4-mer similarity: #> ================================================================================ #>  #> Clusters via relatedness sorting: 100% (0% exclusively) #> Clusters via rare 4-mers: 100% (0% exclusively) #> Estimated clustering effectiveness: 100% #> Time difference of 0.23 secs #>  head(clusters) #>                                     cluster_0 cluster_0_1 cluster_0_2 #> Rickettsia prowazekii str. Dachau          99          78          58 #> Porphyromonas gingivalis W83               82          70          53 #> Porphyromonas gingivalis TDC60             82          70          53 #> Porphyromonas gingivalis ATCC 33277        82          70          53 #> Pasteurella multocida 671/90               94          77          52 #> Pasteurella multocida 36950                94          77          52 #>                                     cluster_0_3 cluster_0_4 cluster_0_5 #> Rickettsia prowazekii str. Dachau            34          15           4 #> Porphyromonas gingivalis W83                 31           7           4 #> Porphyromonas gingivalis TDC60               31           7           4 #> Porphyromonas gingivalis ATCC 33277          31           7           4 #> Pasteurella multocida 671/90                 25          10           4 #> Pasteurella multocida 36950                  25          10           4 #>                                     cluster_0_6 cluster_0_7 #> Rickettsia prowazekii str. Dachau             1           1 #> Porphyromonas gingivalis W83                  1           1 #> Porphyromonas gingivalis TDC60                1           1 #> Porphyromonas gingivalis ATCC 33277           1           1 #> Pasteurella multocida 671/90                  1           1 #> Pasteurella multocida 36950                   1           1 apply(clusters, 2, max) # number of clusters per cutoff #>   cluster_0 cluster_0_1 cluster_0_2 cluster_0_3 cluster_0_4 cluster_0_5  #>         102          84          61          35          16           4  #> cluster_0_6 cluster_0_7  #>           1           1   # make cluster center(s) negative for tracking clusters <- Clusterize(aa, cutoff=0.5, invertCenters=TRUE) #> Partitioning sequences by 6-mer similarity: #>  iteration 8 of up to 400 (100.0% coverage) #>  #> Time difference of 0.01 secs #>  #> Sorting by relatedness within 1 group: #>  iteration 20 of up to 51 (100.0% stability)  #>  #> Time difference of 0.25 secs #>  #> Clustering sequences by 4-mer similarity: #> ================================================================================ #>  #> Clusters via relatedness sorting: 100% (0% exclusively) #> Clusters via rare 4-mers: 100% (0% exclusively) #> Estimated clustering effectiveness: 100% #> Time difference of 0.03 secs #>  head(clusters) #>                                     cluster #> Rickettsia prowazekii str. Dachau         4 #> Porphyromonas gingivalis W83              4 #> Porphyromonas gingivalis TDC60            4 #> Porphyromonas gingivalis ATCC 33277       4 #> Pasteurella multocida 671/90              4 #> Pasteurella multocida 36950               4 clusters[clusters$cluster < 0,, drop=FALSE] #>                                                      cluster #> Mycoplasma pneumoniae M129-B7                             -3 #> Aquifex aeolicus VF5                                      -1 #> Sinorhizobium meliloti AK83                               -4 #> Sinorhizobium meliloti BL225C                             -4 #> Sinorhizobium meliloti GR4                                -4 #> Sinorhizobium meliloti 2011                               -4 #> Sinorhizobium medicae WSM419                              -4 #> Sinorhizobium meliloti SM11                               -4 #> Prochlorococcus marinus subsp. marinus str. CCMP1375      -2 unique(aa[clusters$cluster < 0]) # unique cluster centers #> AAStringSet object of length 4: #>     width seq                                               names                #> [1]   287 MPIKKIISRSNSGIHHSTVIDYK...VKTRNMKKASTNLIIRNRKGEQY Mycoplasma pneumo... #> [2]   304 MGVRKLKPVTNGTRHAVLYDFEE...YKTRRGKKYSDQFIVTRRDGRPL Aquifex aeolicus VF5 #> [3]   278 MALKSFNPTTPSQRQLVIVSRAG...GKRTRSNKSTDKFIMRSRHQRKK Sinorhizobium mel... #> [4]   287 MAIRTFRPYTPGTRTRVVTDFNE...PSNRFVLRKRRRVSKRSRGGRDS Prochlorococcus m... apply(clusters, 2, function(x) max(abs(x))) # number of clusters #> cluster  #>       4   # cluster nucleotide sequences clusters <- Clusterize(dna, cutoff=0.5, invertCenters=TRUE) #> Partitioning sequences by 9-mer similarity: #>  iteration 96 of up to 400 (100.0% coverage) #>  #> Time difference of 0.1 secs #>  #> Sorting by relatedness within 89 groups: #>  iteration 37 of up to 37 (100.0% stability)  #>  #> Time difference of 0.23 secs #>  #> Clustering sequences by 9-mer similarity: #> ================================================================================ #>  #> Clusters via relatedness sorting: 100% (0% exclusively) #> Clusters via rare 6-mers: 100% (0% exclusively) #> Estimated clustering effectiveness: 100% #> Time difference of 0.42 secs #>  head(clusters) #>                                     cluster #> Rickettsia prowazekii str. Dachau        -1 #> Porphyromonas gingivalis W83             -2 #> Porphyromonas gingivalis TDC60            2 #> Porphyromonas gingivalis ATCC 33277       2 #> Pasteurella multocida 671/90              2 #> Pasteurella multocida 36950               2 apply(clusters, 2, function(x) max(abs(x))) # number of clusters #> cluster  #>       4"},{"path":"/reference/Codec.html","id":null,"dir":"Reference","previous_headings":"","what":"Compression/Decompression of Character Vectors — Codec","title":"Compression/Decompression of Character Vectors — Codec","text":"Compresses character vectors raw vectors, decompresses raw vectors character vectors using variety codecs.","code":""},{"path":"/reference/Codec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compression/Decompression of Character Vectors — Codec","text":"","code":"Codec(   x,   compression = c(\"nbit\", \"gzip\"),   compressRepeats = FALSE,   processors = 1 )"},{"path":"/reference/Codec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compression/Decompression of Character Vectors — Codec","text":"x Either character vector compressed, list raw vectors decompressed. compression type compression algorithm use x character vector.  (unambiguous abbreviation ) one \"nbit\" (nucleotides), \"qbit\" (quality scores), \"gzip\", \"bzip2\", \"xz\".  compression \"nbit\" \"qbit\" second method can provided cases x incompressible.  Decompression type determined automatically.  (See details section .) compressRepeats Logical specifying whether compress exact repeats reverse complement repeats character vector input (x). applicable compression \"nbit\".  Repeat compression long DNA sequences generally increases compression 2\\ requiring three-fold compression time. processors number processors use, NULL automatically detect use available processors.","code":""},{"path":"/reference/Codec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compression/Decompression of Character Vectors — Codec","text":"x character vector compressed, output list one element containing raw vector per character string.  x list raw vectors decompressed, output character vector one string per list element.","code":""},{"path":"/reference/Codec.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compression/Decompression of Character Vectors — Codec","text":"Codec can used compress/decompress character vectors using different algorithms.  \"nbit\" \"qbit\" methods tailored specifically nucleotides quality scores, respectively. two methods store data plain text (\"ASCII\" format) incompressible.  cases, second compression method can given use lieu plain text.  example compression = c(\"nbit\", \"gzip\") use \"gzip\" compression \"nbit\" compression inappropriate. performing reverse operation, decompression, type compression automatically detected based unique signature (\"magic number\") added compression algorithm.","code":""},{"path":"/reference/Codec.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compression/Decompression of Character Vectors — Codec","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/Codec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compression/Decompression of Character Vectors — Codec","text":"","code":"fas <- system.file(\"extdata\", \"Bacteria_175seqs.fas\", package=\"DECIPHER\") dna <- as.character(readDNAStringSet(fas)) # aligned sequences object.size(dna) #> 308304 bytes  # compression system.time(x <- Codec(dna, compression=\"nbit\")) #>    user  system elapsed  #>   0.004   0.000   0.005  object.size(x)/sum(nchar(dna)) # bytes per position #> 0.4 bytes  system.time(g <- Codec(dna, compression=\"gzip\")) #>    user  system elapsed  #>   0.007   0.000   0.007  object.size(g)/sum(nchar(dna)) # bytes per position #> 0.4 bytes  # decompression system.time(y <- Codec(x)) #>    user  system elapsed  #>   0.002   0.000   0.002  stopifnot(dna==y)  system.time(z <- Codec(g)) #>    user  system elapsed  #>   0.003   0.000   0.003  stopifnot(dna==z)"},{"path":"/reference/ConsensusSequence.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Consensus Sequence — ConsensusSequence","title":"Create a Consensus Sequence — ConsensusSequence","text":"Forms consensus sequence representing set sequences.","code":""},{"path":"/reference/ConsensusSequence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Consensus Sequence — ConsensusSequence","text":"","code":"ConsensusSequence(   myXStringSet,   threshold = 0.05,   ambiguity = TRUE,   noConsensusChar = \"+\",   minInformation = 1 - threshold,   ignoreNonBases = FALSE,   includeTerminalGaps = FALSE )"},{"path":"/reference/ConsensusSequence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Consensus Sequence — ConsensusSequence","text":"myXStringSet AAStringSet, DNAStringSet, RNAStringSet object aligned sequences. threshold Numeric specifying less threshold fraction sequence information can lost position consensus sequence. ambiguity Logical specifying whether consider ambiguity split respective nucleotides.  Degeneracy codes specified IUPAC_CODE_MAP. noConsensusChar Single character sequence's alphabet giving base use consensus position. minInformation Minimum fraction information required form consensus position. ignoreNonBases Logical specifying whether count gap (\"-\"), mask (\"+\"), unknown (\".\") characters towards consensus. includeTerminalGaps Logical specifying whether include terminal gaps (\"-\" \".\" characters end sequence) formation consensus.","code":""},{"path":"/reference/ConsensusSequence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Consensus Sequence — ConsensusSequence","text":"XStringSet single consensus sequence matching input type.","code":""},{"path":"/reference/ConsensusSequence.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Consensus Sequence — ConsensusSequence","text":"ConsensusSequence removes least frequent characters position, long represent less threshold fraction sequences total.  necessary, ConsensusSequence represents remaining characters using degeneracy code IUPAC_CODE_MAP.  Degeneracy codes always used cases multiple characters equally abundant. Two key parameters control degree consensus: threshold minInformation.  default threshold (0.05) means less 5\\ sequence given position.  default minInformation (1 - 0.05) specifies least 95\\ information consensus, otherwise noConsensusChar used. enables alternative character (e.g., \"+\") substituted positions otherwise yield ambiguity code. ambiguity = TRUE (default) degeneracy codes myXStringSet split respective bases according IUPAC_CODE_MAP DNA/RNA AMINO_ACID_CODE AA. example, R'' \\code{DNAStringSet} count half '' half G''.  \\code{ambiguity = FALSE} degeneracy codes considered forming consensus.  \\code{AAStringSet} input, lack degeneracy codes generally results X'' positions mismatches, unless threshold set higher value default. includeNonBases = TRUE (default) gap (\"-\"), mask (\"+\"), unknown (\".\") characters counted towards consensus, otherwise omitted calculation consensus.  Note gap (\"-\") unknown (\".\") characters treated interchangeably gaps forming consensus sequence.  reason, consensus position unknown (\".\") characters gap (\"-\").  Also, note consensus formed different length sequences represent longest sequences end.  reason consensus sequence generally based sequence alignment sequences equal lengths.","code":""},{"path":[]},{"path":"/reference/ConsensusSequence.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a Consensus Sequence — ConsensusSequence","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/ConsensusSequence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Consensus Sequence — ConsensusSequence","text":"","code":"db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") dna <- SearchDB(db, limit=10) #> Search Expression: #> select row_names, sequence from _Seqs where row_names in (select row_names #> from Seqs) limit 10 #>  #> DNAStringSet of length: 10 #> Time difference of 0 secs #>  BrowseSeqs(dna) # consensus at bottom BrowseSeqs(dna, threshold=0.5) # consensus at bottom  # controlling the degree of consensus AAAT <- DNAStringSet(c(\"A\", \"A\", \"A\", \"T\")) ConsensusSequence(AAAT) # \"W\" #> DNAStringSet object of length 1: #>     width seq #> [1]     1 W ConsensusSequence(AAAT, threshold=0.3) # \"A\" #> DNAStringSet object of length 1: #>     width seq #> [1]     1 A ConsensusSequence(AAAT, threshold=0.3, minInformation=0.8) # \"+\" #> DNAStringSet object of length 1: #>     width seq #> [1]     1 + ConsensusSequence(AAAT, threshold=0.3, minInformation=0.8, noConsensusChar=\"N\") # \"N\" #> DNAStringSet object of length 1: #>     width seq #> [1]     1 N  # switch between degenerate-based and majority-based consensus majority <- DNAStringSet(c(\"GTT\", \"GAA\", \"CTG\")) ConsensusSequence(majority) # degenerate-based #> DNAStringSet object of length 1: #>     width seq #> [1]     3 SWD ConsensusSequence(majority, threshold=0.5) # majority-based #> DNAStringSet object of length 1: #>     width seq #> [1]     3 GTD ConsensusSequence(majority, threshold=0.5, minInformation=0.75) #> DNAStringSet object of length 1: #>     width seq #> [1]     3 ++D  # behavior in the case of a tie ConsensusSequence(DNAStringSet(c(\"A\", \"T\"))) # \"W\" #> DNAStringSet object of length 1: #>     width seq #> [1]     1 W ConsensusSequence(DNAStringSet(c(\"A\", \"T\")), threshold=0.5) # \"W\" #> DNAStringSet object of length 1: #>     width seq #> [1]     1 W ConsensusSequence(AAStringSet(c(\"A\", \"T\"))) # \"X\" #> AAStringSet object of length 1: #>     width seq #> [1]     1 X ConsensusSequence(AAStringSet(c(\"A\", \"T\")), threshold=0.5) # \"X\" #> AAStringSet object of length 1: #>     width seq #> [1]     1 X ConsensusSequence(AAStringSet(c(\"I\", \"L\"))) # \"J\" #> AAStringSet object of length 1: #>     width seq #> [1]     1 J ConsensusSequence(AAStringSet(c(\"I\", \"L\")), threshold=0.5) # \"J\" #> AAStringSet object of length 1: #>     width seq #> [1]     1 J  # handling terminal gaps dna <- DNAStringSet(c(\"ANGCT-\",\"-ACCT-\")) ConsensusSequence(dna) # \"ANSCT-\" #> DNAStringSet object of length 1: #>     width seq #> [1]     6 ANSCT- ConsensusSequence(dna, includeTerminalGaps=TRUE) # \"+NSCT-\" #> DNAStringSet object of length 1: #>     width seq #> [1]     6 +NSCT-  # the \".\" character is treated is a \"-\" aa <- AAStringSet(c(\"ANQIH-\", \"ADELW.\")) ConsensusSequence(aa) # \"ABZJX-\" #> AAStringSet object of length 1: #>     width seq #> [1]     6 ABZJX-  # internal non-bases are included by default ConsensusSequence(DNAStringSet(c(\"A-+.A\", \"AAAAA\")), noConsensusChar=\"N\") # \"ANNNA\" #> DNAStringSet object of length 1: #>     width seq #> [1]     5 ANNNA ConsensusSequence(DNAStringSet(c(\"A-+.A\", \"AAAAA\")), ignoreNonBases=TRUE) # \"AAAAA\" #> DNAStringSet object of length 1: #>     width seq #> [1]     5 AAAAA  # degeneracy codes in the input are considered by default ConsensusSequence(DNAStringSet(c(\"AWNDA\", \"AAAAA\"))) # \"AWNDA\" #> DNAStringSet object of length 1: #>     width seq #> [1]     5 AWNDA ConsensusSequence(DNAStringSet(c(\"AWNDA\", \"AAAAA\")), ambiguity=FALSE) # \"AAAAA\" #> DNAStringSet object of length 1: #>     width seq #> [1]     5 AAAAA"},{"path":"/reference/Cophenetic.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute cophenetic distances on dendrogram objects — Cophenetic","title":"Compute cophenetic distances on dendrogram objects — Cophenetic","text":"Calculates matrix cophenetic distances represented dendrogram object.","code":""},{"path":"/reference/Cophenetic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute cophenetic distances on dendrogram objects — Cophenetic","text":"","code":"Cophenetic(x)"},{"path":"/reference/Cophenetic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute cophenetic distances on dendrogram objects — Cophenetic","text":"x dendrogram object.","code":""},{"path":"/reference/Cophenetic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute cophenetic distances on dendrogram objects — Cophenetic","text":"object class 'dist'.","code":""},{"path":"/reference/Cophenetic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute cophenetic distances on dendrogram objects — Cophenetic","text":"cophenetic distance two observations defined branch length separating dendrogram.  function differs cophenetic function assume tree ultrametric outputs branch length separating pairs observations rather height merger. dendrogram better preserves distance matrix show higher correlation distance matrix cophenetic distances.","code":""},{"path":[]},{"path":"/reference/Cophenetic.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute cophenetic distances on dendrogram objects — Cophenetic","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/Cophenetic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute cophenetic distances on dendrogram objects — Cophenetic","text":"","code":"fas <- system.file(\"extdata\", \"Bacteria_175seqs.fas\", package=\"DECIPHER\") dna <- readDNAStringSet(fas) d1 <- DistanceMatrix(dna, type=\"dist\") #> ================================================================================ #>  #> Time difference of 0.06 secs #>  dend <- TreeLine(myDistMatrix=d1, method=\"NJ\") #> ================================================================================ #>  #> Time difference of 0.01 secs #>  d2 <- Cophenetic(dend) cor(d1, d2) #> [1] 0.9864114"},{"path":"/reference/CorrectFrameshifts.html","id":null,"dir":"Reference","previous_headings":"","what":"Corrects Frameshift Errors In Protein Coding Sequences — CorrectFrameshifts","title":"Corrects Frameshift Errors In Protein Coding Sequences — CorrectFrameshifts","text":"Corrects reading frame mitigate impact frameshift errors caused insertions deletions unaligned nucleotide sequences.","code":""},{"path":"/reference/CorrectFrameshifts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Corrects Frameshift Errors In Protein Coding Sequences — CorrectFrameshifts","text":"","code":"CorrectFrameshifts(   myXStringSet,   myAAStringSet,   type = \"indels\",   acceptDistance = 0.01,   rejectDistance = 0.6,   maxComparisons = 10,   gapOpening = -13,   gapExtension = -1,   frameShift = -15,   geneticCode = GENETIC_CODE,   substitutionMatrix = \"PFASUM50\",   verbose = TRUE,   processors = 1 )"},{"path":"/reference/CorrectFrameshifts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Corrects Frameshift Errors In Protein Coding Sequences — CorrectFrameshifts","text":"myXStringSet DNAStringSet RNAStringSet unaligned protein coding sequences 5' 3' orientation. myAAStringSet AAStringSet reference protein sequences. Ideally consist small set diverse amino acid sequences belonging group protein coding sequences myXStringSet. type Character string indicating type result desired.  (abbreviation ) one \"indels\", \"sequences\", \"\".  (See details section .) acceptDistance Numeric giving maximum distance reference sequence acceptable skip remaining comparisons. rejectDistance Numeric giving maximum distance reference sequence allowed correcting frameshifts.  Sequences myXStringSet greater rejectDistance nearest reference sequence length trimmed 3'-end multiple three nucleotides without frameshift correction. maxComparisons number reference comparisons make stopping search closer reference sequence. gapOpening Numeric giving cost opening gap query reference sequences. gapExtension Numeric giving cost extending open gap query reference sequences. frameShift Numeric giving cost shifting frames query sequence. geneticCode Named character vector format GENETIC_CODE (default), represents standard genetic code. substitutionMatrix Either substitution matrix representing substitution scores matching two amino acids name amino acid substitution matrix.  latter may one following: BLOSUM45'', BLOSUM50'', BLOSUM62'', BLOSUM80'', BLOSUM100'', PAM30'', PAM40'', PAM70'', PAM120'', PAM250'', PFASUM50'' (default), MIQS''. verbose Logical indicating whether display progress. processors number processors use, NULL automatically detect use available processors.","code":""},{"path":"/reference/CorrectFrameshifts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Corrects Frameshift Errors In Protein Coding Sequences — CorrectFrameshifts","text":"type \"indels\" returned object list length myXStringSet.  element list four components: \"insertions\" Approximate positions inserted nucleotides, removed correct reading frame, excess nucleotides 3'-end make length longer multiple three. \"deletions\" Approximate positions deleted nucleotides, added back correct reading frame. \"distance\" amino acid distance nearest reference sequence, 0  \"index\" integer index reference sequence used frame correction, 0 reference sequence within rejectDistance.  Note positions insertions deletions sometimes repeated indicate position needs shifted successively correct reading frame. type \"sequences\" returned object XStringSet type input (myXStringSet). Nucleotides added deleted necessary correct frameshifts. returned sequences reading frame starting position 1, can translated directly. type \"\" returned object list two components: one \"indels\" \"sequences\".","code":""},{"path":"/reference/CorrectFrameshifts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Corrects Frameshift Errors In Protein Coding Sequences — CorrectFrameshifts","text":"Accurate translation protein coding sequences can greatly disrupted one two nucleotide phase shifts occasionally occur DNA sequencing.  frameshift errors can potentially corrected comparison unshifted protein sequences.  function uses set reference amino acid sequences (AAStringSet) find correct frameshift errors set nucleotide sequences (myXStringSet). First, three frame translation nucleotide sequences performed, nearest reference sequence selected.  optimal reading frame position determined based variation Guan & Uberbacher (1996) method.  Putative insertions /deletions (indels) returned result, typically close proximity true indel locations. comparison method others, see Wang et al. (2013). type \"sequences\" \"\", frameshifts corrected adding N's /removing nucleotides.  Note changes nucleotide sequence, new sequence often minor errors exact location indel(s) determined.  However, original frameshifts disrupted entire downstream sequence reduced local perturbations.  returned nucleotide sequences reading frame starting first position.  allows direct translation, practice works well similar reference myAAStringSet correct reading frame.  Hence important myAAStringSet contain wide variety sequences contain lot sequences. Multiple inputs control time required frameshift correction.  number sequences reference set (myAAStringSet) affect speed first search similar sequences.  Assessing frameshifts second step requires order N*M time, N M lengths query (myXStringSet) reference sequences.  Two parameters control number assessments made sequence: (1) maxComparisons determines maximum number reference sequences compare query sequence, (2) acceptDist defines maximum distance query reference acceptable continuing next query sequence.  lower value maxComparisons higher value acceptDist accelerate frameshift correction, potentially expense accuracy.","code":""},{"path":"/reference/CorrectFrameshifts.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Corrects Frameshift Errors In Protein Coding Sequences — CorrectFrameshifts","text":"Guan, X., & Uberbacher, E. C. (1996). Alignments DNA protein sequences containing frameshift errors. Computer Applications Biosciences : CABIOS, 12(1), 31-40. Wang, Q., et al. (2013). Ecological Patterns nifH Genes Four Terrestrial Climatic Zones Explored Targeted Metagenomics Using FrameBot, New Informatics Tool. mBio, 4(5), e00592-13-e00592-13.","code":""},{"path":[]},{"path":"/reference/CorrectFrameshifts.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Corrects Frameshift Errors In Protein Coding Sequences — CorrectFrameshifts","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/CorrectFrameshifts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Corrects Frameshift Errors In Protein Coding Sequences — CorrectFrameshifts","text":"","code":"fas <- system.file(\"extdata\", \"50S_ribosomal_protein_L2.fas\", package=\"DECIPHER\") dna <- readDNAStringSet(fas)  # introduce artificial indels n_ins <- 2 # insertions per sequence shifted <- replaceAt(dna,   lapply(width(dna),     sample,     n_ins),   sample(DNA_BASES,     n_ins,     replace=TRUE)) n_dels <- 1 # deletions per sequence shifted <- replaceAt(shifted,   as(lapply(width(shifted),     function(x) {       IRanges(sample(x,           n_dels),         width=1)     }), \"IRangesList\"))  # to make frameshift correction more challenging, # only supply 20 reference amino acid sequences s <- sample(length(dna), 20) x <- CorrectFrameshifts(shifted,   translate(dna[s]),   type=\"both\") #> Finding the closest reference amino acid sequences: #> ================================================================================ #>  #> Time difference of 0.36 secs #> Assessing frameshifts in nucleotide sequences: #> ================================================================================ #>  #> Time difference of 8.03 secs  # there was a wide range of distances # to the nearest reference sequence quantile(unlist(lapply(x[[1]], `[`, \"distance\"))) #>          0%         25%         50%         75%        100%  #> 0.000000000 0.007272727 0.167883212 0.260073260 0.481848185   # none of the sequences were > rejectDistance # from the nearest reference sequence length(which(unlist(lapply(x[[1]], `[`, \"index\"))==0)) #> [1] 0  # the number of indels was generally correct table(unlist(lapply(x[[1]], function(x) {   length(x$insertions)})))/length(shifted) #>  #>          0          1          2          4  #> 0.03470032 0.11671924 0.82965300 0.01892744  table(unlist(lapply(x[[1]], function(x) {   length(x$deletions)})))/length(shifted) #>  #>          0          1          2          3  #> 0.11671924 0.82965300 0.03470032 0.01892744   # align and display the translations AA <- AlignTranslation(x$sequences,   readingFrame=1,   type=\"AAStringSet\") #> Determining distance matrix based on shared 5-mers: #> ================================================================================ #>  #> Time difference of 0.75 secs #>  #> Clustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.02 secs #>  #> Aligning Sequences: #> ================================================================================ #>  #> Time difference of 1.13 secs #>  #> Iteration 1 of 2: #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.07 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.03 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 0.9 secs #>  #> Iteration 2 of 2: #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.07 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.03 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 0.04 secs #>  BrowseSeqs(AA)"},{"path":"/reference/CreateChimeras.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Artificial Chimeras — CreateChimeras","title":"Create Artificial Chimeras — CreateChimeras","text":"Creates artificial random chimeras set sequences.","code":""},{"path":"/reference/CreateChimeras.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Artificial Chimeras — CreateChimeras","text":"","code":"CreateChimeras(   myDNAStringSet,   numChimeras = 10,   numParts = 2,   minLength = 80,   maxLength = Inf,   minChimericRegionLength = 30,   randomLengths = TRUE,   includeParents = TRUE,   processors = 1,   verbose = TRUE )"},{"path":"/reference/CreateChimeras.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Artificial Chimeras — CreateChimeras","text":"myDNAStringSet DNAStringSet object aligned sequences. numChimeras Number chimeras desired. numParts Number chimeric parts form single chimeric sequence. minLength Minimum length complete chimeric sequence. maxLength Maximum length complete chimeric sequence. minChimericRegionLength Minimum length chimeric region sequence part. randomLengths Logical specifying whether create random length chimeras addition random breakpoints. includeParents Whether include parents chimera output. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display progress.","code":""},{"path":"/reference/CreateChimeras.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Artificial Chimeras — CreateChimeras","text":"DNAStringSet object containing chimeras.  names chimeras specified \"parent #1 name chimeric region (distance parent chimera), ...\". includeParents = TRUE parents chimeras included end result.  parents trimmed length chimera randomLengths = TRUE.  names parents specified \"parent #1 name region (distance parent #2, ...)\".","code":""},{"path":"/reference/CreateChimeras.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Artificial Chimeras — CreateChimeras","text":"Forms set random chimeras input set (typically good quality) sequences.  chimeras created merging random sequences random breakpoints.  chimeras can used testing accuracy FindChimeras chimera finding functions.","code":""},{"path":[]},{"path":"/reference/CreateChimeras.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create Artificial Chimeras — CreateChimeras","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/CreateChimeras.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Artificial Chimeras — CreateChimeras","text":"","code":"db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") dna <- SearchDB(db) #> Search Expression: #> select row_names, sequence from _Seqs where row_names in (select row_names #> from Seqs) #>  #> DNAStringSet of length: 175 #> Time difference of 0.01 secs #>  chims <- CreateChimeras(dna) #> ================================================================================ #>  #> Created 10 chimeras. #> Time difference of 0.22 secs #>  BrowseSeqs(chims)"},{"path":"/reference/DB2Seqs.html","id":null,"dir":"Reference","previous_headings":"","what":"Export Database Sequences to a FASTA or FASTQ File — DB2Seqs","title":"Export Database Sequences to a FASTA or FASTQ File — DB2Seqs","text":"Exports database containing sequences FASTA FASTQ formatted file sequence records.","code":""},{"path":"/reference/DB2Seqs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Export Database Sequences to a FASTA or FASTQ File — DB2Seqs","text":"","code":"DB2Seqs(   file,   dbFile,   tblName = \"Seqs\",   identifier = \"\",   type = \"BStringSet\",   limit = -1,   replaceChar = NA,   nameBy = \"description\",   orderBy = \"row_names\",   removeGaps = \"none\",   append = FALSE,   width = 80,   compress = FALSE,   chunkSize = 1e+05,   sep = \"::\",   clause = \"\",   processors = 1,   verbose = TRUE )"},{"path":"/reference/DB2Seqs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Export Database Sequences to a FASTA or FASTQ File — DB2Seqs","text":"file Character string giving location file written. dbFile SQLite connection object character string specifying path database file. tblName Character string specifying table extract data. identifier Optional character string used narrow search results matching specific identifier.  \"\" identifiers selected. type type XStringSet (sequences) export FASTA formatted file QualityScaledXStringSet export FASTQ formatted file.  (unambiguous abbreviation ) one \"DNAStringSet\", \"RNAStringSet\", \"AAStringSet\", \"BStringSet\", \"QualityScaledDNAStringSet\", \"QualityScaledRNAStringSet\", \"QualityScaledAAStringSet\", \"QualityScaledBStringSet\".  (See details section .) limit Number results display.  default (-1) limit number results. replaceChar Optional character used replace characters sequence present XStringSet's alphabet.  applicable type==\"BStringSet\".  default (NA) results error incompatible character exist.  (See details section .) nameBy Character string giving column name(s) identifying sequence record.  one column name provided, information column concatenated, separated sep, order specified. orderBy Character string giving column name sorting results.  Defaults order entries database.  Optionally can followed \" ASC\" \" DESC\" specify ascending (default) descending order. removeGaps Determines gaps (\"-\" \".\" characters) removed sequences.  (unambiguous abbreviation ) one \"none\", \"\" \"common\". append Logical indicating whether append output existing file. width Integer specifying maximum number characters per line sequence.  applicable exporting FASTQ formatted file. compress Logical specifying whether compress output file using gzip compression. chunkSize Number sequences write file time. less total number sequences removeGaps \"common\". sep Character string providing separator fields sequence's name, default pairs colons (``::''). clause optional character string append query part ``clause''. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display status.","code":""},{"path":"/reference/DB2Seqs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Export Database Sequences to a FASTA or FASTQ File — DB2Seqs","text":"Writes FASTA FASTQ formatted file containing sequence records database. Returns number sequence records written file.","code":""},{"path":"/reference/DB2Seqs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Export Database Sequences to a FASTA or FASTQ File — DB2Seqs","text":"Sequences exported either FASTA FASTQ file determined type sequences.  type XStringSet sequences exported FASTA format.  Quality information QualityScaledXStringSets interpreted PredQuality scores export FASTQ format. type \"BStringSet\" (default) sequences exported FASTA file exactly imported.  type \"DNAStringSet\" U's converted T's export, vise-versa type \"RNAStringSet\".  remaining characters XStringSet's alphabet converted replaceChar removed replaceChar \"\".  Note replaceChar NA (default), result error unexpected character found.","code":""},{"path":"/reference/DB2Seqs.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Export Database Sequences to a FASTA or FASTQ File — DB2Seqs","text":"ES Wright (2016) \"Using DECIPHER v2.0 Analyze Big Biological Sequence Data R\". R Journal, 8(1), 352-359.","code":""},{"path":"/reference/DB2Seqs.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Export Database Sequences to a FASTA or FASTQ File — DB2Seqs","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/DB2Seqs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Export Database Sequences to a FASTA or FASTQ File — DB2Seqs","text":"","code":"db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") tf <- tempfile() DB2Seqs(tf, db, limit=10) #> ================================================================================ #>  #> Wrote 10 sequences. #> Time difference of 0 secs #>  file.show(tf) # press 'q' to exit unlink(tf)"},{"path":"/reference/DECIPHER-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Tools for curating, analyzing, and manipulating biological sequences — DECIPHER-package","title":"Tools for curating, analyzing, and manipulating biological sequences — DECIPHER-package","text":"DECIPHER software toolset can used deciphering managing biological sequences efficiently using R statistical programming language.  program designed used non-destructive workflows importing, maintaining, analyzing, manipulating, exporting massive amount sequences.","code":""},{"path":"/reference/DECIPHER-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tools for curating, analyzing, and manipulating biological sequences — DECIPHER-package","text":"Index:","code":"AA_REDUCED Reduced amino acid alphabets Add2DB Add Data to a Database AdjustAlignment Improve An Existing Alignment By Adjusting Gap Placements AlignDB Align Two Sets of Aligned Sequences in a Sequence Database AlignProfiles Align Two Sets of Aligned Sequences AlignSeqs Align a Set of Unaligned Sequences AlignSynteny Pairwise Aligns Syntenic Blocks AlignTranslation Align Sequences By Their Amino Acid Translation AmplifyDNA Simulate Amplification of DNA by PCR Array2Matrix Create a Matrix Representation of a Microarray BrowseDB View a Database Table in a Web Browser BrowseSeqs View Sequences in a Web Browser CalculateEfficiencyArray Predict the Hybridization Efficiency of Probe/Target Sequence Pairs CalculateEfficiencyFISH Predict Thermodynamic Parameters of Probe/Target Sequence Pairs CalculateEfficiencyPCR Predict Amplification Efficiency of Primer Sequences Clusterize Cluster Sequences By Distance Codec Compression/Decompression of Character Vectors ConsensusSequence Create a Consensus Sequence Cophenetic Compute cophenetic distances on dendrogram objects CorrectFrameshifts Corrects Frameshift Errors In Protein Coding Sequences CreateChimeras Create Artificial Chimeras DB2Seqs Export Database Sequences to a FASTA or FASTQ File deltaGrules Free Energy of Hybridization of Probe/Target Quadruplets deltaHrules Change in Enthalpy of Hybridization of DNA/DNA Quadruplets in Solution deltaHrulesRNA Change in Enthalpy of Hybridization of RNA/RNA Quadruplets in Solution deltaSrules Change in Entropy of Hybridization of DNA/DNA Quadruplets in Solution deltaSrulesRNA Change in Entropy of Hybridization of RNA/RNA Quadruplets in Solution DesignArray Design a Set of DNA Microarray Probes for Detecting Sequences DesignPrimers Design Primers Targeting a Specific Group of Sequences DesignProbes Design FISH Probes Targeting a Specific Group of Sequences DesignSignatures Design PCR Primers for Amplifying Group-Specific Signatures DetectRepeats Detect Repeats in a Sequence DigestDNA Simulate Restriction Digestion of DNA Disambiguate Expand Ambiguities into All Permutations of a DNAStringSet DistanceMatrix Calculate the Distance Between Sequences ExtractGenes Extract Predicted Genes from a Genome FindChimeras Find Chimeras in a Sequence Database FindGenes Find Genes in a Genome FindNonCoding Find Non-Coding RNAs in a Genome FindSynteny Finds Synteny in a Sequence Database FormGroups Forms Groups By Rank Genes-class Genes objects and accessors HEC_MI Mutual Information for Protein Secondary Structure Prediction IdConsensus Create Consensus Sequences by Groups IdentifyByRank Identify By Taxonomic Rank IdLengths Determine the Number of Characters in Each Sequence of Each Sequence IdTaxa Assign Sequences a Taxonomic Classification LearnNonCoding Learn a Non-Coding RNA Model LearnTaxa Train a Classifier for Assigning Taxonomy MapCharacters Map Changes in Ancestral Character States MaskAlignment Mask Highly Variable Regions of An Alignment MeltDNA Simulate Melting of DNA MIQS MIQS Amino Acid Substitution Matrix MODELS Available Models of Sequence Evolution NNLS Sequential Coordinate-wise Algorithm for the Non-negative Least Squares Problem NonCoding NonCoding Models for Common Non-Coding RNA Families NonCoding-class NonCoding Objects and Methods OrientNucleotides Orient Nucleotide Sequences PFASUM PFASUM Amino Acid Substitution Matrices PredictDBN Predict RNA Secondary Structure in Dot-Bracket Notation PredictHEC Predict Protein Secondary Structure as Helix, Beta-Sheet, or Coil Read Dendrogram Read a Dendrogram from a Newick Formatted File RemoveGaps Remove Gap Characters in Sequences RESTRICTION_ENZYMES Common Restriction Enzyme's Cut Sites ScoreAlignment Score a Multiple Sequence Alignment SearchDB Obtain Specific Sequences from a Database Seqs2DB Add Sequences from Text File to Database StaggerAlignment Produce a Staggered Alignment Synteny-class Synteny blocks and hits Taxa-class Taxa training and testing objects TerminalChar Determine the Number of Terminal Characters TileSeqs Form a Set of Tiles for Each Group of Sequences TrainingSet_16S Training Set for Classification of 16S rRNA Gene Sequences TreeLine Construct a Phylogenetic Tree TrimDNA Trims DNA Sequences to the High Quality Region Between Patterns WriteDendrogram Write a Dendrogram to Newick Format WriteGenes Write Genes to a File"},{"path":"/reference/DECIPHER-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Tools for curating, analyzing, and manipulating biological sequences — DECIPHER-package","text":"Erik Wright Maintainer: Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/DesignArray.html","id":null,"dir":"Reference","previous_headings":"","what":"Design a Set of DNA Microarray Probes for Detecting Sequences — DesignArray","title":"Design a Set of DNA Microarray Probes for Detecting Sequences — DesignArray","text":"Chooses set microarray probes maximizing sensitivity specificity target consensus sequence.","code":""},{"path":"/reference/DesignArray.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Design a Set of DNA Microarray Probes for Detecting Sequences — DesignArray","text":"","code":"DesignArray(   myDNAStringSet,   maxProbeLength = 24,   minProbeLength = 20,   maxPermutations = 4,   numRecordedMismatches = 500,   numProbes = 10,   start = 1,   end = NULL,   maxOverlap = 5,   hybridizationFormamide = 10,   minMeltingFormamide = 15,   maxMeltingFormamide = 20,   minScore = -1e+12,   processors = 1,   verbose = TRUE )"},{"path":"/reference/DesignArray.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Design a Set of DNA Microarray Probes for Detecting Sequences — DesignArray","text":"myDNAStringSet DNAStringSet object aligned consensus sequences. maxProbeLength maximum length probes, including poly-T spacer.  Ideally less 27 nucleotides. minProbeLength minimum length probes, including poly-T spacer.  Ideally 18 nucleotides. maxPermutations maximum number probe permutations required represent target site.  example, target site 'N' 4 probes required probes ambiguous.  Typically fewer permutations preferably requires less space microarray simplifies interpretation results. numRecordedMismatches maximum number recorded potential cross-hybridizations target site. numProbes target number probes microarray per input consensus sequence. start Integer specifying starting position alignment potential forward primer target sites begin.  Preferably position included sequences alignment. end Integer specifying ending position alignment potential reverse primer target sites end.  Preferably position included sequences alignment. maxOverlap Maximum overlap nucleotides target sites sequence. hybridizationFormamide formamide concentration (\\ hybridization 42 degrees Celsius.  Note concentration used approximate hybridization efficiency cross-amplifications. minMeltingFormamide minimum melting point formamide concentration (\\ concentration half template bound probe. maxMeltingFormamide maximum melting point formamide concentration (\\ minMeltingFormamide. minScore minimum score designed probes exclusion.  greater minScore accelerate code target sites excluded consideration.  However, minScore high prevent target sites recorded. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display progress.","code":""},{"path":"/reference/DesignArray.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Design a Set of DNA Microarray Probes for Detecting Sequences — DesignArray","text":"data.frame optimal set probes matching specified constraints.  row lists probe's target sequence (name), start position, length nucleotides, start end position sequence alignment, number permutations, score, melt point percent formamide 42 degrees Celsius, hybridization efficiency (hyb_eff), target site, probe(s). Probes designed stringency determined equilibrium hybridization conditions subsequent washing steps.","code":""},{"path":"/reference/DesignArray.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Design a Set of DNA Microarray Probes for Detecting Sequences — DesignArray","text":"algorithm begins determining optimal length probes required meet input constraints maximizing sensitivity target consensus sequence specified hybridization formamide concentration. set potential target sites scored based possibility cross-hybridizing non-target sequences.  set probes returned minimum possibility cross-hybridizing.","code":""},{"path":"/reference/DesignArray.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Design a Set of DNA Microarray Probes for Detecting Sequences — DesignArray","text":"ES Wright et al. (2013) Identification Bacterial Archaeal Communities Source Tap. Water Research Foundation, Denver, CO. DR Noguera, et al. (2014). Mathematical tools optimize design oligonucleotide probes primers. Applied Microbiology Biotechnology. doi:10.1007/s00253-014-6165-x.","code":""},{"path":[]},{"path":"/reference/DesignArray.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Design a Set of DNA Microarray Probes for Detecting Sequences — DesignArray","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/DesignArray.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Design a Set of DNA Microarray Probes for Detecting Sequences — DesignArray","text":"","code":"fas <- system.file(\"extdata\", \"Bacteria_175seqs.fas\", package=\"DECIPHER\") dna <- readDNAStringSet(fas) names(dna) <- 1:length(dna) probes <- DesignArray(dna) #> ================================================================================ #> Time difference of 3.53 secs #>  probes[1,] #>   name start length start_aligned end_aligned permutations        score #> 1    1   550     24           661         686            1 92.60820.... #>      formamide      hyb_eff              target_site #> 1 16.31348.... 85.13890.... GTCATTGGAAACTGGGAGACTTGA #>                                         probes mismatches #> 1 TCAAGTCTCCCAGTTTCCAATGACTTTTTTTTTTTTTTTTTTTT   4 (0.8%)"},{"path":"/reference/DesignPrimers.html","id":null,"dir":"Reference","previous_headings":"","what":"Design PCR Primers Targeting a Specific Group of Sequences — DesignPrimers","title":"Design PCR Primers Targeting a Specific Group of Sequences — DesignPrimers","text":"Assists design primer sets targeting specific group sequences minimizing potential cross-amplify groups sequences.","code":""},{"path":"/reference/DesignPrimers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Design PCR Primers Targeting a Specific Group of Sequences — DesignPrimers","text":"","code":"DesignPrimers(   tiles,   identifier = \"\",   start = 1,   end = NULL,   minLength = 17,   maxLength = 26,   maxPermutations = 4,   minCoverage = 0.9,   minGroupCoverage = 0.2,   annealingTemp = 64,   P = 4e-07,   monovalent = 0.07,   divalent = 0.003,   dNTPs = 8e-04,   minEfficiency = 0.8,   worstScore = -Inf,   numPrimerSets = 0,   minProductSize = 75,   maxProductSize = 1200,   maxSearchSize = 1500,   batchSize = 1000,   maxDistance = 0.4,   primerDimer = 1e-07,   ragged5Prime = TRUE,   taqEfficiency = TRUE,   induceMismatch = FALSE,   processors = 1,   verbose = TRUE )"},{"path":"/reference/DesignPrimers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Design PCR Primers Targeting a Specific Group of Sequences — DesignPrimers","text":"tiles set tiles representing group sequences, format created function TileSeqs. identifier Optional character string used narrow search results matching specific identifier.  Determines target group(s) primers designed.  \"\" identifiers selected. start Integer specifying starting position alignment potential forward primer target sites begin.  Preferably position included sequences alignment. end Integer specifying ending position alignment potential reverse primer target sites end.  Preferably position included sequences alignment. minLength Integer providing minimum length primers consider design. maxLength Integer providing maximum length primers consider design, must less equal maxLength tiles. maxPermutations Integer providing maximum number permutations considered part forward reverse primer set. minCoverage Numeric giving minimum fraction target group's sequences must covered primer set. minGroupCoverage Numeric giving minimum fraction target group must sequence information (terminal gaps) region covered primer set. annealingTemp Numeric indicating desired annealing temperature used PCR experiment. P Numeric giving molar concentration primers reaction. monovalent molar concentration monovalent (Na K) ions solution used determine sodium equivalent concentration. divalent molar concentration divalent (Mg) ions solution used determine sodium equivalent concentration. dNTPs Numeric giving molar concentration free nucleotides added solution used determine sodium equivalent concentration. minEfficiency Numeric giving minimum efficiency hybridization desired primer set.  Note efficiency 99\\ greatly lower predicted specificity primer set, however efficiency 50\\ error melt temperature predictions. worstScore Numeric specifying score cutoff remove target sites consideration.  example, worstScore -5 remove primer sets scoring -5, although may eventually result primer sets meeting design criteria. numPrimerSets Integer giving optimal number primer sets (forward reverse primer sets) design.  set zero possible forward reverse primers returned, primer sets minimizing potential cross-amplifications chosen. minProductSize Integer giving minimum number nucleotides desired PCR product. maxProductSize Integer giving maximum number nucleotides desired PCR product. maxSearchSize Integer giving maximum number nucleotides search false priming upstream downstream expected binding site. batchSize Integer specifying number primers simulate hybridization per batch passed CalculateEfficiencyPCR. maxDistance Numeric specifying maximal fraction mismatched base pairings rolling basis beginning 3' end primer. primerDimer Numeric giving maximum amplification efficiency potential primer-dimer products. ragged5Prime Logical specifying whether 5' end 3' end primer permutations targeting site varying lengths. taqEfficiency Logical determining whether make use elongation efficiency maxDistance increase predictive accuracy Taq DNA Polymerase amplifying primers mismatches near 3' terminus. Note set FALSE using high-fidelity polymerase 3' 5' exonuclease activity. induceMismatch Logical integer specifying whether induce mismatch primer template DNA.  TRUE mismatch induced 6th primer position.  integer value provided 2 6 mismatch induced primer position, 3'-end defined position 1. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display progress.","code":""},{"path":"/reference/DesignPrimers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Design PCR Primers Targeting a Specific Group of Sequences — DesignPrimers","text":"different data.frame returned depending number primer sets requested.  primer sets required columns contain forward reverse primers every possible position scored potential amplify identified groups.  one primer sets requested columns contain information optimal set forward reverse primers used combination give fewest potential cross-amplifications.","code":""},{"path":"/reference/DesignPrimers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Design PCR Primers Targeting a Specific Group of Sequences — DesignPrimers","text":"Primers designed use Taq DNA Polymerase maximize sensitivity specificity target group sequences.  design makes use Taq's bias certain 3' terminal mismatch types order increase specificity can achieve hybridization efficiency alone. Primers designed set tiles target identifier minimizing affinity tiled groups.  Arguments provide constraints ensure designed primer sets meet specified criteria well optimized particular experimental conditions.  search conducted tiles alignment position estimate chance cross-amplification non-target group. numPrimers greater equal one set forward reverse primers minimizes potential false positive overlap returned.  also initiate thorough search target sites upstream downstream expected binding sites ensure primers bind nearby positions.  Lowering maxSearchSize speed thorough search expense potentially missing unexpected target site.  number possible primer sets assessed increased size numPrimers.","code":""},{"path":"/reference/DesignPrimers.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Design PCR Primers Targeting a Specific Group of Sequences — DesignPrimers","text":"program OligoArrayAux (http://www.unafold.org/Dinamelt/software/oligoarrayaux.php) must installed location accessible system.  example, following code print installed OligoArrayAux version executed R console: system(\"hybrid-min -V\") install OligoArrayAux downloaded source folder Unix-like platforms, open shell (Terminal Mac OS) type: cd oligoarrayaux # change directory correct folder name ./configure make sudo make install","code":""},{"path":"/reference/DesignPrimers.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Design PCR Primers Targeting a Specific Group of Sequences — DesignPrimers","text":"ES Wright et al. (2013) \"Exploiting Extension Bias PCR Improve Primer Specificity Ensembles Nearly Identical DNA Templates.\" Environmental Microbiology, doi:10.1111/1462-2920.12259.","code":""},{"path":[]},{"path":"/reference/DesignPrimers.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Design PCR Primers Targeting a Specific Group of Sequences — DesignPrimers","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/DesignPrimers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Design PCR Primers Targeting a Specific Group of Sequences — DesignPrimers","text":"","code":"db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") # not run (must have OligoArrayAux installed first): if (FALSE) tiles <- TileSeqs(db, identifier=c(\"Enterobacteriales\",\"Pseudomonadales\")) if (FALSE) primers <- DesignPrimers(tiles, identifier=\"Enterobacteriales\", start=280, end=420,            minProductSize=50, numPrimerSets=1)"},{"path":"/reference/DesignProbes.html","id":null,"dir":"Reference","previous_headings":"","what":"Design FISH Probes Targeting a Specific Group of Sequences — DesignProbes","title":"Design FISH Probes Targeting a Specific Group of Sequences — DesignProbes","text":"Assists design single dual probes targeting specific group sequences minimizing potential cross-hybridize groups sequences.","code":""},{"path":"/reference/DesignProbes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Design FISH Probes Targeting a Specific Group of Sequences — DesignProbes","text":"","code":"DesignProbes(   tiles,   identifier = \"\",   start = 1,   end = NULL,   minLength = 17,   maxLength = 26,   maxPermutations = 4,   minCoverage = 0.9,   minGroupCoverage = 0.2,   hybTemp = 46,   P = 2.5e-07,   Na = 1,   FA = 35,   minEfficiency = 0.5,   worstScore = -Inf,   numProbeSets = 0,   batchSize = 1000,   target = \"SSU\",   verbose = TRUE )"},{"path":"/reference/DesignProbes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Design FISH Probes Targeting a Specific Group of Sequences — DesignProbes","text":"tiles set tiles representing group sequences, format created function TileSeqs. identifier Optional character string used narrow search results matching specific identifier.  Determines target group(s) probes designed.  \"\" identifiers selected. start Integer specifying starting position alignment potential target sites begin.  Preferably position included sequences alignment. end Integer specifying ending position alignment potential target sites end.  Preferably position included sequences alignment. minLength Integer providing minimum length probes consider design. maxLength Integer providing maximum length probes consider design, must less equal maxLength tiles. maxPermutations Integer providing maximum number probe permutations required reach desired coverage target site. minCoverage Numeric giving minimum fraction target group's sequences must covered designed probe(s). minGroupCoverage Numeric giving minimum fraction target group must sequence information (terminal gaps) target site's region. hybTemp Numeric specifying hybridization temperature, typically 46 degrees Celsius. P Numeric giving molar concentration probes hybridization. Na Numeric giving molar sodium concentration hybridization buffer.  Values may range 0.01M 1M.  Note salt correction 1 molar available thermodynamic rules RNA/RNA interactions. FA Numeric concentration (percent v/v) denaturant formamide hybridization buffer. minEfficiency Numeric giving minimum equilibrium hybridization efficiency desired designed probe(s) defined experimental conditions. worstScore Numeric specifying score cutoff remove target sites consideration.  example, worstScore -5 remove probes scoring -5, although may eventually result probes meeting design criteria. numProbeSets Integer giving optimal number dual probe sets design.  set zero potential single probes returned, probe sets minimizing potential false cross-hybridizations chosen. batchSize Integer specifying number probes simulate hybridization per batch passed CalculateEfficiencyFISH. target target molecule used generation tiles.  Either \"SSU\" small-subunit rRNA, \"LSU\" large-subunit rRNA, \"\".  Used determine domain dG3 calculations, plus minus 200 nucleotides target site \"\". verbose Logical indicating whether display progress.","code":""},{"path":"/reference/DesignProbes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Design FISH Probes Targeting a Specific Group of Sequences — DesignProbes","text":"different data.frame returned depending number primer sets requested.  probe sets required columns contain designed probes every possible position scored potential cross-hybridize identified groups.  one probe sets requested columns contain information optimal set probes (probe one probe two) used combination give fewest potential cross-hybridizations.","code":""},{"path":"/reference/DesignProbes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Design FISH Probes Targeting a Specific Group of Sequences — DesignProbes","text":"Probes designed maximize sensitivity specificity target group(s) (identifier(s)).  numProbeSets > 0 many pairs probes minimal cross-hybridization overlap returned, enabling increased specificity dual-color approach. Probes designed set tiles target identifier minimizing affinity tiled groups.  Arguments provide constraints ensure designed probes meet specified criteria well optimized particular experimental conditions.  search conducted tiles alignment position estimate chance cross-hybridization non-target group. Two models used design, experimentally calibrated using denaturation profiles 5 organisms belonging three domains life.  Probe lengths chosen meet minEfficiency using fast model probe-target hybridization.  Candidate probes confirmed using slower model also takes account probe-folding target-folding.  Finally, probes scored inability cross-hybridize non-target groups using fast model taking account mismatches.","code":""},{"path":"/reference/DesignProbes.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Design FISH Probes Targeting a Specific Group of Sequences — DesignProbes","text":"program OligoArrayAux (http://www.unafold.org/Dinamelt/software/oligoarrayaux.php) must installed location accessible system.  example, following code print installed OligoArrayAux version executed R console: system(\"hybrid-min -V\") install OligoArrayAux downloaded source folder Unix-like platforms, open shell (Terminal Mac OS) type: cd oligoarrayaux # change directory correct folder name ./configure make sudo make install","code":""},{"path":"/reference/DesignProbes.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Design FISH Probes Targeting a Specific Group of Sequences — DesignProbes","text":"ES Wright et al. (2014) \"Automated Design Probes rRNA-Targeted Fluorescence Situ Hybridization Reveals Advantages Using Dual Probes Accurate Identification.\" Applied Environmental Microbiology, doi:10.1128/AEM.01685-14.","code":""},{"path":[]},{"path":"/reference/DesignProbes.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Design FISH Probes Targeting a Specific Group of Sequences — DesignProbes","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/DesignProbes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Design FISH Probes Targeting a Specific Group of Sequences — DesignProbes","text":"","code":"db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") # not run (must have OligoArrayAux installed first): if (FALSE) tiles <- TileSeqs(db, identifier=c(\"Enterobacteriales\",\"Pseudomonadales\")) if (FALSE) probes <- DesignProbes(tiles, identifier=\"Enterobacteriales\", start=280, end=420)"},{"path":"/reference/DesignSignatures.html","id":null,"dir":"Reference","previous_headings":"","what":"Design PCR Primers for Amplifying Group-Specific Signatures — DesignSignatures","title":"Design PCR Primers for Amplifying Group-Specific Signatures — DesignSignatures","text":"Aids design pairs primers amplifying unique ``signature'' group sequences.  Signatures distinct PCR products can differentiated length, melt temperature, sequence.","code":""},{"path":"/reference/DesignSignatures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Design PCR Primers for Amplifying Group-Specific Signatures — DesignSignatures","text":"","code":"DesignSignatures(   dbFile,   tblName = \"Seqs\",   identifier = \"\",   focusID = NA,   type = \"melt\",   resolution = 0.5,   levels = 10,   enzymes = NULL,   minLength = 17,   maxLength = 26,   maxPermutations = 4,   annealingTemp = 64,   P = 4e-07,   monovalent = 0.07,   divalent = 0.003,   dNTPs = 8e-04,   minEfficiency = 0.8,   ampEfficiency = 0.5,   numPrimerSets = 100,   minProductSize = 70,   maxProductSize = 400,   kmerSize = 8,   searchPrimers = 500,   maxDictionary = 20000,   primerDimer = 1e-07,   pNorm = 1,   taqEfficiency = TRUE,   processors = 1,   verbose = TRUE )"},{"path":"/reference/DesignSignatures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Design PCR Primers for Amplifying Group-Specific Signatures — DesignSignatures","text":"dbFile SQLite connection object character string specifying path database file. tblName Character string specifying table DNA sequences located. identifier Optional character string used narrow search results matching specific identifier.  Determines target group(s) primers designed.  \"\" identifiers selected. focusID Optional character string specifying identifiers used initial step designing primers. NA (default), identifier sequence information used focusID. type Character string indicating type signature used differentiate PCR products group.  (abbreviation ) one \"melt\", \"length\", \"sequence\". resolution Numeric specifying ``resolution'' experiment, vector giving boundaries bins.  (See details section .) levels Numeric giving number ``levels'' can distinguished bin.  (See details section .) enzymes Named character vector providing cut sites one restriction enzymes.  Cut sites must delineated format RESTRICTION_ENZYMES. minLength Integer providing minimum length primers consider design. maxLength Integer providing maximum length primers consider design. maxPermutations Integer providing maximum number permutations allowed forward reverse primer attain greater coverage sequences. annealingTemp Numeric indicating desired annealing temperature used PCR experiment. P Numeric giving molar concentration primers reaction. monovalent molar concentration monovalent (Na K) ions solution used determine sodium equivalent concentration. divalent molar concentration divalent (Mg) ions solution used determine sodium equivalent concentration. dNTPs Numeric giving molar concentration free nucleotides added solution used determine sodium equivalent concentration. minEfficiency Numeric giving minimum efficiency hybridization desired primer set. ampEfficiency Numeric giving minimum efficiency required theoretical amplification primers.  Note ampEfficiency must less equal minEfficiency.  Lower values ampEfficiency allow PCR products, although low values unrealistic experimentally. numPrimerSets Integer giving optimal number primer sets (forward reverse primer sets) design. minProductSize Integer giving minimum number nucleotides desired PCR product. maxProductSize Integer giving maximum number nucleotides desired PCR product. kmerSize Integer giving size k-mers use preliminary search potential primers. searchPrimers Numeric specifying number forward reverse primers use searching potential PCR products.  lower value result faster search, potentially neglect useful primers. maxDictionary Numeric giving maximum number primers search simultaneously given step. primerDimer Numeric giving maximum amplification efficiency potential primer-dimer products. pNorm Numeric specifying power (p > 0) used calculating \\(L\\textsuperscript{p}\\)-norm scoring primer pairs.  default (p = 1), score equivalent average difference pairwise signatures.  p < 1, many small differences preferred fewer large differences, vise-versa p > 1.  enables prioritizing primer pairs yield greater number unique signatures (p < 1), fewer distinct, dissimilar, signatures (p > 1). taqEfficiency Logical determining whether make use elongation efficiency increase predictive accuracy Taq DNA Polymerase amplifying primers mismatches near 3' terminus.  Note set FALSE using high-fidelity polymerase 3' 5' exonuclease activity. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display progress.","code":""},{"path":"/reference/DesignSignatures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Design PCR Primers for Amplifying Group-Specific Signatures — DesignSignatures","text":"data.frame top-scoring pairs forward reverse primers, score, total number PCR products, associated columns restriction enzyme (enzyme NULL).","code":""},{"path":"/reference/DesignSignatures.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Design PCR Primers for Amplifying Group-Specific Signatures — DesignSignatures","text":"Signatures group-specific PCR products can differentiated either melt temperature profile, length, sequence. DesignSignatures assists finding optimal pair forward reverse primers obtaining distinguishable signature group sequences.  Groups delineated unique identifier database.  algorithm works progressively narrowing search optimal primers: (1) frequent k-mers found; (2) used design primers initially matching focusID group; (3) common forward reverse primers selected based groups, ambiguity added maxPermutations; (4) final search performed find optimal forward reverse primer.  Pairs primers scored distance signatures generated group, depends type experiment. arguments resolution levels control theoretical resolving power experiment.  signature group discretized grouped bins'' certain magnitude signal.  \\code{resolution} determines separation distinguishable bins'', levels controls range values bin.  high-accuracy experiment many bins /many levels.  levels interpreted similarly every type experiment, resolution treated differently depending type.  type \"melt\", resolution can either vector different melt temperatures, single number giving change temperatures can differentiated.  high-resolution melt (HRM) assay typically resolution 0.25 1 degree Celsius.  type \"length\" resolution either number bins minProductSize maxProductSize, bin boundaries.  example, resolution can lower (wider bins) long lengths, higher (narrower bins) shorter lengths.  type \"sequence\" resolution sets k-mer size used differentiating amplicons.  Oftentimes, 4 6-mers used classification amplicons. signatures can diversified using restriction enzyme digest PCR products type \"melt\" \"length\".  enzymes supplied additional search made find best enzyme use pair primers.  case, output includes primer pairs, well enzymes digest PCR products primer pair.  output re-scored rank top primer pair enzyme combination.  Note enzymes inapplicable type \"sequence\" restriction enzymes alter sequence DNA.  Also, recommended subset available RESTRICTION_ENZYMES used input enzymes order accelerate search best enzyme.","code":""},{"path":"/reference/DesignSignatures.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Design PCR Primers for Amplifying Group-Specific Signatures — DesignSignatures","text":"Wright, E.S. & Vetsigian, K.H. (2016) \"DesignSignatures: tool designing primers yields amplicons distinct signatures.\" Bioinformatics, doi:10.1093/bioinformatics/btw047.","code":""},{"path":[]},{"path":"/reference/DesignSignatures.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Design PCR Primers for Amplifying Group-Specific Signatures — DesignSignatures","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/DesignSignatures.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Design PCR Primers for Amplifying Group-Specific Signatures — DesignSignatures","text":"","code":"# below are suggested inputs for different types of experiments db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\")  if (FALSE) { # High Resolution Melt (HRM) assay: primers <- DesignSignatures(db,            resolution=seq(75, 100, 0.25), # degrees Celsius            minProductSize=55, # base pairs            maxProductSize=400)  # Primers for next-generation sequencing: primers <- DesignSignatures(db,            type=\"sequence\",            minProductSize=300, # base pairs            maxProductSize=700,            resolution=5, # 5-mers            levels=5)  # Primers for community fingerprinting: primers <- DesignSignatures(db,            type=\"length\",            levels=2, # presence/absence            minProductSize=200, # base pairs            maxProductSize=1400,            resolution=c(seq(200, 700, 3),                         seq(705, 1000, 5),                         seq(1010, 1400, 10)))  # Primers for restriction fragment length polymorphism (RFLP): data(RESTRICTION_ENZYMES) myEnzymes <- RESTRICTION_ENZYMES[c(\"EcoRI\", \"HinfI\", \"SalI\")] primers <- DesignSignatures(db,            type=\"length\",            levels=2, # presence/absence            minProductSize=200, # base pairs            maxProductSize=600,            resolution=c(seq(50, 100, 3),                         seq(105, 200, 5),                         seq(210, 600, 10)),            enzymes=myEnzymes) }"},{"path":"/reference/DetectRepeats.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect Repeats in a Sequence — DetectRepeats","title":"Detect Repeats in a Sequence — DetectRepeats","text":"Detects approximate copies sequence patterns likely arose duplication events therefore share common ancestor.","code":""},{"path":"/reference/DetectRepeats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect Repeats in a Sequence — DetectRepeats","text":"","code":"DetectRepeats(   myXStringSet,   type = \"tandem\",   minScore = 15,   allScores = FALSE,   maxPeriod = 1000,   maxFailures = 2,   maxShifts = 5,   alphabet = AA_REDUCED[[125]],   useEmpirical = TRUE,   processors = 1,   verbose = TRUE,   ... )"},{"path":"/reference/DetectRepeats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect Repeats in a Sequence — DetectRepeats","text":"myXStringSet AAStringSet, DNAStringSet, RNAStringSet object unaligned sequences. type Character string indicating type repeats detect.  (abbreviation ) one \"tandem\", \"interspersed\", \"\".  \"tandem\" possible myXStringSet AAStringSet.  (See details section .) minScore Numeric giving minimum score repeats myXStringSet report. allScores Logical specifying whether repeats returned (TRUE) top scoring repeat multiple overlapping matches region. maxPeriod Numeric indicating maximum periodicity tandem repeats consider.  Interspersed repeats detected least maxPeriod nucleotides apart. maxFailures Numeric determining maximum number failing attempts extend repeat permitted.  Numbers greater zero may increase accuracy expense speed, decreasing marginal returns maxFailures gets higher higher. maxShifts Numeric determining maximum number failing attempts shift repeat left right permitted.  Numbers greater zero may increase accuracy expense speed, decreasing marginal returns maxShifts gets higher higher. alphabet Character vector amino acid groupings used reduce 20 standard amino acids smaller groups.  Alphabet reduction helps find distant homologies sequences.  non-reduced amino acid alphabet can used setting alphabet equal AA_STANDARD. applicable myXStringSet AAStringSet. useEmpirical Logical specifying whether use empirical signals structurally-determined tandem repeats scoring. Empirical signals include number repeats, periodicity, amino acid composition myXStringSet AAStringSet. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display progress. ... arguments passed directly FindSynteny type \"interspersed\" \"\".","code":""},{"path":"/reference/DetectRepeats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect Repeats in a Sequence — DetectRepeats","text":"type \"tandem\", data.frame giving \"Index\" sequence myXStringSet, \"Begin\" \"End\" positions tandem repeats, \"Left\" \"Right\" positions repeat, \"Score\". type \"interspersed\", data.frame similar matrix lower diagonal Synteny objects (see Synteny-class). type \"\", list two elements.","code":""},{"path":"/reference/DetectRepeats.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Detect Repeats in a Sequence — DetectRepeats","text":"Many sequences composed substantial fraction repetitive sequence.  Two main forms repetition tandem repeats interspersed repeats, can caused duplication events followed divergence. Detecting duplications challenging variability repeat length composition due evolution.  significance repeat can quantified time since divergence common ancestor. DetectRepeats uses seed--extend approach identify candidate repeats, tests whether set repeats statistically significant using background-corrected substitution matrix gap (.e., insertion deletion) penalties.  higher score implies repeats conserved , therefore, likely diverged within finite amount time common ancestor.  myXStringSet AAStringSet, similarity includes agreement among predicted secondary structures. Two possible types repeats detectable: * type \"tandem\" (default) \"\" Contiguous approximate copies nucleotide amino acid sequence.  First, repeated k-mers identified along length input sequence(s).  k-mer seed identified, repeated attempts made extend repeat left right, well optimize beginning ending positions. * type \"interspersed\" \"\" Dispersed approximate copies nucleotide sequence strand opposite strands.  identified FindSynteny, aligned AlignSynteny, scored using statistical framework tandem repeats. highest scoring repeat region returned, unless allScores TRUE, case overlapping repeats permitted result.","code":""},{"path":"/reference/DetectRepeats.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Detect Repeats in a Sequence — DetectRepeats","text":"Schaper, E., et al. (2012). Repeat repeat?-Statistical validation tandem repeat prediction genomic sequences. Nucleic Acids Research, 40(20), 10005-17.","code":""},{"path":[]},{"path":"/reference/DetectRepeats.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Detect Repeats in a Sequence — DetectRepeats","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/DetectRepeats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect Repeats in a Sequence — DetectRepeats","text":"","code":"fas <- system.file(\"extdata\", \"Human_huntingtin_cds.fas.gz\", package=\"DECIPHER\") dna <- readDNAStringSet(fas)  x <- DetectRepeats(dna) #> ================================================================================ #>  #> Time difference of 3.69 secs #>  x #>   Index Begin End         Left        Right    Score #> 1     1    53 160 53, 62, .... 61, 70, .... 58.52349  # number of tandem repeats lengths(x[, \"Left\"]) #> [1] 12  # average periodicity of tandem repeats per <- mapply(function(a, b) b - a + 1,   x[, \"Left\"],   x[, \"Right\"],   SIMPLIFY=FALSE) sapply(per, mean) #> [1] 9  # extract a tandem repeat i <- 1 reps <- extractAt(dna[[x[i, \"Index\"]]],   IRanges(x[[i, \"Left\"]], x[[i, \"Right\"]])) reps #> DNAStringSet object of length 12: #>      width seq #>  [1]     9 AGCAGCAGC #>  [2]     9 AGCAGCAGC #>  [3]     9 AGCAGCAGC #>  [4]     9 AGCAGCAGC #>  [5]     9 AGCAGCAGC #>  ...   ... ... #>  [8]     9 CGCCACCGC #>  [9]     9 CGCCGCCGC #> [10]     9 CGCCGCCGC #> [11]     9 CTCCTCAGC #> [12]     9 TTCCTCAGC reps <- AlignSeqs(reps, verbose=FALSE) # align the repeats reps #> DNAStringSet object of length 12: #>      width seq #>  [1]     9 AGCAGCAGC #>  [2]     9 AGCAGCAGC #>  [3]     9 AGCAGCAGC #>  [4]     9 AGCAGCAGC #>  [5]     9 AGCAGCAGC #>  ...   ... ... #>  [8]     9 CGCCACCGC #>  [9]     9 CGCCGCCGC #> [10]     9 CGCCGCCGC #> [11]     9 CTCCTCAGC #> [12]     9 TTCCTCAGC BrowseSeqs(reps)  aa <- translate(dna) y <- DetectRepeats(aa) #> ================================================================================ #>  #> Time difference of 1.27 secs #>  y #>   Index Begin End         Left        Right    Score #> 1     1    18  49 18, 19, .... 18, 19, .... 26.43138  # highlight tandem repeats in the sequence colors <- c(\"deeppink\", \"deepskyblue\") colors <- lapply(colors, function(x) col2rgb(x)/255) cols <- vector(\"list\", length(aa)) for (i in seq_along(cols)) {   cols[[i]] <- matrix(0, nrow=3, ncol=width(aa)[i])   for (j in which(y[, \"Index\"] == i)) {     left <- y[[j, \"Left\"]]     right <- y[[j, \"Right\"]]     n <- 0     for (k in seq_along(left)) {       r <- left[k]:right[k]       n <- n + 1       if (n > length(colors))         n <- 1       cols[[i]][, r] <- colors[[n]]     }   } } BrowseSeqs(aa, patterns=cols)  # find interspersed (rather than tandem) repeats data(yeastSEQCHR1) chr1 <- DNAStringSet(yeastSEQCHR1)  z <- DetectRepeats(chr1, type=\"interspersed\") #> ================================================================================ #>  #> Time difference of 0.18 secs #>  z #>   index1 index2 strand       score start1 start2   end1   end2 #> 1      1      1      0   244.84467 160238 165826 160574 166162 #> 2      1      1      0   187.94986   1805 176651   2176 177027 #> 3      1      1      0   126.34664 183135 189419 183468 189751 #> 4      1      1      0    78.95767 195872 199401 196028 199556 #> 5      1      1      1 10582.21294  12908 203520  27843 219315 #> 6      1      1      1    75.45568      2 228511   1699 230202 #> 7      1      1      1    16.67126  93842 132303  93879 132340"},{"path":"/reference/DigestDNA.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Restriction Digestion of DNA — DigestDNA","title":"Simulate Restriction Digestion of DNA — DigestDNA","text":"Restriction enzymes can used cut double-stranded DNA fragments specific cut sites.  DigestDNA performs -silico restriction digest input DNA sequence(s) given one restriction sites.","code":""},{"path":"/reference/DigestDNA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Restriction Digestion of DNA — DigestDNA","text":"","code":"DigestDNA(sites, myDNAStringSet, type = \"fragments\", strand = \"both\")"},{"path":"/reference/DigestDNA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Restriction Digestion of DNA — DigestDNA","text":"sites character vector DNA recognition sequences enzymes' corresponding cut site(s). myDNAStringSet DNAStringSet object character vector one sequences 5' 3' orientation. type Character string indicating type results desired.  (abbreviation ) either \"fragments\" \"positions\". strand Character string indicating strand(s) cut.  (abbreviation ) one \"\", \"top\", \"bottom\".  top strand defined input DNAStringSet sequence, bottom strand reverse complement.","code":""},{"path":"/reference/DigestDNA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Restriction Digestion of DNA — DigestDNA","text":"DigestDNA can return two types results: cut positions resulting DNA fragments corresponding top, bottom, strands.  type \"positions\" output list cut location(s) sequence myDNAStringSet.  cut location defined position cut relative 5'-end.  example, cut 6 occur positions 5 6, respective strand's 5' nucleotide defined position 1. type \"fragments\" (default), result DNAStringSetList.  element list contains top /bottom strand fragments digestion myDNAStringSet, original sequence cuts made. Sequences named whether originated top bottom strand, list elements named based input DNA sequences.  top strand defined myDNAStringSet input, whereas bottom strand reverse complement.","code":""},{"path":"/reference/DigestDNA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Restriction Digestion of DNA — DigestDNA","text":"context restriction digest experiment known DNA sequence, can useful predict expected DNA fragments -silico. Restriction enzymes make cuts double-stranded DNA specific positions near recognition site.  recognition site may somewhat ambiguous, represented IUPAC_CODE_MAP.  Cuts occur different positions top bottom strands result sticky-ends, whereas occur position result fragments blunt-ends.  Multiple restriction sites can supplied simultaneously digest DNA.  case, sites different restriction enzymes may overlapping, result multiple close-proximity cuts occur experimentally.  Also, note cut sites matched non-DNA_BASES myDNAStringSet.","code":""},{"path":[]},{"path":"/reference/DigestDNA.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate Restriction Digestion of DNA — DigestDNA","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/DigestDNA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Restriction Digestion of DNA — DigestDNA","text":"","code":"# digest hypothetical DNA sequences with BamHI data(RESTRICTION_ENZYMES) site <- RESTRICTION_ENZYMES[c(\"BamHI\")] dna <- DNAStringSet(c(\"AAGGATCCAA\", \"GGGATCAT\")) dna # top strand #> DNAStringSet object of length 2: #>     width seq #> [1]    10 AAGGATCCAA #> [2]     8 GGGATCAT reverseComplement(dna) # bottom strand #> DNAStringSet object of length 2: #>     width seq #> [1]    10 TTGGATCCTT #> [2]     8 ATGATCCC names(dna) <- c(\"hyp1\", \"hyp2\") d <- DigestDNA(site, dna) d # fragments in a DNAStringSetList #> DNAStringSetList of length 2 #> [[\"hyp1\"]] top=AAG top=GATCCAA bottom=TTG bottom=GATCCTT #> [[\"hyp2\"]] top=GGGATCAT bottom=ATGATCCC unlist(d) # all fragments as one DNAStringSet #> DNAStringSet object of length 6: #>     width seq                                               names                #> [1]     3 AAG                                               hyp1.top #> [2]     7 GATCCAA                                           hyp1.top #> [3]     3 TTG                                               hyp1.bottom #> [4]     7 GATCCTT                                           hyp1.bottom #> [5]     8 GGGATCAT                                          hyp2.top #> [6]     8 ATGATCCC                                          hyp2.bottom  # Restriction digest of Yeast Chr. 1 with EcoRI and EcoRV data(yeastSEQCHR1) sites <- RESTRICTION_ENZYMES[c(\"EcoRI\", \"EcoRV\")] seqs <- DigestDNA(sites, yeastSEQCHR1) seqs[[1]] #> DNAStringSet object of length 314: #>       width seq                                             names                #>   [1]   612 CCACACCACACCCACACACCCA...CCATCATTATCCACATTTTGAT top #>   [2]  1431 ATCTATATCTCATTCGGCGGTC...ATTGGGCTAAGTGAGCTCTGAT top #>   [3]   568 ATCAGAGACGTAGACACCCAAT...AGAAGCTTATTGTCTAAGCCTG top #>   [4]    51 AATTCAGTCTGCTTTAAACGGC...GAGGAAATATTTCCATCTCTTG top #>   [5]   136 AATTCGTACAACATTAAACGTG...GATGGTAATGAGACAAGTTGAT top #>   ...   ... ... #> [310]   132 ATCAACTTGTCTCATTACCATC...AACACACGTTTAATGTTGTACG bottom #> [311]    51 AATTCAAGAGATGGAAATATTT...GGAAGCCGTTTAAAGCAGACTG bottom #> [312]   572 AATTCAGGCTTAGACAATAAGC...ATTGGGTGTCTACGTCTCTGAT bottom #> [313]  1431 ATCAGAGCTCACTTAGCCCAAT...GACCGCCGAATGAGATATAGAT bottom #> [314]   612 ATCAAAATGTGGATAATGATGG...TGGGTGTGTGGGTGTGGTGTGG bottom  pos <- DigestDNA(sites, yeastSEQCHR1, type=\"positions\") str(pos) #> List of 1 #>  $ 1:List of 2 #>   ..$ top   : num [1:156] 613 2044 2612 2663 2799 ... #>   ..$ bottom: num [1:156] 974 5491 6024 12303 15707 ..."},{"path":"/reference/Disambiguate.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand Ambiguities into All Permutations of a DNAStringSet — Disambiguate","title":"Expand Ambiguities into All Permutations of a DNAStringSet — Disambiguate","text":"Performs inverse function ConsensusSequence expanding ambiguities present sequences.","code":""},{"path":"/reference/Disambiguate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand Ambiguities into All Permutations of a DNAStringSet — Disambiguate","text":"","code":"Disambiguate(myXStringSet)"},{"path":"/reference/Disambiguate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expand Ambiguities into All Permutations of a DNAStringSet — Disambiguate","text":"myXStringSet DNAStringSet RNAStringSet object sequences.","code":""},{"path":"/reference/Disambiguate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expand Ambiguities into All Permutations of a DNAStringSet — Disambiguate","text":"DNAStringSetList RNAStringSetList one element sequence myXStringSet.","code":""},{"path":"/reference/Disambiguate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Expand Ambiguities into All Permutations of a DNAStringSet — Disambiguate","text":"Ambiguity codes IUPAC_CODE_MAP can used represent multiple nucleotides single position.  Using letters, multiple oligonucleotide permutations can represented single ambiguous sequence.  function expands sequence DNAStringSet input permutations.  Note sequences many ambiguities can result large number potential permutations.","code":""},{"path":[]},{"path":"/reference/Disambiguate.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Expand Ambiguities into All Permutations of a DNAStringSet — Disambiguate","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/Disambiguate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expand Ambiguities into All Permutations of a DNAStringSet — Disambiguate","text":"","code":"dna <- DNAStringSet(c(\"ACST\", \"NNN\")) dna_list <- Disambiguate(dna) dna_list[[1]] #> DNAStringSet object of length 2: #>     width seq #> [1]     4 ACCT #> [2]     4 ACGT dna_list[[2]] #> DNAStringSet object of length 64: #>      width seq #>  [1]     3 AAA #>  [2]     3 CCC #>  [3]     3 GGG #>  [4]     3 TTT #>  [5]     3 ACA #>  ...   ... ... #> [60]     3 TCG #> [61]     3 ATT #> [62]     3 CAA #> [63]     3 GCC #> [64]     3 TGG unlist(dna_list) #> DNAStringSet object of length 66: #>      width seq #>  [1]     4 ACCT #>  [2]     4 ACGT #>  [3]     3 AAA #>  [4]     3 CCC #>  [5]     3 GGG #>  ...   ... ... #> [62]     3 TCG #> [63]     3 ATT #> [64]     3 CAA #> [65]     3 GCC #> [66]     3 TGG  rna <- RNAStringSet(c(\"ACGU\", \"AGAU\")) # 2 permutations rna <- ConsensusSequence(rna) # \"ASRU\" Disambiguate(rna) # 4 permutations #> RNAStringSetList of length 1 #> [[1]] ACAU AGGU ACGU AGAU"},{"path":[]},{"path":"/reference/DistanceMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the Distances Between Sequences — DistanceMatrix","text":"","code":"DistanceMatrix(   myXStringSet,   method = \"overlap\",   type = \"matrix\",   includeTerminalGaps = FALSE,   penalizeGapLetterMatches = TRUE,   minCoverage = 0,   correction = \"none\",   processors = 1,   verbose = TRUE )"},{"path":"/reference/DistanceMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the Distances Between Sequences — DistanceMatrix","text":"myXStringSet DNAStringSet, RNAStringSet, AAStringSet object aligned sequences. method Character string determining region distance calculated.  (unambiguous abbreviation ) one \"overlap\", \"shortest\", \"longest\".  default method (\"overlap\") calculates distance overlapping region terminal gaps includeTerminalGaps FALSE entire alignment otherwise.  Setting method \"shortest\" \"longest\" use region start end shortest longest sequence, respectively, pairwise distance.  method relevant includeTerminalGaps TRUE. type Character string indicating type output desired.  either \"matrix\" \"dist\".  (See value section .) includeTerminalGaps Logical specifying whether include terminal gaps (\"-\" \".\" characters end sequence) calculation distance. penalizeGapLetterMatches Logical specifying whether consider gap--letter matches mismatches.  FALSE, gap--letter matches included total length used calculate distance.  default (TRUE) penalize gap--letter mismatches letter--letter mismatches.  NA gap--letter mismatches penalized per insertion deletion, .e., changing gap--letter letter--gap. minCoverage Numeric zero one giving minimum fraction sequence positions (gap mask) shortest sequence must overlapping longer sequence pair.  Sequences minCoverage assigned NA distances.  Note non-overlapping sequences always given NA distances, regardless minCoverage, unless includeTerminalGaps TRUE (distance = 100\\ correctionThe substitution model used distance correction.  (abbreviation ) either \"none\", \"Jukes-Cantor\" (.e., \"JC69\"), \"F81\".  \"F81\" letter frequencies derived myXStringSet. processorsThe number processors use, NULL automatically detect use available processors. verboseLogical indicating whether display progress. type \"matrix\", symmetric matrix element distance sequences referenced respective row column.  dimnames matrix correspond names XStringSet.type \"dist\", object class \"dist\" contains one triangle distance matrix vector.  Since distance matrix symmetric, storing one triangle memory efficient. Calculates distance matrix XStringSet.  element distance matrix corresponds dissimilarity two sequences XStringSet. uncorrected (correction = \"none\") distance matrix represents hamming distance sequences myXStringSet. Ambiguity can represented using characters IUPAC_CODE_MAP DNAStringSet RNAStringSet inputs, using AMINO_ACID_CODE AAStringSet input. example, distance 'N' nucleotide base zero.  letters B (N D), J (L), Z (Q E), X (letter) degenerate AMINO_ACID_CODE.includeTerminalGaps = FALSE terminal gaps (\"-\" \".\" characters) included sequence length.  can faster since positions common pair sequences compared.  Sequences overlapping region alignment given value NA, unless includeTerminalGaps = TRUE, case distance 100\\ Masked characters (\"+\") either sequence considered distance.Penalizing gap--letter mismatches specifies whether penalize special mismatch types include total length calculating distance.  \"-\" \".\" characters interpreted gaps.  default behavior calculate distance fraction positions differ across region alignment shared sequences (including gap--gap matches).Two correction factors available, \"JC69\" \"F81\", described MODELS.  transform raw distance (\\(d\\)) $$-E * \\log \\left( 1 - d / E \\right)$$, $$E = 1 - \\sum_{\\sym} f_i^2$$ (\\(f\\)) relative frequency symbol (\\(sym\\)).  \"JC69\" model symbols assumed equal frequency, whereas \"F81\" model symbol frequencies empirically derived input myXStringSet.  Note gaps treated additional symbol penalizeGapLetterMatches TRUE.elements distance matrix can referenced dimnames corresponding names XStringSet.  Additionally, attribute named \"correction\" specifying method correction used can accessed using function attr. # example using defaults: dna <- DNAStringSet(c(\"ACTG\", \"ACCG\")) dna DistanceMatrix(dna)# changing output type \"dist\": d <- DistanceMatrix(dna, type=\"dist\") d length(d) # minimal memory space required m <- .matrix(d) length(m) # memory space required# supplying AAStringSet aa <- AAStringSet(c(\"ASYK\", \"ATYK\", \"CTWN\")) aa DistanceMatrix(aa)# defaults compare intersection internal ranges: dna <- DNAStringSet(c(\"ANGCT-\", \"-ACCT-\")) dna d <- DistanceMatrix(dna) d # d[1,2] 1 base 4 = 0.25# compare union internal positions, without terminal gaps: dna <- DNAStringSet(c(\"ANGCT-\", \"-ACCT-\")) dna d <- DistanceMatrix(dna, includeTerminalGaps=TRUE) d # d[1,2] now 2 bases 5 = 0.40# gap (\"-\") unknown (\".\") characters interchangeable: dna <- DNAStringSet(c(\"ANGCT.\", \".ACCT-\")) dna d <- DistanceMatrix(dna, includeTerminalGaps=TRUE) d # d[1,2] still 2 bases 5 = 0.40# compare different methods calculating distance: dna <- DNAStringSet(c(\"--ACTG\", \"TGAGT-\")) dna DistanceMatrix(dna, method=\"overlap\") # 1/3 DistanceMatrix(dna, method=\"overlap\",                minCoverage=1) # NA (3/4 overlapping) DistanceMatrix(dna, method=\"shortest\",                includeTerminalGaps=FALSE) # 1/3 DistanceMatrix(dna, method=\"shortest\",                includeTerminalGaps=TRUE) # 2/4 DistanceMatrix(dna, method=\"shortest\",                includeTerminalGaps=TRUE,                penalizeGapLetterMatches=FALSE) # 1/3 DistanceMatrix(dna, method=\"longest\",                includeTerminalGaps=FALSE) # 1/3 DistanceMatrix(dna, method=\"longest\",                includeTerminalGaps=TRUE) # 3/5 DistanceMatrix(dna, method=\"longest\",                includeTerminalGaps=TRUE,                penalizeGapLetterMatches=FALSE) # 1/3# neither internal external gap/gap matches considered: dna <- DNAStringSet(c(\"---CTA\", \"-AG-C--\")) dna DistanceMatrix(dna) # 1/2 DistanceMatrix(dna, includeTerminalGaps=TRUE) # 4/5 DistanceMatrix(dna, includeTerminalGaps=TRUE,                method=\"shortest\") # 2/3 DistanceMatrix(dna, includeTerminalGaps=TRUE,                method=\"longest\") # 3/4 TreeLine Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/ExtractGenes.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Predicted Genes from a Genome — ExtractGenes","title":"Extract Predicted Genes from a Genome — ExtractGenes","text":"Extracts predicted genes genome used prediction.","code":""},{"path":"/reference/ExtractGenes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Predicted Genes from a Genome — ExtractGenes","text":"","code":"ExtractGenes(x, myDNAStringSet, type = \"DNAStringSet\", ...)"},{"path":"/reference/ExtractGenes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Predicted Genes from a Genome — ExtractGenes","text":"x object class Genes. myDNAStringSet DNAStringSet object used generating x. type class sequences return.  (unambiguous abbreviation ) one \"AAStringSet\", \"DNAStringSet\" (default), \"RNAStringSet\". ... parameters passed directly translate.","code":""},{"path":"/reference/ExtractGenes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Predicted Genes from a Genome — ExtractGenes","text":"\"AAStringSet\", \"DNAStringSet\", \"RNAStringSet\" determined type.","code":""},{"path":"/reference/ExtractGenes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract Predicted Genes from a Genome — ExtractGenes","text":"Extracts set gene predictions either DNA, mRNA, proteins.","code":""},{"path":[]},{"path":"/reference/ExtractGenes.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract Predicted Genes from a Genome — ExtractGenes","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/ExtractGenes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Predicted Genes from a Genome — ExtractGenes","text":"","code":"# import a test genome fas <- system.file(\"extdata\",   \"Chlamydia_trachomatis_NC_000117.fas.gz\",   package=\"DECIPHER\") genome <- readDNAStringSet(fas)  x <- FindGenes(genome) #> Iter  Models Start Motif  Init  Fold UpsNt  Term   RBS  Auto  Stop Genes #> 1          1 18.40                 _                                 886 1          1 18.40                 \\                                 886 1          1 18.40                 |                                 886 1          1 18.40                 /                                 886 1          1 18.40                 _                                 886 1          1 18.40                 \\                                 886 1          1 18.40                 |                                 886 1          1 18.40                 /                                 886 1          1 18.40                 _                                 886 2         12 18.40  0.48  0.90                                       888 3         15 18.38  0.53  1.16  0.40  1.41                           890 4         16 15.59  0.52  1.26  0.48  1.76  0.24                     893 5         12 15.62  0.51  1.25  0.48  1.84  0.25  0.98  0.10  0.07   897 6         13 15.61  0.51  1.25  0.49  1.91  0.25  1.05  0.10  0.07   897 7         13 15.59  0.51  1.26  0.50  1.93  0.26  1.01  0.10  0.07   898 8         10 15.59  0.51  1.26  0.52  1.94  0.26  1.04  0.10  0.07   897 9         10 15.59  0.51  1.26  0.51  1.94  0.26  1.06  0.10  0.07   897 #>  #> Time difference of 22.28 secs #>  genes <- ExtractGenes(x, genome) proteins <- ExtractGenes(x, genome, type=\"AAStringSet\")"},{"path":"/reference/FindChimeras.html","id":null,"dir":"Reference","previous_headings":"","what":"Find Chimeras in a Sequence Database — FindChimeras","title":"Find Chimeras in a Sequence Database — FindChimeras","text":"Finds chimeras present database sequences.  Makes use reference database (presumed ) good quality sequences.","code":""},{"path":"/reference/FindChimeras.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find Chimeras in a Sequence Database — FindChimeras","text":"","code":"FindChimeras(   dbFile,   tblName = \"Seqs\",   identifier = \"\",   dbFileReference,   tblNameReference = \"Seqs\",   batchSize = 100,   minNumFragments = 20000,   tb.width = 5,   multiplier = 20,   minLength = 30,   minCoverage = 0.6,   overlap = 100,   minSuspectFragments = 4,   showPercentCoverage = FALSE,   add2tbl = FALSE,   maxGroupSize = -1,   minGroupSize = 25,   excludeIDs = NULL,   processors = 1,   verbose = TRUE )"},{"path":"/reference/FindChimeras.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find Chimeras in a Sequence Database — FindChimeras","text":"dbFile SQLite connection object character string specifying path database file checked chimeric sequences. tblName Character string specifying table check chimeras. identifier Optional character string used narrow search results matching specific identifier.  \"\" identifiers selected. dbFileReference SQLite connection object character string specifying path reference database file (presumed ) good quality sequences.  16S reference database available http://DECIPHER.codes. tblNameReference Character string specifying table reference sequences. batchSize Number sequences tile fragments time. minNumFragments Number suspect fragments accumulate searching groups. tb.width single integer 1..14 giving number nucleotides start fragment part trusted band. multiplier single integer specifying multiple fragments found --group greater fragments found -group order consider sequence chimera. minLength Minimum length chimeric region order considered chimera. minCoverage Minimum fraction coverage necessary chimeric region. overlap Number nucleotides end sequence chimeric region must overlap order considered chimera. minSuspectFragments Minimum number suspect fragments belonging another group required consider sequence chimera. showPercentCoverage Logical indicating whether list percent coverage suspect fragments chimeric region output. add2tbl Logical character string specifying table name add result. maxGroupSize Maximum number sequences searched group.  value less 0 means search unlimited. minGroupSize minimum number sequences group considered part search chimeras.  May need set small value reference databases mostly small groups. excludeIDs Optional character vector identifier(s) exclude database searches, NULL (default) exclude . processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display progress.","code":""},{"path":"/reference/FindChimeras.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find Chimeras in a Sequence Database — FindChimeras","text":"data.frame containing sequences meet specifications chimeric.  chimera column contains information chimeric region group belongs.  row.names data.frame correspond sequences dbFile.","code":""},{"path":"/reference/FindChimeras.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find Chimeras in a Sequence Database — FindChimeras","text":"FindChimeras works finding suspect fragments uncommon group sequence belongs, common another group sequence belong.  sequence dbFile tiled short sequence segments called fragments.  fragments infrequent respective group dbFileReference considered suspect.  enough suspect fragments sequence meet specified constraints sequence flagged chimera. default parameters optimized full-length 16S sequences (> 1,000 nucleotides).  Shorter 16S sequences require two parameters different defaults: minCoverage = 0.2, minSuspectFragments = 2. Groups determined identifier present database.  reason, groups dbFile exist groups dbFileReference.  reference database assumed contain many sequences good quality. reference database present feasible create reference database using input database reference database. Removing chimeras reference database iteratively repeating process can result clean reference database. non-16S sequences may necessary optimize parameters particular sequences.  simplest way perform optimization experiment different input parameters artificial chimeras created using CreateChimeras.  Adjusting input parameters maximum number artificial chimeras identified easiest way determine new defaults.","code":""},{"path":"/reference/FindChimeras.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Find Chimeras in a Sequence Database — FindChimeras","text":"ES Wright et al. (2012) \"DECIPHER: Search-Based Approach Chimera Identification 16S rRNA Sequences.\" Applied Environmental Microbiology, doi:10.1128/AEM.06516-11.","code":""},{"path":[]},{"path":"/reference/FindChimeras.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find Chimeras in a Sequence Database — FindChimeras","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/FindChimeras.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find Chimeras in a Sequence Database — FindChimeras","text":"","code":"db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") # It is necessary to set dbFileReference to the file path of the # 16S reference database available from http://DECIPHER.codes chimeras <- FindChimeras(db, dbFileReference=db) #> ================================================================================ #>  #> No chimeras found. #> Time difference of 0.03 secs #>"},{"path":"/reference/FindGenes.html","id":null,"dir":"Reference","previous_headings":"","what":"Find Genes in a Genome — FindGenes","title":"Find Genes in a Genome — FindGenes","text":"Predicts start stop positions protein coding genes genome.","code":""},{"path":"/reference/FindGenes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find Genes in a Genome — FindGenes","text":"","code":"FindGenes(   myDNAStringSet,   geneticCode = getGeneticCode(\"11\"),   minGeneLength = 60,   includeGenes = NULL,   allowEdges = TRUE,   allScores = FALSE,   showPlot = FALSE,   processors = 1,   verbose = TRUE )"},{"path":"/reference/FindGenes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find Genes in a Genome — FindGenes","text":"myDNAStringSet DNAStringSet object unaligned sequences representing genome. geneticCode named character vector defining translation codons amino acids.  Optionally, \"alt_init_codons\" attribute can used specify alternative initiation codons.  default, bacterial archael genetic code used, seven possible initiation codons: ATG, GTG, TTG, CTG, ATA, ATT, ATC. minGeneLength Integer specifying minimum length genes find genome. includeGenes Genes object include potential genes NULL (default) predict genes de novo. allowEdges Logical determining whether allow genes run edge sequences.  TRUE (default), genes can identified implied starts ends outside boundaries myDNAStringSet, although boundary set last possible codon position.  useful genome sequences circular incomplete. allScores Logical indicating whether return information possible open reading frames predicted genes (default). showPlot Logical determining whether plot displayed distribution gene lengths scores.  (See details section .) processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether print information predictions iteration.  (See details section .)","code":""},{"path":"/reference/FindGenes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find Genes in a Genome — FindGenes","text":"object class Genes.","code":""},{"path":"/reference/FindGenes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find Genes in a Genome — FindGenes","text":"Protein coding genes identified learning characteristic signature directly genome, .e., ab initio prediction.  Gene signatures derived content open reading frame surrounding signals indicate presence gene.  Genes assumed contain introns frame shifts, making function best suited prokaryotic genomes. showPlot TRUE plot displayed four panels. upper left panel shows fitted distribution background open reading frame lengths.  upper right panel shows distribution top fitted distribution predicted gene lengths.  lower left panel shows fitted distribution scores intergenic spacing genes opposite genome strands.  bottom right panel shows total score open reading frames predicted genes length. verbose TRUE, information shown predictions iteration gene finding.  mean score difference genes non-genes updated iteration, unless negative, case score dropped \"-\" displayed.  columns denote number iterations (\"Iter\"), number codon scoring models (\"Models\"), start codon scores (\"Start\"), upstream k-mer motif scores (\"Motif\"), mRNA folding scores (\"Fold\"), initial codon bias scores (\"Init\"), upstream nucleotide bias scores (\"UpsNt\"), termination codon bias scores (\"Term\"), ribosome binding site scores (\"RBS\"), codon autocorrelation scores (\"Auto\"), stop codon scores (\"Stop\"), number predicted genes (\"Genes\").","code":""},{"path":[]},{"path":"/reference/FindGenes.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find Genes in a Genome — FindGenes","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/FindGenes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find Genes in a Genome — FindGenes","text":"","code":"# import a test genome fas <- system.file(\"extdata\",   \"Chlamydia_trachomatis_NC_000117.fas.gz\",   package=\"DECIPHER\") genome <- readDNAStringSet(fas)  z <- FindGenes(genome) #> Iter  Models Start Motif  Init  Fold UpsNt  Term   RBS  Auto  Stop Genes #> 1          1 18.40                 _                                 886 1          1 18.40                 \\                                 886 1          1 18.40                 |                                 886 1          1 18.40                 /                                 886 1          1 18.40                 _                                 886 1          1 18.40                 \\                                 886 1          1 18.40                 |                                 886 1          1 18.40                 /                                 886 1          1 18.40                 _                                 886 2         12 18.40  0.48  0.90                                       888 3         15 18.38  0.53  1.16  0.40  1.41                           891 4         14 15.59  0.51  1.26  0.47  1.75  0.24                     894 5         10 15.64  0.51  1.24  0.48  1.82  0.25  0.97  0.10  0.07   897 6         14 15.62  0.50  1.24  0.50  1.90  0.25  1.06  0.10  0.07   897 7         11 15.61  0.50  1.24  0.50  1.92  0.25  1.05  0.10  0.07   897 8         13 15.60  0.51  1.25  0.49  1.93  0.25  1.07  0.10  0.07   898 9         12 15.60  0.51  1.25  0.51  1.94  0.25  1.06  0.10  0.07   897 10        12 15.60  0.51  1.25  0.51  1.95  0.25  1.08  0.10  0.07   897 11        11 15.59  0.51  1.25  0.49  1.96  0.25  1.09  0.10  0.07   896 12        11 15.59  0.51  1.24  0.51  1.96  0.25  1.10  0.10  0.07   897 13        13 15.59  0.51  1.24  0.51  1.97  0.25  1.07  0.10  0.07   896 14        11 15.58  0.51  1.24  0.52  1.97  0.26  1.13  0.10  0.07   896 15        11 15.58  0.51  1.25  0.50  1.98  0.26  1.12  0.10  0.07   896 16        11 15.58  0.51  1.25  0.51  1.98  0.26  1.15  0.10  0.07   896 #>  #> Time difference of 36.82 secs #>  z #> Genes object of size 896 specifying: #> 896 protein coding genes from 66 to 5,361 nucleotides. #>  #>   Index Strand Begin  End TotalScore ... Gene #> 1     1      0     1 1176      78.51 ...    1 #> 2     1      1  1321 1593      21.37 ...    1 #> 3     1      0  1794 2096      34.37 ...    1 #> 4     1      0  2108 3583     139.65 ...    1 #> 5     1      0  3585 5051     124.72 ...    1 #> 6     1      1  5150 6241      78.55 ...    1 #> ... with 890 more rows. genes <- ExtractGenes(z, genome) genes #> DNAStringSet object of length 896: #>       width seq #>   [1]  1176 GCGGCCGCCCGGGAAATTGCTAAAAGATGGGAG...GGCGTTGGAATAGAGAAGTCGATAGGGAATAA #>   [2]   273 ATGCTTTGTAAAGTTTGTAGAGGATTATCTTCT...GATACCACCACCATCATATGGATAGAGAATAA #>   [3]   303 ATGACAGAGTCATATGTAAACAAAGAAGAAATC...GATTAGTCAAAGTCCCTACAGTTATCAAATAG #>   [4]  1476 ATGTATCGTAAGAGTGCTTTAGAATTAAGAGAT...TGAATGGACTTTTTGACGGAGGAATAGAATAA #>   [5]  1467 ATGGGCATAGCACATACTGAATGGGAGTCTGTG...AATTGCTATTAGCAGCTATGCGAGATATGTAA #>   ...   ... ... #> [892]  3051 ATGCCTTTTTCTTTGAGATCTACATCATTTTGT...TTGTATCCATGGGCTTGAATAGAATCTTTTAA #> [893]   303 ATGCTGGCAACAATTAAAAAAATTACTGTGTTG...GAGATTCTCGCCTAGAATGCAAGAAGATATAA #> [894]  2637 ATGCGACCTGATCATATGAACTTCTGTTGTCTA...CCCTGGATCTGGGGACCACTTACAGGTTCTAG #> [895]    96 ATGTCAAAAAAAAGTAATAATTTACAGACTTTT...ATGAAGAGTTAAGGAAGATTTTTGGATTGTGA #> [896]   600 ATGAGCATCAGGGGAGTAGGAGGCAACGGGAAT...AAGCGAACAAGTTGGCTGGCCCTGACGGGGTA proteins <- ExtractGenes(z, genome, type=\"AAStringSet\") proteins #> AAStringSet object of length 896: #>       width seq #>   [1]   392 AAAREIAKRWEQRVRDLQDKGAARKLLNDPLGR...QVEGILRDMLTNGSQTFRDLMRRWNREVDRE* #>   [2]    91 MLCKVCRGLSSLIVVLGAINTGILGVTGYKVNL...CLNFLKCCFKKRHGDCCSSKGGYHHHHMDRE* #>   [3]   101 MTESYVNKEEIISLAKNAALELEDAHVEEFVTS...DMVTSDFTQEEFLSNVPVSLGGLVKVPTVIK* #>   [4]   492 MYRKSALELRDAVVNRELSVTAITEYFYHRIES...ICQVGYSFQEHSQIKQLYPKAVNGLFDGGIE* #>   [5]   489 MGIAHTEWESVIGLEVHVELNTESKLFSPARNH...GFLVGQIMKRTEGKAPPKRVNELLLAAMRDM* #>   ...   ... ... #> [892]  1017 MPFSLRSTSFCFLACLCSYSYGFASSPQVLTPN...HHFGRAYMNYSLDARRRQTAHFVSMGLNRIF* #> [893]   101 MLATIKKITVLLLSKRKAGIRIDYCALALDAVE...LDASLESAQVRLAGLMLDYWDGDSRLECKKI* #> [894]   879 MRPDHMNFCCLCAAILSSTAVLFGQDPLGETAL...LHRLQTLLNVSYVLRGQSHSYSLDLGTTYRF* #> [895]    32 MSKKSNNLQTFSSRALFHVFQDEELRKIFGL* #> [896]   200 MSIRGVGGNGNSRIPSHNGDGSNRRSQNTKGNN...NLDVNEARLMAAYTSECADHLEANKLAGPDGV"},{"path":"/reference/FindNonCoding.html","id":null,"dir":"Reference","previous_headings":"","what":"Find Non-Coding RNAs in a Genome — FindNonCoding","title":"Find Non-Coding RNAs in a Genome — FindNonCoding","text":"Searches conserved patterns representing family non-coding RNAs. Returns start end boundaries potential matches along log-odds score.","code":""},{"path":"/reference/FindNonCoding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find Non-Coding RNAs in a Genome — FindNonCoding","text":"","code":"FindNonCoding(   x,   myXStringSet,   minScore = 16,   allScores = FALSE,   processors = 1,   verbose = TRUE )"},{"path":"/reference/FindNonCoding.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find Non-Coding RNAs in a Genome — FindNonCoding","text":"x NonCoding object list NonCoding objects searching. myXStringSet DNAStringSet RNAStringSet object unaligned sequences, typically representing genome. minScore Numeric giving minimum log-odds score matches x myXStringSet report, vector numerics specifying minimum score per NonCoding object x.  maximum false discovery rate approximately exp(-minScore) per nucleotide per object x. allScores Logical specifying whether matches returned (TRUE) top matches multiple matches region. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display progress.","code":""},{"path":"/reference/FindNonCoding.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find Non-Coding RNAs in a Genome — FindNonCoding","text":"object class Genes.","code":""},{"path":"/reference/FindNonCoding.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find Non-Coding RNAs in a Genome — FindNonCoding","text":"Non-coding RNAs identified location representative sequence patterns relative beginning end non-coding RNA.  Potential matches NonCoding object x scored based log-odds relative background derived input sequence (myXStringSet).  Matches least minScore returned Genes object \"Gene\" column set negative index list element x identified.","code":""},{"path":"/reference/FindNonCoding.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Find Non-Coding RNAs in a Genome — FindNonCoding","text":"Wright, E. S. (2021). FindNonCoding: rapid simple detection non-coding RNAs genomes. Bioinformatics. https://doi.org/10.1093/bioinformatics/btab708","code":""},{"path":[]},{"path":"/reference/FindNonCoding.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find Non-Coding RNAs in a Genome — FindNonCoding","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/FindNonCoding.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find Non-Coding RNAs in a Genome — FindNonCoding","text":"","code":"data(NonCodingRNA_Bacteria) x <- NonCodingRNA_Bacteria names(x) #>  [1] \"tRNA-Ala\"                             #>  [2] \"tRNA-Arg\"                             #>  [3] \"tRNA-Asn\"                             #>  [4] \"tRNA-Asp\"                             #>  [5] \"tRNA-Cys\"                             #>  [6] \"tRNA-Gln\"                             #>  [7] \"tRNA-Glu\"                             #>  [8] \"tRNA-Gly\"                             #>  [9] \"tRNA-His\"                             #> [10] \"tRNA-Ile\"                             #> [11] \"tRNA-Leu\"                             #> [12] \"tRNA-Lys\"                             #> [13] \"tRNA-Met\"                             #> [14] \"tRNA-Phe\"                             #> [15] \"tRNA-Pro\"                             #> [16] \"tRNA-Ser\"                             #> [17] \"tRNA-Thr\"                             #> [18] \"tRNA-Trp\"                             #> [19] \"tRNA-Tyr\"                             #> [20] \"tRNA-Val\"                             #> [21] \"tRNA-Sec\"                             #> [22] \"rRNA_5S-RF00001\"                      #> [23] \"rRNA_16S-RF00177\"                     #> [24] \"rRNA_23S-RF02541\"                     #> [25] \"tmRNA-RF00023\"                        #> [26] \"tmRNA_Alpha-RF01849\"                  #> [27] \"RNase_P_class_A-RF00010\"              #> [28] \"RNase_P_class_B-RF00011\"              #> [29] \"SsrS-RF00013\"                         #> [30] \"Intron_Gp_I-RF00028\"                  #> [31] \"Intron_Gp_II-RF00029\"                 #> [32] \"SmallSRP-RF00169\"                     #> [33] \"Cyclic-di-GMP_Riboswitch-RF01051\"     #> [34] \"Cyclic-di-AMP_Riboswitch-RF00379\"     #> [35] \"T-box_Leader-RF00230\"                 #> [36] \"Ribosomal_Protein_L10_Leader-RF00557\" #> [37] \"Cobalamin_Riboswitch-RF00174\"         #> [38] \"TPP_Riboswitch-RF00059\"               #> [39] \"SAM_Riboswitch-RF00162\"               #> [40] \"Fluoride_Riboswitch-RF01734\"          #> [41] \"FMN_Riboswitch-RF00050\"               #> [42] \"Glycine_Riboswitch-RF00504\"           #> [43] \"HEARO-RF02033\"                        #> [44] \"Flavo_1-RF01705\"                      #> [45] \"Acido_Lenti_1-RF01687\"                #> [46] \"5'_ureB-RF02514\"                       # import a test genome fas <- system.file(\"extdata\",   \"Chlamydia_trachomatis_NC_000117.fas.gz\",   package=\"DECIPHER\") genome <- readDNAStringSet(fas)  z <- FindNonCoding(x, genome) #> ================================================================================ #>  #> Time difference of 39.6 secs z #> Genes object of size 46 specifying: #> 46 non-coding RNAs from 72 to 2,938 nucleotides. #>  #>   Index Strand  Begin    End TotalScore Gene #> 1     1      1  20663  21082      88.33  -25 #> 2     1      1  42727  42801      69.94   -3 #> 3     1      1  68920  68995      78.62  -15 #> 4     1      0 158662 158736      55.75  -17 #> 5     1      0 158744 158827      52.31  -19 #> 6     1      1 202339 202414      68.64  -10 #> ... with 40 more rows.  annotations <- attr(z, \"annotations\") m <- match(z[, \"Gene\"], annotations) sort(table(names(annotations)[m])) #>  #> RNase_P_class_A-RF00010        SmallSRP-RF00169                tRNA-Asn  #>                       1                       1                       1  #>                tRNA-Asp                tRNA-Cys                tRNA-Gln  #>                       1                       1                       1  #>                tRNA-Glu                tRNA-His                tRNA-Ile  #>                       1                       1                       1  #>                tRNA-Lys                tRNA-Phe                tRNA-Trp  #>                       1                       1                       1  #>                tRNA-Tyr           tmRNA-RF00023        rRNA_16S-RF00177  #>                       1                       1                       2  #>        rRNA_23S-RF02541         rRNA_5S-RF00001                tRNA-Ala  #>                       2                       2                       2  #>                tRNA-Gly                tRNA-Pro                tRNA-Val  #>                       2                       2                       2  #>                tRNA-Arg                tRNA-Met                tRNA-Thr  #>                       3                       3                       3  #>                tRNA-Ser                tRNA-Leu  #>                       4                       5   genes <- ExtractGenes(z, genome, type=\"RNAStringSet\") genes #> RNAStringSet object of length 46: #>      width seq #>  [1]   420 GGGGGUGUAAAGGUUUCGACUUAGAAAUGAAGC...AGGACGAGAGUUCGACUCUCUCCACCUCCAUAG #>  [2]    75 UCCGGAGUAGCUCAGCGGUAGAGCAGUGGACUG...UGGUCGUUGGUUCGAACCCAUCCUCCGGAGUCU #>  [3]    76 CGGAGUAUAGCGCAGCCUGGUUAGCGCGGUUGC...AUAGGUCGGGGGUUCGAAUCCCUCUACUCCGAU #>  [4]    75 GCUGGAGUAGCUCAAUUGGCAGAGCAUUCGAUU...ACGGUUGAGGGUUCAAUUCCUUUCUCCAGCAUC #>  [5]    84 GGGGGUGUCGCAUAGCGGUCAAUUGCAUCGGAC...CGGAUACGUUGGUUCAAAUCCAGCCACCCCCAG #>  ...   ... ... #> [42]    72 GGUGGCAUCGCCAAGCGGUAAGGCCGAGGCCUG...CUCUAUCCCCGGUUCGAUUCCGGGUGCCACCUU #> [43]    74 UGGGGUGUGGCCAAGCGGUAAGGCAGCGGUUUU...CGCAUCGGAGGUUCGAAUCCUUCCACCCCAGAG #> [44]    75 GGGGUAUUAGCUCAGUUGGUUAGAGCGUCACGU...GAAGGUCAGCUGUUCAAGUCAGCUAUAUCCCAA #> [45]    88 GGAAGAAUGGCAGAGCGGUUUAAUGCACCUGUC...GGUCCGGGGGUUCGAAUCCCUCUUCUUCCGCAU #> [46]    85 GCCCAGGUGGUGAAAUUGGUAGACACGCUGGAU...GGCAUGUAGGUUCAAGUCCUAUCCUGGGCAUAG"},{"path":"/reference/FindSynteny.html","id":null,"dir":"Reference","previous_headings":"","what":"Finds Synteny in a Sequence Database — FindSynteny","title":"Finds Synteny in a Sequence Database — FindSynteny","text":"Finds syntenic blocks groups sequences database.","code":""},{"path":"/reference/FindSynteny.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finds Synteny in a Sequence Database — FindSynteny","text":"","code":"FindSynteny(   dbFile,   tblName = \"Seqs\",   identifier = \"\",   useFrames = TRUE,   alphabet = AA_REDUCED[[1]],   geneticCode = GENETIC_CODE,   sepCost = 0,   gapCost = -0.01,   shiftCost = 0,   codingCost = 0,   maxSep = 2000,   maxGap = 5000,   minScore = 30,   dropScore = -100,   maskRepeats = TRUE,   allowOverlap = TRUE,   storage = 0.5,   processors = 1,   verbose = TRUE )"},{"path":"/reference/FindSynteny.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finds Synteny in a Sequence Database — FindSynteny","text":"dbFile SQLite connection object character string specifying path database file. tblName Character string specifying table sequences located. identifier Optional character string used narrow search results matching specific identifier.  \"\" identifiers selected.  Repeated identifiers find synteny sequence , blocking identical positions matching sequences. useFrames Logical specifying whether use 6-frame amino acid translations help find distant hits.  Using alphabet helpful genome largely composed coding DNA.  FALSE faster less sensitive distant homology. alphabet Character vector amino acid groupings used reduce 20 standard amino acids smaller groups.  Alphabet reduction helps find distant homologies sequences.  non-reduced amino acid alphabet can used setting alphabet equal AA_STANDARD. geneticCode Either character vector giving genetic code use translation, list containing one genetic code identifier. list provided must named corresponding identifiers database. sepCost Cost per nucleotide separation hits apply chaining hits blocks. gapCost Cost gaps hits apply chaining hits blocks. shiftCost Cost shifting different reading frames chaining reduced amino acid hits blocks. codingCost Cost switching coding non-coding hits chaining hits blocks. maxSep Maximal separation (nucleotides) hits block. maxGap maximum number gaps hits block. minScore minimum score required chain hits become block.  Higher values minScore less likely yield false positives. dropScore change maximal score required stop extending blocks. maskRepeats Logical specifying whether ``soft'' mask repeats searching hits. allowOverlap Logical specifying whether permit blocks overlap sequence. storage Excess gigabytes available store objects need recomputed later steps.  number zero (modest) fraction available system memory.  Note storage gigabytes may required, stored later reuse. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display progress.","code":""},{"path":"/reference/FindSynteny.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finds Synteny in a Sequence Database — FindSynteny","text":"object class ``Synteny''.","code":""},{"path":"/reference/FindSynteny.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finds Synteny in a Sequence Database — FindSynteny","text":"Long nucleotide sequences, genomes, often collinear may composed many smaller segments (e.g., contigs).  FindSynteny searches hits'' sequences can chained collinear blocks'' synteny.  Hits defined k-mer exact nucleotide matches k-mer matches reduced amino acid alphabet (useFrames TRUE).  Hits chained blocks long : (1) within sequence, (2) within maxSep maxGap distance, (3) help maintain score minScore.  Blocks extended first last hit score drops dropScore maximum reached.  process results set hits blocks stored object class ``Synteny''.","code":""},{"path":"/reference/FindSynteny.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Finds Synteny in a Sequence Database — FindSynteny","text":"FindSynteny intended used sets sequences ~100 million nucleotides total per identifier.  reason, better performance can sometimes achieved assigning unique identifier chromosome belonging large genome.","code":""},{"path":[]},{"path":"/reference/FindSynteny.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finds Synteny in a Sequence Database — FindSynteny","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/FindSynteny.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finds Synteny in a Sequence Database — FindSynteny","text":"","code":"db <- system.file(\"extdata\", \"Influenza.sqlite\", package=\"DECIPHER\") synteny <- FindSynteny(db) #> ================================================================================ #>  #> Time difference of 0.42 secs #>  synteny #>          H9N2     H5N1     H2N2     H7N9     H1N1 #> H9N2   8 seqs 74% hits 78% hits 76% hits 73% hits #> H5N1 8 blocks   8 seqs 70% hits 74% hits 84% hits #> H2N2 8 blocks 8 blocks   8 seqs 73% hits 71% hits #> H7N9 8 blocks 8 blocks 8 blocks   8 seqs 74% hits #> H1N1 8 blocks 8 blocks 8 blocks 8 blocks   8 seqs pairs(synteny) # scatterplot matrix"},{"path":"/reference/FormGroups.html","id":null,"dir":"Reference","previous_headings":"","what":"Forms Groups By Rank — FormGroups","title":"Forms Groups By Rank — FormGroups","text":"Agglomerates sequences groups within specified size range based taxonomic rank.","code":""},{"path":"/reference/FormGroups.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forms Groups By Rank — FormGroups","text":"","code":"FormGroups(   dbFile,   tblName = \"Seqs\",   goalSize = 50,   minGroupSize = 25,   maxGroupSize = 5000,   includeNames = FALSE,   add2tbl = FALSE,   verbose = TRUE )"},{"path":"/reference/FormGroups.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Forms Groups By Rank — FormGroups","text":"dbFile SQLite connection object character string specifying path database file. tblName Character string specifying table rank information located. goalSize Number sequences required group stop adding sequences. minGroupSize Minimum number sequences group required stop trying recombine larger group. maxGroupSize Maximum number sequences group allowed continue agglomeration. includeNames Logical indicating whether include formal scientific name group name. add2tbl Logical character string specifying table name add result. verbose Logical indicating whether display progress.","code":""},{"path":"/reference/FormGroups.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Forms Groups By Rank — FormGroups","text":"data.frame rank corresponding group name identifier.  Note quotes stripped group names prevent problems may cause.  origin gives rank preceding identifier.  count denotes number sequences corresponding rank.  add2tbl FALSE identifier'' origin'' columns updated dbFile.","code":""},{"path":"/reference/FormGroups.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Forms Groups By Rank — FormGroups","text":"FormGroups uses ``rank'' field dbFile table group sequences similar taxonomic rank.  Rank information must present tblName, created default importing sequences GenBank formatted file. Rank information contains formal scientific name first line, followed taxonomic lineage subsequent lines.  includeNames TRUE formal scientific name appended end group name, otherwise taxonomic lineage used group name. algorithm ascends taxonomic tree, agglomerating taxa groups goalSize reached.  group size minGroupSize agglomeration attempted larger group.  additional agglomeration results group larger maxGroupSize agglomeration undone group smaller.  Setting minGroupSize goalSize avoids creation polyphyletic groups.  Note approach may often result paraphyletic groups.","code":""},{"path":[]},{"path":"/reference/FormGroups.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Forms Groups By Rank — FormGroups","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/FormGroups.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Forms Groups By Rank — FormGroups","text":"","code":"db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") g <- FormGroups(db, goalSize=10, minGroupSize=5, maxGroupSize=20) #> ================================================================================ #> Formed 14 distinct groups. #> Time difference of 0.01 secs #>  head(g) #>                                                                                                                                                       rank #> 15                                               uncultured bacterium\\nRoot; Bacteria; \"Firmicutes\"; \"Bacilli\"; Bacillales; Bacillaceae; \\nLysinibacillus. #> 46                                       uncultured bacterium\\nRoot; Bacteria; \"Firmicutes\"; \"Bacilli\"; Bacillales; \\n\"Staphylococcaceae\"; Staphylococcus. #> 14                                uncultured bacterium\\nRoot; Bacteria; \"Firmicutes\"; \"Bacilli\"; \"Lactobacillales\"; \\n\"Carnobacteriaceae\"; Dolosigranulum. #> 16                 uncultured bacterium\\nRoot; Bacteria; \"Firmicutes\"; \"Clostridia\"; Clostridiales; \\nPeptococcaceae; Peptococcaceae 1; Desulfosporosinus. #> 58 uncultured bacterium\\nRoot; Bacteria; \"Firmicutes\"; \"Erysipelotrichi\"; \\n\"Erysipelotrichales\"; Erysipelotrichaceae; \\nunclassified_Erysipelotrichaceae. #> 52                            uncultured bacterium\\nRoot; Bacteria; \"Bacteroidetes\"; \"Bacteroidia\"; \"Bacteroidales\"; \\n\"Porphyromonadaceae\"; Dysgonomonas. #>    count        origin      identifier #> 15     1 Root;Bacteria    _Firmicutes_ #> 46     2 Root;Bacteria    _Firmicutes_ #> 14     1 Root;Bacteria    _Firmicutes_ #> 16     1 Root;Bacteria    _Firmicutes_ #> 58     4 Root;Bacteria    _Firmicutes_ #> 52     3 Root;Bacteria _Bacteroidetes_ tapply(g$count, g$identifier, sum) #>               Alphaproteobacteria                          Bacteria  #>                                12                                13  #>                Betaproteobacteria               Gammaproteobacteria  #>                                20                                16  #>                 Hyphomicrobiaceae                    Mycobacterium_  #>                                 7                                22  #>                   Pseudomonadales                       Rhizobiales  #>                                 9                                15  #>                 Sphingomonadaceae                     Sphingomonas_  #>                                13                                 9  #>                   _Bacteroidetes_                      _Firmicutes_  #>                                18                                 9  #>                      _Nitrospira_ unclassified_Alphaproteobacteria_  #>                                 5                                 7"},{"path":"/reference/Genes.html","id":null,"dir":"Reference","previous_headings":"","what":"Genes objects and accessors — Genes","title":"Genes objects and accessors — Genes","text":"Gene prediction consist delimiting boundaries regions function genes within genome.  Class Genes provides objects functions storing boundaries genes associated information resulting gene prediction. Gene prediction consist delimiting boundaries regions function genes within genome.  Class Genes provides objects functions storing boundaries genes associated information resulting gene prediction.","code":""},{"path":"/reference/Genes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Genes objects and accessors — Genes","text":"x object class Genes. xlim Numeric vector length 2 specifying x-axis limits plotting. ylim Numeric vector length 2 specifying y-axis limits plotting. interact Logical determining whether plot interactive.  TRUE, clicking plot right left side scroll one frame direction.  end interaction, either right-click, press escape key, press stop button depending graphics device use. colorBy Character string indicating name column x used coloring.  Unambiguous abbreviations also permitted. colorRamp function return n colors given number n.  Examples rainbow, heat.colors, terrain.colors, cm.colors, (default) colorRampPalette. colorGenes Character string specifying color genes, NA color genes according colorBy. Numeric character vector row indices extract x. j Numeric character vector column indices extract x.  j missing, columns included returned object also belong class Genes. ... optional parameters.","code":""},{"path":"/reference/Genes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Genes objects and accessors — Genes","text":"Objects class Genes stored numeric matrices containing information pertaining gene predictions.  matrix columns include index (\"Index\") corresponding sequence original genome, strand (\"Strand\") gene located (either \"+\" (0) \"-\" (1), beginning (\"Begin\") ending (\"End\") positions gene, scores acquired prediction, whether (!= 0) (0) region predicted gene.  Note start gene beginning position strand \"+\" end strand \"-\".  convention, rows negative values \"Gene\" column represent non-coding RNAs rows positive values represent protein coding genes. plot method show total score prediction along genome.  useful displaying result setting allScores TRUE FindGenes.  , possible genes either strand shown (default), predicted genes highlighted.  beginning (solid) ending (dashed) positions denoted vertical lines.  Note x-axis cumulative genome position, changes genome sequences indices demarcated dashed vertical lines. Objects class Genes stored numeric matrices containing information pertaining gene predictions.  matrix columns include index (\"Index\") corresponding sequence original genome, strand (\"Strand\") gene located (either \"+\" (0) \"-\" (1), beginning (\"Begin\") ending (\"End\") positions gene, scores acquired prediction, whether (!= 0) (0) region predicted gene.  Note start gene beginning position strand \"+\" end strand \"-\".  convention, rows negative values \"Gene\" column represent non-coding RNAs rows positive values represent protein coding genes. plot method show total score prediction along genome.  useful displaying result setting allScores TRUE FindGenes.  , possible genes either strand shown (default), predicted genes highlighted.  beginning (solid) ending (dashed) positions denoted vertical lines.  Note x-axis cumulative genome position, changes genome sequences indices demarcated dashed vertical lines.","code":""},{"path":[]},{"path":"/reference/Genes.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Genes objects and accessors — Genes","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/Genes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Genes objects and accessors — Genes","text":"","code":"# import a test genome fas <- system.file(\"extdata\",   \"Chlamydia_trachomatis_NC_000117.fas.gz\",   package=\"DECIPHER\") genome <- readDNAStringSet(fas)  x <- FindGenes(genome, allScores=TRUE) #> Iter  Models Start Motif  Init  Fold UpsNt  Term   RBS  Auto  Stop Genes #> 1          1 18.40                 _                                 886 1          1 18.40                 \\                                 886 1          1 18.40                 |                                 886 1          1 18.40                 /                                 886 1          1 18.40                 _                                 886 1          1 18.40                 \\                                 886 1          1 18.40                 |                                 886 1          1 18.40                 /                                 886 1          1 18.40                 _                                 886 2         12 18.40  0.48  0.90                                       888 3         15 18.38  0.53  1.16  0.42  1.41                           891 4         14 15.59  0.51  1.26  0.46  1.77  0.24                     894 5         12 15.62  0.52  1.25  0.49  1.83  0.25  0.94  0.10  0.07   897 6         11 15.60  0.50  1.25  0.50  1.93  0.25  1.04  0.10  0.07   897 7         10 15.59  0.51  1.25  0.52  1.94  0.25  1.06  0.10  0.07   898 8         10 15.59  0.51  1.25  0.52  1.94  0.25  1.08  0.10  0.07   898 #>  #> Time difference of 19.02 secs #>  x #> Genes object of size 109,490 specifying: #> 898 protein coding genes from 66 to 5,361 nucleotides. #> 108,592 open reading frames from 60 to 5,370 nucleotides. #>  #>   Index Strand Begin  End TotalScore ... Gene #> 1     1      0     1 1176      78.90 ...    1 #> 2     1      0     2   82      -4.67 ...    0 #> 3     1      0    16 1176      62.19 ...    0 #> 4     1      0    17   82      -8.70 ...    0 #> 5     1      1    41  106     -13.67 ...    0 #> 6     1      1    91  150     -35.32 ...    0 #> ... with 109,484 more rows. head(unclass(x)) # the underlying structure #>   Index Strand Begin  End TotalScore LengthScore CodingScore CodonModel #> 1     1      0     1 1176  78.896062   39.250137  40.9557100          1 #> 2     1      0     2   82  -4.673275   -4.161170  -1.0159291          1 #> 3     1      0    16 1176  62.189206   38.692159  40.2579864          1 #> 4     1      0    17   82  -8.695409   -4.861395  -0.6626534          1 #> 5     1      1    41  106 -13.674990   -4.861395  -3.0677958          1 #> 6     1      1    91  150 -35.318056   -5.168009  -6.5484587          1 #>   CouplingScore StartScore StopScore InitialCodonScore TerminationCodonScore #> 1     2.9008621   0.000000 0.1885137       -3.91891306             -0.370162 #> 2    -0.2562897   0.000000 0.1885137       -0.17878686              0.610945 #> 3     2.7390739 -19.703580 0.1885137        0.40581566             -0.370162 #> 4    -0.1513470  -3.944274 0.1885137        0.05046972              0.610945 #> 5    -0.1810210   0.528316 0.1885137       -2.53725635             -1.036936 #> 6    -0.1681282 -19.703580 0.1885137       -0.54743562              1.334340 #>   RibosomeBindingSiteScore AutocorrelationScore UpstreamNucleotideScore #> 1                 0.000000          -0.11008592                0.000000 #> 2                 0.000000           0.13944140                0.000000 #> 3                 0.000000          -0.02060062                0.000000 #> 4                 0.000000           0.07433219                0.000000 #> 5                -1.167263           0.25905937               -1.275122 #> 6                -1.167263          -0.09438568               -1.804918 #>   UpstreamMotifScore FoldingScore FractionReps Gene #> 1          0.0000000    0.0000000            1    1 #> 2          0.0000000    0.0000000            0    0 #> 3          0.0000000    0.0000000            0    0 #> 4          0.0000000    0.0000000            0    0 #> 5         -0.5240908    0.0000000            0    0 #> 6         -1.3502303   -0.2885014            0    0  plot(x) # default coloring by \"Strand\"  # color by RBS score (blue is weak/low, red is strong/high) plot(x, colorBy=\"RibosomeBindingSiteScore\", colorGenes=NA)  # color by fraction of times a gene was chosen plot(x, colorBy=\"FractionReps\", colorGenes=NA)  # color by which codon model was selected for each ORF plot(x, colorBy=\"CodonModel\", xlim=c(1, 3e4))     # import a test genome fas <- system.file(\"extdata\",   \"Chlamydia_trachomatis_NC_000117.fas.gz\",   package=\"DECIPHER\") genome <- readDNAStringSet(fas)  x <- FindGenes(genome, allScores=TRUE) #> Iter  Models Start Motif  Init  Fold UpsNt  Term   RBS  Auto  Stop Genes #> 1          1 18.40                 _                                 886 1          1 18.40                 \\                                 886 1          1 18.40                 |                                 886 1          1 18.40                 /                                 886 1          1 18.40                 _                                 886 1          1 18.40                 \\                                 886 1          1 18.40                 |                                 886 1          1 18.40                 /                                 886 1          1 18.40                 _                                 886 2         12 18.40  0.48  0.90                                       888 3         15 18.38  0.53  1.16  0.39  1.41                           892 4         12 15.59  0.52  1.27  0.47  1.74  0.24                     893 5         10 15.64  0.52  1.24  0.45  1.82  0.25  0.97  0.10  0.07   895 6         12 15.63  0.51  1.23  0.49  1.90  0.25  1.06  0.10  0.07   895 7         12 15.62  0.51  1.23  0.49  1.92  0.25  1.06  0.10  0.07   896 8         11 15.61  0.51  1.23  0.52  1.94  0.25  1.10  0.10  0.07   895 9         12 15.60  0.51  1.22  0.51  1.96  0.26  1.07  0.10  0.07   897 10        12 15.59  0.51  1.22  0.50  1.97  0.26  1.05  0.10  0.07   896 11        13 15.59  0.52  1.23  0.49  1.97  0.26  1.06  0.10  0.07   896 12        12 15.59  0.52  1.23  0.52  1.98  0.26  1.03  0.10  0.07   896 13        12 15.59  0.52  1.23  0.52  1.98  0.26  1.09  0.10  0.07   896 #>  #> Time difference of 30.22 secs #>  x #> Genes object of size 109,490 specifying: #> 896 protein coding genes from 66 to 5,361 nucleotides. #> 108,594 open reading frames from 60 to 5,370 nucleotides. #>  #>   Index Strand Begin  End TotalScore ... Gene #> 1     1      0     1 1176      79.07 ...    1 #> 2     1      0     2   82      -4.53 ...    0 #> 3     1      0    16 1176      62.26 ...    0 #> 4     1      0    17   82      -8.95 ...    0 #> 5     1      1    41  106     -13.09 ...    0 #> 6     1      1    91  150     -35.05 ...    0 #> ... with 109,484 more rows. head(unclass(x)) # the underlying structure #>   Index Strand Begin  End TotalScore LengthScore CodingScore CodonModel #> 1     1      0     1 1176  79.069699   39.230301  40.7334879          1 #> 2     1      0     2   82  -4.533781   -4.192193  -0.9715666          1 #> 3     1      0    16 1176  62.263684   38.672572  40.0151986          1 #> 4     1      0    17   82  -8.952250   -4.894312  -0.6326839          1 #> 5     1      1    41  106 -13.090648   -4.894312  -3.0879852          1 #> 6     1      1    91  150 -35.048788   -5.201787  -6.4858756          1 #>   CouplingScore  StartScore StopScore InitialCodonScore TerminationCodonScore #> 1     3.1397201   0.0000000 0.1898898       -3.89030859            -0.3730247 #> 2    -0.2586311   0.0000000 0.1898898       -0.07510064             0.6148295 #> 3     2.9740883 -19.6716490 0.1898898        0.32498452            -0.3730247 #> 4    -0.1510043  -4.0150440 0.1898898       -0.13867805             0.6148295 #> 5    -0.1940904   0.5153314 0.1898898       -2.44678725            -0.9703715 #> 6    -0.1509718 -19.6716490 0.1898898       -0.52640259             1.3314561 #>   RibosomeBindingSiteScore AutocorrelationScore UpstreamNucleotideScore #> 1                0.0000000           0.03963315                0.000000 #> 2                0.0000000           0.15899120                0.000000 #> 3                0.0000000           0.13162499                0.000000 #> 4                0.0000000           0.07475257                0.000000 #> 5               -0.7202308           0.26030898               -1.222000 #> 6               -1.0253225          -0.05973201               -1.814188 #>   UpstreamMotifScore FoldingScore FractionReps Gene #> 1          0.0000000    0.0000000            1    1 #> 2          0.0000000    0.0000000            0    0 #> 3          0.0000000    0.0000000            0    0 #> 4          0.0000000    0.0000000            0    0 #> 5         -0.5204004    0.0000000            0    0 #> 6         -1.3239635   -0.3102414            0    0  plot(x) # default coloring by \"Strand\"  # color by RBS score (blue is weak/low, red is strong/high) plot(x, colorBy=\"RibosomeBindingSiteScore\", colorGenes=NA)  # color by fraction of times a gene was chosen plot(x, colorBy=\"FractionReps\", colorGenes=NA)  # color by which codon model was selected for each ORF plot(x, colorBy=\"CodonModel\", xlim=c(1, 3e4))"},{"path":"/reference/HEC_MI.html","id":null,"dir":"Reference","previous_headings":"","what":"Mutual Information for Protein Secondary Structure Prediction — HEC_MI","title":"Mutual Information for Protein Secondary Structure Prediction — HEC_MI","text":"Arrays containing values mutual information single residues (HEC_MI1) pairs residues (HEC_MI2) located within 10 residues position predicted (position \"0\").  arrays dimensions corresponding 20 (standard) amino acids, positions (-10 10), states (helix (\"H\"), sheet (\"E\"), coil (\"C\")).","code":""},{"path":"/reference/HEC_MI.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Mutual Information for Protein Secondary Structure Prediction — HEC_MI","text":"format HEC_MI1 : num 1:20, 1:21, 1:3 0.04264 -0.00117 0.02641 0.08264 -0.04876 ...  - attr(*, \"dimnames\")=List 3 ..$ : chr 1:20 \"\" \"R\" \"N\" \"D\" ...  ..$ : chr 1:21 \"-10\" \"-9\" \"-8\" \"-7\" ...  ..$ : chr 1:3 \"H\" \"E\" \"C\" format HEC_MI2 : num 1:20, 1:20, 1:21, 1:21, 1:3 2.56 -Inf -Inf -Inf -Inf ...  - attr(*, \"dimnames\")=List 5 ..$ : chr 1:20 \"\" \"R\" \"N\" \"D\" ...  ..$ : chr 1:20 \"\" \"R\" \"N\" \"D\" ...  ..$ : chr 1:21 \"-10\" \"-9\" \"-8\" \"-7\" ...  ..$ : chr 1:21 \"-10\" \"-9\" \"-8\" \"-7\" ...  ..$ : chr 1:3 \"H\" \"E\" \"C\"","code":""},{"path":"/reference/HEC_MI.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Mutual Information for Protein Secondary Structure Prediction — HEC_MI","text":"values matrix derived based set 15,201 proteins ASTRAL Compendium (Chandonia, 2004).  8-states assigned Dictionary Protein Secondary Structure (DSSP) reduced 3-states via H = G, H, ; E = E; C = B, S, C, T.","code":""},{"path":"/reference/HEC_MI.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Mutual Information for Protein Secondary Structure Prediction — HEC_MI","text":"Chandonia, J. M. (2004). ASTRAL Compendium 2004. Nucleic Acids Research, 32(90001), 189D-192. doi:10.1093/nar/gkh034.","code":""},{"path":"/reference/HEC_MI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mutual Information for Protein Secondary Structure Prediction — HEC_MI","text":"","code":"data(HEC_MI1) # the contribution of an arginine (\"R\") # located 3 residues left of center # to a helical (\"H\") state at the center HEC_MI1[\"R\", \"-3\", \"H\"] #> [1] 0.0525285  data(HEC_MI2) # the contribution of arginine and lysine (\"K\") # located at positions -1 and +1, respectively # to a coil (\"C\") state at the center position HEC_MI2[\"R\", \"K\", \"-1\", \"1\", \"C\"] #> [1] -0.2300684  matplot(-10:10, t(HEC_MI1[,, \"H\"]),        type=\"l\", col=1:8, lty=rep(1:3, each=8),        xlab=\"Amino Acid Position Relative to Center\",        ylab=\"Log-Odds of Helix at Center Position\") legend(\"bottomleft\",        lwd=1, col=1:8, lty=rep(1:3, each=8),        legend=dimnames(HEC_MI1)[[1]], ncol=2)"},{"path":"/reference/IdConsensus.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Consensus Sequences by Groups — IdConsensus","title":"Create Consensus Sequences by Groups — IdConsensus","text":"Forms consensus sequence representing sequences group.","code":""},{"path":"/reference/IdConsensus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Consensus Sequences by Groups — IdConsensus","text":"","code":"IdConsensus(   dbFile,   tblName = \"Seqs\",   identifier = \"\",   type = \"DNAStringSet\",   colName = \"identifier\",   processors = 1,   verbose = TRUE,   ... )"},{"path":"/reference/IdConsensus.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Consensus Sequences by Groups — IdConsensus","text":"dbFile SQLite connection object character string specifying path database file. tblName Character string specifying table form consensus. identifier Optional character string used narrow search results matching specific identifier.  \"\" identifiers selected. type type XStringSet (sequences) use forming consensus.  (abbreviation ) one \"DNAStringSet\", \"RNAStringSet\", \"AAStringSet\", \"BStringSet\". colName Column containing group name sequence. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display progress. ... Additional arguments passed directly ConsensusSequence AAStringSet, DNAStringSet, RNAStringSet, consensusString BStringSet.","code":""},{"path":"/reference/IdConsensus.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Consensus Sequences by Groups — IdConsensus","text":"XStringSet object containing consensus sequence group.  names XStringSet contain number sequences name group.","code":""},{"path":"/reference/IdConsensus.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Consensus Sequences by Groups — IdConsensus","text":"Creates consensus sequence distinct groups defined colName.  resulting XStringSet contains many consensus sequences distinct groups colName.  example, possible create set consensus sequences one consensus sequence \"id\" tblName.","code":""},{"path":[]},{"path":"/reference/IdConsensus.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create Consensus Sequences by Groups — IdConsensus","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/IdConsensus.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Consensus Sequences by Groups — IdConsensus","text":"","code":"db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") con <- IdConsensus(db, colName=\"identifier\", noConsensusChar=\"N\") #> ================================================================================ #>  #> Found consensus for 44 groups. #> Time difference of 0.18 secs #>  BrowseSeqs(con)"},{"path":"/reference/IdLengths.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine the Number of Characters in Each Sequence — IdLengths","title":"Determine the Number of Characters in Each Sequence — IdLengths","text":"Counts number standard non-standard characters sequence.","code":""},{"path":"/reference/IdLengths.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine the Number of Characters in Each Sequence — IdLengths","text":"","code":"IdLengths(   dbFile,   tblName = \"Seqs\",   type = \"DNAStringSet\",   add2tbl = FALSE,   batchSize = 10000,   processors = 1,   verbose = TRUE )"},{"path":"/reference/IdLengths.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine the Number of Characters in Each Sequence — IdLengths","text":"dbFile SQLite connection object character string specifying path database file. tblName Character string specifying table sequences located. type type XStringSet processed.  (abbreviation ) one \"AAStringSet\", \"DNAStringSet\", \"RNAStringSet\". add2tbl Logical character string specifying table name add result. batchSize Integer specifying number sequences process time. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display progress.","code":""},{"path":"/reference/IdLengths.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine the Number of Characters in Each Sequence — IdLengths","text":"data.frame number standard characters, nonstandard characters, width sequence.  row.names data.frame correspond \"row_names\" tblName dbFile.","code":""},{"path":"/reference/IdLengths.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Determine the Number of Characters in Each Sequence — IdLengths","text":"IdLengths designed efficiently determine number standard non-standard characters every sequence within database.  Standard non-standard characters defined respect type sequences.  DNA RNA sequences four standard characters 11 non-standard characters (.e., ambiguity codes).  amino acid sequences 20 standard seven non-standard characters (including stops).  Gap (-''), missing (.''), mask (``+'') characters count toward width number standard non-standard characters.","code":""},{"path":"/reference/IdLengths.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Determine the Number of Characters in Each Sequence — IdLengths","text":"ES Wright (2016) \"Using DECIPHER v2.0 Analyze Big Biological Sequence Data R\". R Journal, 8(1), 352-359.","code":""},{"path":[]},{"path":"/reference/IdLengths.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Determine the Number of Characters in Each Sequence — IdLengths","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/IdLengths.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine the Number of Characters in Each Sequence — IdLengths","text":"","code":"db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") l <- IdLengths(db) #> ================================================================================ #> Lengths counted for 175 sequences. #>  #> Time difference of 0.01 secs #>  head(l) #>   standard nonstandard width #> 1     1222          13  1596 #> 2     1346           5  1596 #> 3     1323           3  1596 #> 4     1337           8  1596 #> 5     1318          25  1596 #> 6     1307           7  1596"},{"path":[]},{"path":"/reference/IdTaxa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign Sequences a Taxonomic Classification — IdTaxa","text":"","code":"IdTaxa(   test,   trainingSet,   type = \"extended\",   strand = \"both\",   threshold = 60,   bootstraps = 100,   samples = L^0.47,   minDescend = 0.98,   fullLength = 0,   processors = 1,   verbose = TRUE )"},{"path":"/reference/IdTaxa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assign Sequences a Taxonomic Classification — IdTaxa","text":"test AAStringSet, DNAStringSet, RNAStringSet unaligned sequences. trainingSet object class Taxa subclass Train compatible class test. type Character string indicating type output desired.  (abbreviation ) one \"extended\" \"collapsed\".  (See value section .) strand Character string indicating orientation test sequences relative trainingSet.  (abbreviation ) one \"\", \"top\", \"bottom\". top strand defined input test sequences orientation trainingSet, bottom strand reverse complement orientation.  default \"\" classify using orientations choose result highest confidence. Choosing correct strand make classification 2-fold faster, assuming reads orientation. Note strand ignored test AAStringSet. threshold Numeric specifying confidence truncate output taxonomic classifications.  Lower values threshold classify deeper taxonomic tree expense accuracy, vise-versa higher values threshold. bootstraps Integer giving maximum number bootstrap replicates perform sequence.  number bootstrap replicates set automatically (average) 99\\ test sequence. samples function call written function L', evaluate numeric vector length L'.  Typically form ``+ B*L^C'', ', B', `C' constants. minDescend Numeric giving minimum fraction bootstraps required descend tree initial tree descend phase algorithm.  Higher values less likely descend tree, causing direct comparison sequences trainingSet.  Lower values may increase classification speed expense accuracy. Suggested values 1.0 0.9. fullLength Numeric specifying fold-difference sequence lengths sequences test trainingSet allowable, 0 (default) consider sequences trainingSet regardless length.  Can specified either single numeric (> 1), two numerics specifying upper lower fold-difference.  fullLength 0 1 (exclusive), fold-difference inferred length variability among sequences belonging class based foldDifference quantiles.  example, setting fullLength 0.99 use 1st 99th percentile intra-group length variability trainingSet. case full-length sequences, specifying fullLength can improve speed accuracy using sequence length pre-filter classification.  Note fullLength greater 0 test trainingSet consist full-length sequences. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display progress.","code":""},{"path":"/reference/IdTaxa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign Sequences a Taxonomic Classification — IdTaxa","text":"type \"extended\" (default) object class Taxa subclass Train returned.  stored list elements corresponding respective sequence test. list element contains components: taxon character vector containing taxa sequence assigned. confidence numeric vector giving corresponding percent confidence taxon. rank classifier trained set ranks, character vector containing rank name taxon. type \"collapsed\" character vector returned taxonomic assignment sequence.  takes repeating form Taxon name [rank, confidence\\%]; ...'' \\code{rank}s supplied training, Taxon name confidence\\ Classifies sequences according training set assigning confidence taxonomic labels taxonomic level. Sequences test assigned taxonomic classification based trainingSet created LearnTaxa.  taxonomic level given confidence 0\\ taxonomy truncated confidence drops threshold.  taxonomic classification truncated, last group labeled ``unclassified_'' followed final taxon's name.  Note reported confidence p-value directly relate given classification's probability wrong.  default threshold 60% intended minimize rate incorrect classifications. Lower values threshold (e.g., 50%) may preferred increase taxonomic depth classifications.  Values 60% 50% recommended nucleotide sequences 50% 40% amino acid sequences.  Murali, ., et al. (2018). IDTAXA: novel approach accurate taxonomic classification microbiome sequences. Microbiome, 6, 140. https://doi.org/10.1186/s40168-018-0521-5Cooley, N. Wright, E. (2021). Accurate annotation protein coding sequences IDTAXA. NAR Genomics Bioinformatics, 3(3). https://doi.org/10.1093/nargab/lqab080 LearnTaxa, Taxa-class Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/IdentifyByRank.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify By Taxonomic Rank — IdentifyByRank","title":"Identify By Taxonomic Rank — IdentifyByRank","text":"Identifies sequences specific level taxonomic rank.","code":""},{"path":"/reference/IdentifyByRank.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify By Taxonomic Rank — IdentifyByRank","text":"","code":"IdentifyByRank(   dbFile,   tblName = \"Seqs\",   level = 0,   add2tbl = FALSE,   verbose = TRUE )"},{"path":"/reference/IdentifyByRank.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify By Taxonomic Rank — IdentifyByRank","text":"dbFile SQLite connection object character string specifying path database file. tblName Character string specifying table rank information located. level Level taxonomic rank.  (See details section .) add2tbl Logical character string specifying table name add result. verbose Logical indicating whether print database queries information.","code":""},{"path":"/reference/IdentifyByRank.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify By Taxonomic Rank — IdentifyByRank","text":"data.frame rank corresponding identifier identifier.  Note quotes stripped identifiers prevent problems may cause.  origin gives rank preceding identifier.  add2tbl FALSE ``identifier'' column updated dbFile.","code":""},{"path":"/reference/IdentifyByRank.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Identify By Taxonomic Rank — IdentifyByRank","text":"IdentifyByRank simply identifies sequence specific level taxonomic rank.  Requires rank information present tblName, created default importing sequences GenBank formatted file. input parameter level integer giving ``level'' taxonomic rank choose identifier.  Negative levels interpreted many levels last level rank. level zero selects base level (see ). specified level rank exist closest rank chosen.  Therefore, setting level Inf always select last taxonomic level (.e., genus). example, representative ``rank'' imported GenBank file : Saccharomyces cerevisiae Eukaryota; Fungi; Ascomycota; Saccharomycotina; Saccharomycetes; Saccharomycetales; Saccharomycetaceae; Saccharomyces. Setting level 0 result identifier Saccharomyces cerevisiae'', first line.  \\code{level} \\code{2} return Fungi'', -2 (second last) return Saccharomycetaceae''.  \\code{level} \\code{Inf} find nearest level end, Saccharomyces''.","code":""},{"path":[]},{"path":"/reference/IdentifyByRank.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Identify By Taxonomic Rank — IdentifyByRank","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/IdentifyByRank.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify By Taxonomic Rank — IdentifyByRank","text":"","code":"db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") ids <- IdentifyByRank(db, level=Inf) #>  #> Formed 72 distinct groups. #> Time difference of 0.01 secs #>  head(ids) #>                                                                                                                                                      rank #> 1                                               uncultured bacterium\\nRoot; Bacteria; \"Firmicutes\"; \"Bacilli\"; Bacillales; Bacillaceae; \\nLysinibacillus. #> 2                                       uncultured bacterium\\nRoot; Bacteria; \"Firmicutes\"; \"Bacilli\"; Bacillales; \\n\"Staphylococcaceae\"; Staphylococcus. #> 3                                uncultured bacterium\\nRoot; Bacteria; \"Firmicutes\"; \"Bacilli\"; \"Lactobacillales\"; \\n\"Carnobacteriaceae\"; Dolosigranulum. #> 4                 uncultured bacterium\\nRoot; Bacteria; \"Firmicutes\"; \"Clostridia\"; Clostridiales; \\nPeptococcaceae; Peptococcaceae 1; Desulfosporosinus. #> 5 uncultured bacterium\\nRoot; Bacteria; \"Firmicutes\"; \"Erysipelotrichi\"; \\n\"Erysipelotrichales\"; Erysipelotrichaceae; \\nunclassified_Erysipelotrichaceae. #> 6                            uncultured bacterium\\nRoot; Bacteria; \"Bacteroidetes\"; \"Bacteroidia\"; \"Bacteroidales\"; \\n\"Porphyromonadaceae\"; Dysgonomonas. #>                                                                                          origin #> 1                             Root; Bacteria; \"Firmicutes\"; \"Bacilli\"; Bacillales; Bacillaceae; #> 2                    Root; Bacteria; \"Firmicutes\"; \"Bacilli\"; Bacillales;  \"Staphylococcaceae\"; #> 3             Root; Bacteria; \"Firmicutes\"; \"Bacilli\"; \"Lactobacillales\";  \"Carnobacteriaceae\"; #> 4 Root; Bacteria; \"Firmicutes\"; \"Clostridia\"; Clostridiales;  Peptococcaceae; Peptococcaceae 1; #> 5  Root; Bacteria; \"Firmicutes\"; \"Erysipelotrichi\";  \"Erysipelotrichales\"; Erysipelotrichaceae; #> 6       Root; Bacteria; \"Bacteroidetes\"; \"Bacteroidia\"; \"Bacteroidales\";  \"Porphyromonadaceae\"; #>                         identifier #> 1                   Lysinibacillus #> 2                   Staphylococcus #> 3                   Dolosigranulum #> 4                Desulfosporosinus #> 5 unclassified_Erysipelotrichaceae #> 6                     Dysgonomonas"},{"path":"/reference/LearnNonCoding.html","id":null,"dir":"Reference","previous_headings":"","what":"Learn a Non-Coding RNA Model — LearnNonCoding","title":"Learn a Non-Coding RNA Model — LearnNonCoding","text":"Learns compact representation patterns representing set non-coding RNAs belonging family.","code":""},{"path":"/reference/LearnNonCoding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Learn a Non-Coding RNA Model — LearnNonCoding","text":"","code":"LearnNonCoding(   myXStringSet,   threshold = 0.3,   weight = NA,   maxLoopLength = 500,   maxPatterns = 20,   scoreDependence = FALSE,   structure = NULL,   processors = 1 )"},{"path":"/reference/LearnNonCoding.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Learn a Non-Coding RNA Model — LearnNonCoding","text":"myXStringSet DNAStringSet RNAStringSet object aligned sequence representatives belonging non-coding RNA family. threshold Numeric specifying minimum relative frequency patterns consider learning. weight Either numeric vector weights sequence, single number implying equal weights, NA (default) automatically calculate sequence weights based myXStringSet. maxLoopLength Numeric giving maximum length conserved hairpin loops consider. maxPatterns numeric vector length two specifying maximum number motifs hairpins, respectively, single numeric giving maximum . scoreDependence Logical determining whether record log-odds score dependencies patterns.  default (FALSE) recommended non-coding RNA families. structure Either character string providing consensus secondary structure dot bracket notation, matrix paired positions first two columns, NULL (default) predict consensus secondary structure PredictDBN. processors number processors use, NULL automatically detect use available processors.","code":""},{"path":"/reference/LearnNonCoding.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Learn a Non-Coding RNA Model — LearnNonCoding","text":"object class NonCoding.","code":""},{"path":"/reference/LearnNonCoding.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Learn a Non-Coding RNA Model — LearnNonCoding","text":"Non-coding RNAs belonging family typically conserved sequence motifs, secondary structure elements, k-mer frequencies can used identify members family.  LearnNonCoding identifies conserved patterns determines best identifying non-coding RNA relative random sequence background. Sequence motifs hairpins defined relative distance start end non-coding RNA, allowing precise rapid identification boundaries matches non-coding RNA genome.","code":""},{"path":"/reference/LearnNonCoding.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Learn a Non-Coding RNA Model — LearnNonCoding","text":"Wright, E. S. (2021). FindNonCoding: rapid simple detection non-coding RNAs genomes. Bioinformatics. https://doi.org/10.1093/bioinformatics/btab708","code":""},{"path":[]},{"path":"/reference/LearnNonCoding.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Learn a Non-Coding RNA Model — LearnNonCoding","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/LearnNonCoding.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Learn a Non-Coding RNA Model — LearnNonCoding","text":"","code":"# import a family of non-coding RNAs fas_path <- system.file(\"extdata\",   \"IhtA.fas\",   package=\"DECIPHER\") rna <- readRNAStringSet(fas_path) rna #> RNAStringSet object of length 27: #>      width seq                                              names                #>  [1]   103 AAGAUGAUAUUCUGCGCCAUGGA...UGAUUGUUGUUUUCUUGGCUUU KE360988.1/6443-6... #>  [2]   105 AAGAUGAUAUUCUCCGCCGUGGA...AACUUUAUGUUUUCUUGGCUUU AE002161.1/54676-... #>  [3]   107 AAGUUGGUAUUCUAACGCCAUGG...UAUCUCCGGUUCUCUUGGCUUU AE001273.1/773281... #>  [4]   107 AAGUUGGUAUUCUAACGCCAUGG...UGUCUCCAGUUCUCUUGGCUUU AE002160.2/53054-... #>  [5]   103 AAGAUGAUAUUCUACGCCAUGGA...UGAUUGUUGUUUUCUUGGCUUU AE015925.1/52097-... #>  ...   ... ... #> [23]   107 AAGUUGGUAUUCUAACGCCAUGG...UAUCUCCGGUUCUCUUGGCUUU CP006674.1 Chlamy... #> [24]   103 AAGAUGAUAUUCUGCGCCAUGGA...UGAUUGUUGUUUUCUUGGCUUU KE356008.1 Chlamy... #> [25]   108 AAGUUGGUAUUCUAACGCCAUGG...UAUCUCCGGUUCUCUUGGCUUU CVNC01000001.1 Ch... #> [26]   103 AAGAUGAUAUUCUGCGCCAUGGA...UGAUUGUUGUUUUCUUGGCUUU AP006861.1 Chlamy... #> [27]   101 AAGAUGAUAUUCUACGCCAUGGA...AUGAUGUUGUUUUCUUGGCUUU CP015840.1 Chlamy...  # align the sequences RNA <- AlignSeqs(rna) #> Determining distance matrix based on shared 7-mers: #> ================================================================================ #>  #> Time difference of 0 secs #>  #> Clustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0 secs #>  #> Aligning Sequences: #> ================================================================================ #>  #> Time difference of 0.05 secs #>  #> Iteration 1 of 2: #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 0.02 secs #>  #> Iteration 2 of 2: #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 0 secs #>  RNA #> RNAStringSet object of length 27: #>      width seq                                              names                #>  [1]   113 AAGAUGAUAUUCUG-CGCCAUGG...GAUUGU-UGUUUUCUUGGCUUU KE360988.1/6443-6... #>  [2]   113 AAGAUGAUAUUCUC-CGCCGUGG...AACUUUAUGUUUUCUUGGCUUU AE002161.1/54676-... #>  [3]   113 AAGUUGGUAUUCUAACGCCAUGG...--UCUCCGGUUCUCUUGGCUUU AE001273.1/773281... #>  [4]   113 AAGUUGGUAUUCUAACGCCAUGG...--UCUCCAGUUCUCUUGGCUUU AE002160.2/53054-... #>  [5]   113 AAGAUGAUAUUCUA-CGCCAUGG...GAUUGU-UGUUUUCUUGGCUUU AE015925.1/52097-... #>  ...   ... ... #> [23]   113 AAGUUGGUAUUCUAACGCCAUGG...--UCUCCGGUUCUCUUGGCUUU CP006674.1 Chlamy... #> [24]   113 AAGAUGAUAUUCUG-CGCCAUGG...GAUUGU-UGUUUUCUUGGCUUU KE356008.1 Chlamy... #> [25]   113 AAGUUGGUAUUCUAACGCCAUGG...--UCUCCGGUUCUCUUGGCUUU CVNC01000001.1 Ch... #> [26]   113 AAGAUGAUAUUCUG-CGCCAUGG...GAUUGU-UGUUUUCUUGGCUUU AP006861.1 Chlamy... #> [27]   113 AAGAUGAUAUUCUA-CGCCAUGG...GAU-GU-UGUUUUCUUGGCUUU CP015840.1 Chlamy...  y <- LearnNonCoding(RNA) y #> NonCoding object with 17 motifs, 5 hairpins, and 2-mer frequencies. y[[\"motifs\"]] #>    begin_low begin_high end_low end_high         motif          pwm #> 1          0          0      96      100       AAGATGr 0.945907.... #> 2          7          7      89       93       TATTCTA 0.018030.... #> 3         14         15      82       86       CGCCATG 0.018361.... #> 4         21         22      81       85             G 0.018030.... #> 5         22         23      72       76     AATAGCTTC 0.911521.... #> 6         31         33      59       63  rACTCTGkTGyw 0.455021.... #> 7         44         45      57       61             T 0.042112.... #> 8         45         50      48       52     tCAGGGGGA 0.215551.... #> 9         54         59      39       43     AAGCCAAGA 0.945907.... #> 10        64         70      34       38           rwr 0.583125.... #> 11        68         74      20       24 rdmGTydGCCGTA 0.549315.... #> 12        82         86      19       20             A 0.945907.... #> 13        84         87      18       19             y 0.018361.... #> 14        85         88      17       18             T 0.018361.... #> 15        86         89      15       16            kT 0.018361.... #> 16        88         92       8        8       tGTTTTC 0.168051.... #> 17        95         99       0        0      TTGGCTTT 0.018030.... #>        minscore   prevalence   background #> 1  0, 2.084.... 0.035714.... 0.969580.... #> 2  0, 5.945.... 0.035714.... 0.977905.... #> 3  0, 5.985.... 0.035714.... 0.983121.... #> 4        0, Inf 0.053728.... 0.549456.... #> 5  0, 7.982.... 0.053728.... 0.981433.... #> 6  0, 7.010.... 0.035714.... 0.976160.... #> 7        0, Inf 0.021524.... 0.449913.... #> 8  0, 4.568.... 0.115007.... 0.961494.... #> 9  0, 9.438.... 0.069671.... 0.978351.... #> 10 1.165281.... 0.122610.... 0.549946.... #> 11 0, 7.108.... 0.035714.... 0.971890.... #> 12       0, Inf 0.119267.... 0.583608.... #> 13 0.377645.... 0.069671.... 0.449913.... #> 14       0, Inf 0.035714.... 0.449913.... #> 15 0, 0.743.... 0.076484.... 0.434978.... #> 16 0, 4.681.... 0.035714.... 0.948541.... #> 17       0, Inf 0.035714.... 0.990832.... y[[\"hairpins\"]] #>   begin_low begin_high end_low end_high width_low width_high length_low #> 1        -4          1      63       72        31         44          6 #> 2         7          7      77       81        19         20          8 #> 3        25         31      42       52        24         40          5 #> 4        31         35      48       54        19         24          5 #> 5        49         58      -4        0        49         61         13 #>   length_high           dG   prevalence   background #> 1          12 -Inf, -2.... 0.296145.... 0.213168.... #> 2           8 -Inf, -3.... 0.753849.... 0.008085.... #> 3           8 -Inf, -5.... 0.238152.... 0.089677.... #> 4           9 -Inf, -9.... 0.231175.... 0.004305.... #> 5          26 -Inf, -2.... 0.142687.... 0.000105.... head(y[[\"kmers\"]]) #> [1] 185 109 183 162  78  83"},{"path":"/reference/LearnTaxa.html","id":null,"dir":"Reference","previous_headings":"","what":"Train a Classifier for Assigning Taxonomy — LearnTaxa","title":"Train a Classifier for Assigning Taxonomy — LearnTaxa","text":"Trains classifier based reference taxonomy containing sequence representatives assigned taxonomic groups.","code":""},{"path":"/reference/LearnTaxa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Train a Classifier for Assigning Taxonomy — LearnTaxa","text":"","code":"LearnTaxa(   train,   taxonomy,   rank = NULL,   K = NULL,   N = 500,   minFraction = 0.01,   maxFraction = 0.06,   maxIterations = 10,   multiplier = 100,   maxChildren = 200,   alphabet = AA_REDUCED[[139]],   verbose = TRUE )"},{"path":"/reference/LearnTaxa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Train a Classifier for Assigning Taxonomy — LearnTaxa","text":"train AAStringSet, DNAStringSet, RNAStringSet unaligned sequences. taxonomy Character string providing reference taxonomic assignment sequence train.  Taxonomic ranks separated semicolons (;'') beginning Root''. rank Optionally, data.frame 5 named columns giving Index'' (.e., 0 number unique taxa), Name'' (.e., taxon name), Parent'' (.e., Index'' parent taxon), Level'' (.e., integer rank level), Rank'' (e.g., genus'') taxonomic rank. information often provided separate taxid'' file along publicly available training sequence sets. K Integer specifying k-mer size NULL (default) calculate k-mer size automatically.  default value K matches sequences found chance every N k-mers. N Numeric indicating approximate number k-mers can randomly selected one found chance average. example, default value 500 set K (K unspecified) every 500th k-mer expected match chance. minFraction Numeric giving minimum fraction k-mers sample initial tree descent phase classification algorithm.  (See details section .) maxFraction Numeric giving maximum fraction k-mers sample initial tree descent phase classification algorithm.  (See details section .) maxIterations Integer specifying maximum number iterations attempt re-classification training sequence declaring ``problem sequence''.  (See details section .) multiplier Numeric indicating degree individual sequences control fraction k-mers sampled edge initial tree descent phase classification algorithm.  (See details section .) maxChildren Integer giving maximum number child taxa taxon consider descending taxonomic tree.  value 1 prevent use tree descent algorithm altogether. Lower values may decrease classification speed, result output objects require less memory. alphabet Character vector amino acid groupings used reduce 20 standard amino acids smaller groups.  Alphabet reduction helps find distant homologies sequences.  non-reduced amino acid alphabet can used setting alphabet equal AA_STANDARD. verbose Logical indicating whether display progress.","code":""},{"path":"/reference/LearnTaxa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Train a Classifier for Assigning Taxonomy — LearnTaxa","text":"object class Taxa subclass Train, stored list components: taxonomy character vector containing possible groups taxonomy. taxa character vector containing basal taxon taxonomy. ranks character vector rank names taxon, NULL rank information supplied. levels Integer giving rank level taxon. children list containing index children taxonomy taxon. parents integer providing index parent taxon. fraction numeric minFraction maxFraction represents learned fraction informative k-mers sample taxon initial tree descent phase classification algorithm.  Problem groups marked fraction NA. sequences List containing integer indices sequences train belonging taxon. kmers List containing unique sorted k-mers (converted integers) belonging sequence train. crossIndex Integer indicating index taxonomy sequence's taxonomic label. K value K provided input. IDFweights Numeric vector length 4^K providing inverse document frequency weight k-mer. decisionKmers List informative k-mers associated relative frequencies internal edge taxonomy. problemSequences data.frame providing Index'', Expected'' label, Predicted'' taxon sequences correctly classified initial tree descent phase algorithm. } \\item{problemGroups}{ Character vector containing taxonomic groups repeatedly problems correctly re-classifying sequences \\code{train} initial tree descent phase classification algorithm.  Problem groups likely indicate number sequences (entire group sequences) assigned problem group incorrectly placed taxonomic tree. } \\item{alphabet}{ \\code{alphabet} \\code{train} AAStringSet'', otherwise NULL.","code":""},{"path":"/reference/LearnTaxa.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Train a Classifier for Assigning Taxonomy — LearnTaxa","text":"Learning training data two part process consisting () forming taxonomic tree (ii) ensuring training sequences can correctly reclassified.  latter step relies reclassifying sequences train descending taxonomic tree, process termed ``tree descent''.  Ultimately, goal tree descent quickly accurately narrow selection groups sequence may belong.  learning process, tree descent tuned performs well classifying new sequences. process training classifier first involves learning taxonomic tree spanning reference sequences train.  Typically, reference taxonomic classifications provided authoritative source, oftentimes along taxid'' file containing taxonomic \\code{rank} information.  taxonomic tree may contain number levels (e.g., Root, Phylum, Class, Order, Family, Genus) long hierarchically nested always begin Root''. second phase training classifier, tree descent, involves learning optimal set k-mers discerning different sub-groups edge.  fraction k-mers greatest discerning power matched training sequence, process repeated 100 random subsamples decide set possible taxonomic groups training sequence may belong. learning process works attempting correctly re-classify training sequence taxonomy.  Initially, maxFraction informative k-mers repeatedly sampled edge tree descent. Training sequences incorrectly classified edge lower fraction k-mers sampled amount proportional multiplier.  fraction sampled k-mers decreases, tree descent process terminates higher rank levels. major advantage tree descent speeds classification process indicates training set likely contains mislabeled sequences incorrectly-placed taxonomic groups.  Training sequences correctly classified within maxIterations marked problem sequences'', likely mislabeled.  enough sequences difficulty correctly classified edge fraction drops \\code{minFraction}, edge recorded problem group''. final result object can used classification IdTaxa, well information train used help correct errors taxonomy.","code":""},{"path":"/reference/LearnTaxa.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Train a Classifier for Assigning Taxonomy — LearnTaxa","text":"K NULL, automatically determined value K might large computers, resulting error.  cases recommended K manually set smaller value.","code":""},{"path":"/reference/LearnTaxa.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Train a Classifier for Assigning Taxonomy — LearnTaxa","text":"Murali, ., et al. (2018). IDTAXA: novel approach accurate taxonomic classification microbiome sequences. Microbiome, 6, 140. https://doi.org/10.1186/s40168-018-0521-5","code":""},{"path":[]},{"path":"/reference/LearnTaxa.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Train a Classifier for Assigning Taxonomy — LearnTaxa","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/LearnTaxa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Train a Classifier for Assigning Taxonomy — LearnTaxa","text":"","code":"# import training sequences fas <- system.file(\"extdata\", \"50S_ribosomal_protein_L2.fas\", package=\"DECIPHER\") dna <- readDNAStringSet(fas)  # parse the headers to obtain a taxonomy s <- strsplit(names(dna), \" \") genus <- sapply(s, `[`, 1) species <- sapply(s, `[`, 2) taxonomy <- paste(\"Root\", genus, species, sep=\"; \") head(taxonomy) #> [1] \"Root; Rickettsia; prowazekii\"    \"Root; Porphyromonas; gingivalis\" #> [3] \"Root; Porphyromonas; gingivalis\" \"Root; Porphyromonas; gingivalis\" #> [5] \"Root; Pasteurella; multocida\"    \"Root; Pasteurella; multocida\"     # train the classifier trainingSet <- LearnTaxa(dna, taxonomy) #> ================================================================================ #>  #> Time difference of 2.94 secs #>  trainingSet #>   A training set of class 'Taxa' #>    * K-mer size: 9 #>    * Number of rank levels: 4 #>    * Total number of sequences: 317 #>    * Number of groups: 118 #>    * Number of problem groups: 0 #>    * Number of problem sequences: 0  # view information about the classifier plot(trainingSet)   if (FALSE) { # train the classifier with amino acid sequences aa <- translate(dna) trainingSetAA <- LearnTaxa(aa, taxonomy) trainingSetAA }"},{"path":"/reference/MIQS.html","id":null,"dir":"Reference","previous_headings":"","what":"MIQS Amino Acid Substitution Matrix — MIQS","title":"MIQS Amino Acid Substitution Matrix — MIQS","text":"MIQS amino acid substitution matrix defined Yamada & Tomii (2014).","code":""},{"path":"/reference/MIQS.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"MIQS Amino Acid Substitution Matrix — MIQS","text":"format : num 1:25, 1:25 3.2 -1.3 -0.4 -0.4 1.5 -0.2 -0.4 0.4 -1.2 -1.3 ...  - attr(*, \"dimnames\")=List 2 ..$ : chr 1:25 \"\" \"R\" \"N\" \"D\" ...  ..$ : chr 1:25 \"\" \"R\" \"N\" \"D\" ...","code":""},{"path":"/reference/MIQS.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"MIQS Amino Acid Substitution Matrix — MIQS","text":"Yamada, K., & Tomii, K. (2014). Revisiting amino acid substitution matrices identifying distantly related proteins. Bioinformatics, 30(3), 317-325.","code":""},{"path":"/reference/MIQS.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"MIQS Amino Acid Substitution Matrix — MIQS","text":"Substitution matrix values represent log-odds observing aligned pair amino acids versus likelihood finding pair chance. Values MIQS matrix units third-bits (\\(log(odds\\ ratio)*3/log(2)\\)).","code":""},{"path":"/reference/MIQS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"MIQS Amino Acid Substitution Matrix — MIQS","text":"","code":"data(MIQS) MIQS[\"A\", \"R\"] # score for A/R pairing #> [1] -1.3  data(BLOSUM62) plot(BLOSUM62[1:20, 1:20], MIQS[1:20, 1:20]) abline(a=0, b=1)"},{"path":"/reference/MODELS.html","id":null,"dir":"Reference","previous_headings":"","what":"Available Models of Sequence Evolution — MODELS","title":"Available Models of Sequence Evolution — MODELS","text":"MODELS contains models sequence evolution can used TreeLine.","code":""},{"path":"/reference/MODELS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Available Models of Sequence Evolution — MODELS","text":"","code":"MODELS"},{"path":"/reference/MODELS.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Available Models of Sequence Evolution — MODELS","text":"object class list length 2.","code":""},{"path":"/reference/MODELS.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Available Models of Sequence Evolution — MODELS","text":"MODELS list two elements: character vector (eight) nucleotide models character vector (37) protein models.  MODELS time reversible. Nucleotide models described order increasing number parameters follows: JC69 (Jukes Cantor, 1969) simplest substitution model assumes equal base frequencies (1/4) equal mutation rates. K80 (Kimura, 1980) Assumes equal base frequencies, distinguishes rate transitions transversions. T92 (Tamura, 1992) addition distinguishing transitions transversions, parameter added represent G+C content bias. F81 (Felsenstein, 1981) Assumes equal mutation rates, allows bases different frequencies. HKY85 (Hasegawa, Kishino Yano, 1985) Distinguishes transitions transversions allows bases different frequencies. TN93 (Tamura Nei, 1993) Allows unequal base frequencies distinguishes transversions two possible types transitions (.e., <-> G & C <-> T). SYM (Zharkikh, 1994) Equal base frequencies substitution rates free parameters. GTR (Tavare, 1986) general time reversible model allowing unequal base frequencies substitution rates. Protein models described following publications: AB (Mirsky, 2015), BLOSUM62 (Henikoff, 1992), cpREV (Adachi, 2000), cpREV64 (Zhong, 2010), Dayhoff (Dayhoff, 1978), DCMut-Dayhoff (Kosiol, 2005), DCMut-JTT (Kosiol, 2005), DEN (Le, 2018), FLAVI (Le, 2020), FLU (Dang, 2010), gcpREV (Cox, 2013), HIVb (Nickle, 2007), HIVw (Nickle, 2007), JTT (Jones, 1992), LG (Le, 2008), MtArt (Abascal, 2007), mtDeu (Le, 2017), mtInv (Le, 2017), mtMam (Yang, 1998), mtMet (Le, 2017), mtOrt (Chang, 2020), mtREV (Adachi, 1996), mtVer (Le, 2017), MtZoa (Rota-Stabelli, 2009), PMB (Veerassamy, 2003), Q.bird (Minh, 2021), Q.insect (Minh, 2021), Q.LG (Minh, 2021), Q.mammal (Minh, 2021), Q.pfam (Minh, 2021), Q.plant (Minh, 2021), Q.yeast (Minh, 2021), rtREV (Dimmic, 2002), stmtREV (Liu, 2014), VT (Muller, 2000), WAG (Whelan, 2001), WAGstar (Whelan, 2001). +G (Yang, 1993) Specifying model+G4 adds single parameter models relax assumption equal rates among sites sequence.  single parameter specifies shape Gamma Distribution.  continuous distribution represented 2-10 discrete rates respective probabilities determined equal bins Laguerre Quadrature method (Felsenstein, 2001).  example, specifying model+G8 represent continuous Gamma Distribution eight rates associated probabilities. +F Specifying model+F uses empirical frequencies rather optimized state frequencies.  applicable models state frequencies free parameters.","code":""},{"path":"/reference/MODELS.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Available Models of Sequence Evolution — MODELS","text":"Abascal, F., Posada, D., Zardoya, R. (2007) Molecular Biology Evolution, 24, 1-5. Adachi, J. Hasegawa, M. (1996) Journal Molecular Evolution, 42, 459-468. Adachi, J., Waddell, P., Martin, W., Hasegawa, M. (2000) Journal Molecular Evolution, 50, 348-358. Chang, H., Nie, Y., Zhang, N., Zhang, X., Sun, H., Mao, Y., Qiu, Z., Huang, Y. (2020) BMC Ecology Evolution, 20, 57. Cox, C. Foster, P. (2013) Molecular Phylogenetics Evolution, 68, 218-220. Dang, C., Le, S., Gascuel, O., Le, V. (2010) BMC Evolutionary Biology, 10, 99. Dayhoff, M., Schwartz, R., Orcutt, B. (1978) Atlas Protein Sequence Structure, National Biomedical Research Foundation, Washington DC, 5, 345-352. Dimmic, M., Rest, J., Mindell, D., Goldstein, R. (2002) Journal Molecular Evolution, 55, 65-73. Felsenstein, J. (1981) Evolutionary trees DNA sequences: maximum likelihood approach. Journal Molecular Evolution, 17(6), 368-376. Felsenstein, J. (2001) Taking Variation Evolutionary Rates Sites Account Inferring Phylogenies. Journal molecular evolution, 53(4-5), 447-455. Hasegawa, M., Kishino H., Yano T. (1985) Dating human-ape splitting molecular clock mitochondrial DNA. Journal Molecular Evolution, 22(2), 160-174. Henikoff, S. Henikoff, J. (1992) Proceedings National Academy Sciences USA, 89, 10915-10919. Jones, D., Taylor, W., Thornton, J. (1992) Computer Applications Biosciences, 8, 275-282. Jukes, T. Cantor C. (1969) Evolution Protein Molecules. New York: Academic Press. pp. 21-132. Kimura, M. (1980) simple method estimating evolutionary rates base substitutions comparative studies nucleotide sequences. Journal Molecular Evolution, 16(2), 111-120. Kosiol, C. Goldman, N. (2005) Molecular Biology Evolution, 22, 193-199. Le, S. Gascuel, O. (2008) Molecular Biology Evolution, 25, 1307-1320. Le, T., Dang, C., Le, S. (2018) Proceedings 10th International Conference Knowledge Systems Engineering (KSE 2018), Ho Chi Minh City, Vietnam, 242-246. Le, T., Vinh, L. (2020) Journal Molecular Evolution, 88, 445-452. Le, V., Dang, C., Le, S. (2017) BMC Evolutionary Biology, 17, 136. Liu, Y., Cox, C., Wang, W., Goffinet, B. (2014) Systematic Biology, 63, 862-878. Minh, B., Dang, C., Le, S., Lanfear, R. (2021) Systematic Biology, syab010. Mirsky, ., Kazandjian, L., Anisimova, M. (2015) Molecular Biology Evolution, 32, 806-819. Muller, T. Vingron, M. (2000) Journal Computational Biology, 7, 761-776. Nickle, D., Heath, L., Jensen, M., Gilbert P., Mullins, J., Kosakovsky Pond SL (2007) PLoS ONE, 2, e503. Rota-Stabelli, O., Yang, Z., Telford, M. (2009) Molecular Phylogenetics Evolution, 52, 268-272. Tamura, K. (1992) Estimation number nucleotide substitutions strong transition-transversion G+C content biases. Molecular Biology Evolution, 9(4), 678-687. Tamura, K. Nei M. (1993) Estimation number nucleotide substitutions control region mitochondrial DNA humans chimpanzees. Molecular Biology Evolution, 10(3), 512-526. Tavare, S. (1986) ``Probabilistic Statistical Problems Analysis DNA Sequences.'' Lectures Mathematics Life Sciences, 17: 57-86. Veerassamy, S., Smith, ., Tillier, E. (2003) Journal Computational Biology, 10, 997-1010. Whelan, S. Goldman, N. (2001) Molecular Biology Evolution, 18, 691-699. Yang, Z., Nielsen, R., Hasegawa, M. (1998) Molecular Biology Evolution, 15, 1600-1611. Yang, Z. (1993) Maximum-likelihood estimation phylogeny DNA sequences substitution rates differ sites. Molecular Biology Evolution, 10(6), 1396-1401. Zharkikh, . (1994) Estimation evolutionary distances nucleotide sequences. Journal Molecular Evolution, 39, 315-329. Zhong, B., Yonezawa, T., Zhong, Y., Hasegawa, M. (2010) Molecular Biology Evolution, 27, 2855-2863.","code":""},{"path":[]},{"path":"/reference/MODELS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Available Models of Sequence Evolution — MODELS","text":"","code":"str(MODELS) #> List of 2 #>  $ Nucleotide: chr [1:16] \"JC69\" \"JC69+G4\" \"K80\" \"K80+G4\" ... #>  $ Protein   : chr [1:74] \"AB\" \"AB+G4\" \"BLOSUM62\" \"BLOSUM62+G4\" ..."},{"path":"/reference/MapCharacters.html","id":null,"dir":"Reference","previous_headings":"","what":"Map Changes in Ancestral Character States — MapCharacters","title":"Map Changes in Ancestral Character States — MapCharacters","text":"Maps character changes phylogenetic tree containing reconstructed ancestral states.","code":""},{"path":"/reference/MapCharacters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map Changes in Ancestral Character States — MapCharacters","text":"","code":"MapCharacters(   x,   refPositions = seq_len(nchar(attr(x, \"state\")[1])),   labelEdges = FALSE,   type = \"dendrogram\",   chars = LETTERS,   ignoreIndels = TRUE )"},{"path":"/reference/MapCharacters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map Changes in Ancestral Character States — MapCharacters","text":"x object class dendrogram \"state\" attributes node. refPositions Numeric vector reference positions original sequence alignment.  changes refPositions reported, state changes labeled according position refPositions. labelEdges Logical determining whether label edges number changes along edge. type Character string indicating type output desired.  (abbreviation ) one \"dendrogram\", \"table\", \"\".  (See value section .) chars Character vector specifying characters consider state changes site.  default (LETTERS) consider upper case letter. Alternatively, chars AA_STANDARD, DNA_BASES, RNA_BASES. ignoreIndels Logical specifying whether report insertions deletions (indels).  TRUE (default), substitutions one state another reported.","code":""},{"path":"/reference/MapCharacters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map Changes in Ancestral Character States — MapCharacters","text":"type \"dendrogram\" (default) original dendrogram  x returned addition \"change\" attributes every edge except root.  type \"table\" sorted table character changes returned frequent parallel changes beginning.  type \"\" list length 2 provided containing dendrogram table.","code":""},{"path":"/reference/MapCharacters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Map Changes in Ancestral Character States — MapCharacters","text":"Ancestral state reconstruction affords ability identify character changes occurred along edges rooted phylogenetic tree.  Character changes reported according index refPositions.  ignoreIndels FALSE, adjacent insertions deletions merged single changes occurring first position.  table changes can used identify parallel, convergent, divergent mutations.","code":""},{"path":[]},{"path":"/reference/MapCharacters.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Map Changes in Ancestral Character States — MapCharacters","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/MapCharacters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map Changes in Ancestral Character States — MapCharacters","text":"","code":"fas <- system.file(\"extdata\", \"Bacteria_175seqs.fas\", package=\"DECIPHER\") dna <- readDNAStringSet(fas)  # align the sequences rna <- RNAStringSet(RemoveGaps(dna)) rna <- AlignSeqs(rna) #> Determining distance matrix based on shared 9-mers: #> ================================================================================ #>  #> Time difference of 1.52 secs #>  #> Clustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.01 secs #>  #> Aligning Sequences: #> ================================================================================ #>  #> Time difference of 1.78 secs #>  #> Iteration 1 of 2: #> Predicting RNA Secondary Structures: #> ================================================================================ #>  #> Time difference of 1.48 secs #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.07 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.01 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 1.68 secs #>  #> Iteration 2 of 2: #> Predicting RNA Secondary Structures: #> ================================================================================ #>  #> Time difference of 1.5 secs #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.07 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.01 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 0.59 secs #>  rna # input alignment #> RNAStringSet object of length 175: #>       width seq                                             names                #>   [1]  1470 ----------------------...---------------------- uncultured bacter... #>   [2]  1470 ----------------------...CG-------------------- uncultured bacter... #>   [3]  1470 ----------------------...---------------------- uncultured bacter... #>   [4]  1470 ----------------------...CGGCCG---------------- uncultured bacter... #>   [5]  1470 ----------------------...CGGUG----------------- uncultured bacter... #>   ...   ... ... #> [171]  1470 ----------------------...---------------------- uncultured bacter... #> [172]  1470 ----------------------...---------------------- uncultured bacter... #> [173]  1470 ----------------------...---------------------- uncultured bacter... #> [174]  1470 ----------------------...CGG------------------- uncultured bacter... #> [175]  1470 ----------------------...---------------------- uncultured bacter...  d <- DistanceMatrix(rna, type=\"dist\", correction=\"JC\") #> ================================================================================ #>  #> Time difference of 0.06 secs #>  tree <- TreeLine(myDistMatrix=d,                  method=\"NJ\",                  type=\"dendrogram\",                  myXStringSet=rna,                  reconstruct=TRUE) #> ================================================================================ #> Optimizing model parameters: JC69     -ln(L) = 53341, AICc = 107631, BIC = 109168 JC69+G4  -ln(L) = 46743, AICc = 94439, BIC = 95978 K80      -ln(L) = 52567, AICc = 106087, BIC = 107627 K80+G4   -ln(L) = 45922, AICc = 92800, BIC = 94343 F81      -ln(L) = 53311, AICc = 107582, BIC = 109129 F81+G4   -ln(L) = 46709, AICc = 94383, BIC = 95933 HKY85    -ln(L) = 52552, AICc = 106068, BIC = 107618 HKY85+G4 -ln(L) = 45878, AICc = 92725, BIC = 94279 T92      -ln(L) = 52556, AICc = 106068, BIC = 107611 T92+G4   -ln(L) = 45908, AICc = 92777, BIC = 94323 TN93     -ln(L) = 52391, AICc = 105750, BIC = 107303 TN93+G4  -ln(L) = 45831, AICc = 92635, BIC = 94191 SYM      -ln(L) = 52446, AICc = 105860, BIC = 107413 SYM+G4   -ln(L) = 45863, AICc = 92698, BIC = 94254 GTR      -ln(L) = 52258, AICc = 105497, BIC = 107060 GTR+G4   -ln(L) = 45812, AICc = 92607, BIC = 94174 #>  #> The selected model was:  GTR+G4 #>  #> Model parameters: #> Frequency(A) = 0.257 #> Frequency(C) = 0.177 #> Frequency(G) = 0.368 #> Frequency(T) = 0.198 #> Rate A <-> C = 1.050 #> Rate A <-> G = 1.846 #> Rate A <-> T = 1.597 #> Rate C <-> G = 0.868 #> Rate C <-> T = 4.196 #> Rate G <-> T = 1.000 #> Alpha = 0.303 #>  #> Time difference of 59.32 secs #>   out <- MapCharacters(tree,                      labelEdges=TRUE,                      type=\"both\",                      chars=RNA_BASES)  # plot the tree with defaults tree <- out[[1]] plot(tree, horiz=TRUE) # edges show number of changes   # color edges by number of changes maxC <- 200 # changes at maximum of color spectrum colors <- colorRampPalette(c(\"black\", \"darkgreen\", \"green\"))(maxC) colorEdges <- function(x) {    num <- attr(x, \"edgetext\") + 1    if (length(num)==0)        return(x)    if (num > maxC)        num <- maxC    attr(x, \"edgePar\") <- list(col=colors[num])    attr(x, \"edgetext\") <- NULL    return(x) } colorfulTree <- dendrapply(tree, colorEdges) plot(colorfulTree, horiz=TRUE, leaflab=\"none\")   # look at parallel changes (X->Y) parallel <- out[[2]] head(parallel) # parallel changes #>  #> A1406U  C606U   C80U  G637A  A647G C1003G  #>     27     18     18     18     17     17   # look at convergent changes (*->Y) convergent <- gsub(\".*?([0-9]+.*)\", \"\\\\1\", names(parallel)) convergent <- tapply(parallel, convergent, sum) convergent <- sort(convergent, decreasing=TRUE) head(convergent) #> 1406U  838G 1003G 1000C 1273U  147A  #>    27    21    20    18    18    18   # look at divergent changes (X->*) divergent <- gsub(\"(.*[0-9]+).*\", \"\\\\1\", names(parallel)) divergent <- tapply(parallel, divergent, sum) divergent <- sort(divergent, decreasing=TRUE) head(divergent) #>  U577  U578  A647 C1003 C1004  U476  #>    35    33    32    31    31    31   # plot number of changes by position changes <- gsub(\".*?([0-9]+).*\", \"\\\\1\", names(parallel)) changes <- tapply(parallel, changes, sum) plot(as.numeric(names(changes)),      changes,      xlab=\"Position\",      ylab=\"Total independent changes\")   # count cases of potential compensatory mutations compensatory <- dendrapply(tree,     function(x) {         change <- attr(x, \"change\")         pos <- as.numeric(gsub(\".*?([0-9]+).*\", \"\\\\1\", change))         e <- expand.grid(seq_along(pos), seq_along(pos))         e <- e[pos[e[, 1]] < pos[e[, 2]],]         list(paste(change[e[, 1]], change[e[, 2]], sep=\" & \"))     }) compensatory <- unlist(compensatory) u <- unique(compensatory) m <- match(compensatory, u) m <- tabulate(m, length(u)) compensatory <- sort(setNames(m, u), decreasing=TRUE) head(compensatory) # ranked list of concurrent mutations #>   C362G & G367C  G978A & C1223U   A241G & U251C   C887U & G894A    C98U & G109A  #>              13              10               9               9               8  #> U1116C & A1159G  #>               8"},{"path":"/reference/MaskAlignment.html","id":null,"dir":"Reference","previous_headings":"","what":"Mask Highly Variable Regions of An Alignment — MaskAlignment","title":"Mask Highly Variable Regions of An Alignment — MaskAlignment","text":"Automatically masks poorly aligned regions alignment based sequence conservation gap frequency.","code":""},{"path":"/reference/MaskAlignment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mask Highly Variable Regions of An Alignment — MaskAlignment","text":"","code":"MaskAlignment(   myXStringSet,   type = \"sequences\",   windowSize = 5,   threshold = 1,   maxFractionGaps = 0.2,   includeTerminalGaps = FALSE,   correction = FALSE,   randomBackground = FALSE,   showPlot = FALSE )"},{"path":"/reference/MaskAlignment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mask Highly Variable Regions of An Alignment — MaskAlignment","text":"myXStringSet AAStringSet, DNAStringSet, RNAStringSet object aligned sequences. type Character string indicating type result desired.  (abbreviation ) one \"sequences\", \"ranges\", \"values\".  (See value section .) windowSize Integer value specifying size region left right center-point use calculating moving average. threshold Numeric giving average entropy bits region masked. maxFractionGaps Numeric specifying maximum faction gaps alignment column masked. includeTerminalGaps Logical specifying whether include terminal gaps (\".\" \"-\" characters end sequences) calculation gap fraction. correction Logical indicating whether apply small-sample size correction columns letters (Yu et al., 2015). randomBackground Logical determining whether background letter frequencies determined directly myXStringSet (default) uniform distribution letters. showPlot Logical specifying whether show plot positions kept masked.","code":""},{"path":"/reference/MaskAlignment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mask Highly Variable Regions of An Alignment — MaskAlignment","text":"type \"sequences\" MultipleAlignment object input type masked columns input criteria met. Otherwise, type \"ranges\" IRanges object giving start end positions masked columns.  Else (type \"values\") data.frame containing one row per site alignment three columns information: \"entropy\" entropy score column, units bits. \"gaps\" column, fraction gap characters (\"-\" \".\"). \"mask\" logical vector indicating whether column met criteria masking.","code":""},{"path":"/reference/MaskAlignment.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Mask Highly Variable Regions of An Alignment — MaskAlignment","text":"Poorly aligned regions multiple sequence alignment may lead incorrect results downstream analyses.  One method mitigate effects mask columns alignment may poorly aligned, highly-variable regions regions many insertions deletions (gaps). Highly variable regions detected signature low information content.  , information content defined relative entropy column alignment (Yu et al., 2015), higher conserved columns.  relative entropy based background distribution letter-frequencies alignment. moving average windowSize nucleotides left right center-point applied smooth noise information content signal along sequence.  Regions dropping threshold bits maxFractionGaps masked.","code":""},{"path":"/reference/MaskAlignment.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Mask Highly Variable Regions of An Alignment — MaskAlignment","text":"Yu, Y.-K., et al. (2015). Log-odds sequence logos. Bioinformatics, 31(3), 324-331. http://doi.org/10.1093/bioinformatics/btu634","code":""},{"path":[]},{"path":"/reference/MaskAlignment.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Mask Highly Variable Regions of An Alignment — MaskAlignment","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/MaskAlignment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mask Highly Variable Regions of An Alignment — MaskAlignment","text":"","code":"fas <- system.file(\"extdata\", \"Streptomyces_ITS_aligned.fas\", package=\"DECIPHER\") dna <- readDNAStringSet(fas) masked_dna <- MaskAlignment(dna, showPlot=TRUE)   # display only unmasked nucleotides for use in downstream analyses not_masked <- as(masked_dna, \"DNAStringSet\") BrowseSeqs(not_masked)  # display only masked nucleotides that are covered by the mask masked <- masked_dna colmask(masked, append=\"replace\", invert=TRUE) <- colmask(masked) masked <- as(masked, \"DNAStringSet\") BrowseSeqs(masked)  # display the complete DNA sequence set including the mask masks <- lapply(width(colmask(masked_dna)), rep, x=\"+\") masks <- unlist(lapply(masks, paste, collapse=\"\")) masked_dna <- replaceAt(dna, at=IRanges(colmask(masked_dna)), value=masks) BrowseSeqs(masked_dna)  # get the start and end ranges of masked columns ranges <- MaskAlignment(dna, type=\"ranges\") ranges #> IRanges object with 13 ranges and 0 metadata columns: #>            start       end     width #>        <integer> <integer> <integer> #>    [1]        19        19         1 #>    [2]       170       213        44 #>    [3]       230       230         1 #>    [4]       235       235         1 #>    [5]       267       286        20 #>    ...       ...       ...       ... #>    [9]       378       394        17 #>   [10]       399       406         8 #>   [11]       418       418         1 #>   [12]       420       442        23 #>   [13]       495       496         2 replaceAt(dna, ranges) # remove the masked columns #> DNAStringSet object of length 88: #>      width seq                                              names                #>  [1]   473 TGTACACACCGCCCGTCACGTCA...GGGGTTTCCGAATGGGGAAACC supercont3.1 of S... #>  [2]   473 NNNNCACACCGCCCGTCACGTCA...GGGGTTTCCGAATGGGGAAACC supercont3.1 of S... #>  [3]   473 TGTACACACCGCCCGTCACGTCA...GGGGTTTCCGAATGGGGAAACC supercont1.1 of S... #>  [4]   473 CGTACACACCGCCCGTCACGTCA...GGGGTTTCCGAATGGGGAAACC supercont1.1 of S... #>  [5]   473 TGTACACACCGCCCGTCACGTCA...GGGGTTTCCGAATGGGGAAACC supercont1.1 of S... #>  ...   ... ... #> [84]   473 TGTACACACCGCCCGTCACGTCA...GGGGTTTCCGAATGGGGAAACC gi|297189896|ref|... #> [85]   473 TGTACACACCGCCCGTCACGTCA...GGGGTGTCCGAATGGGGAAACC gi|224581106|ref|... #> [86]   473 TGTACACACCGCCCGTCACGTCA...GGGGTGTCCGAATGGGGAAACC gi|224581106|ref|... #> [87]   473 TGTACACACCGCCCGTCACGTCA...GGGGTGTCCGAATGGGGAAACC gi|224581106|ref|... #> [88]   473 TGTACACACCGCCCGTCACGTCA...GGGGTTTCCGAATGGGGAAACC gi|224581108|ref|...  # obtain the entropy scores of each column values <- MaskAlignment(dna, type=\"values\") head(values) #>    entropy gaps  mask #> 1 1.895882    0 FALSE #> 2 1.260362    0 FALSE #> 3 1.964568    0 FALSE #> 4 2.087429    0 FALSE #> 5 1.889936    0 FALSE #> 6 2.211969    0 FALSE"},{"path":"/reference/MeltDNA.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Melting of DNA — MeltDNA","title":"Simulate Melting of DNA — MeltDNA","text":"denaturation double-stranded DNA occurs range temperatures. Beginning helical state, DNA transition random-coil state temperature increased.  MeltDNA predicts positional helicity, melt curve, negative derivate different temperatures.","code":""},{"path":"/reference/MeltDNA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Melting of DNA — MeltDNA","text":"","code":"MeltDNA(myDNAStringSet, type = \"derivative\", temps = 50:100, ions = 0.2)"},{"path":"/reference/MeltDNA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Melting of DNA — MeltDNA","text":"myDNAStringSet DNAStringSet object character vector one sequences 5' 3' orientation. type Character string indicating type results desired.  (abbreviation ) one \"derivative curves\", \"melt curves\", \"positional probabilities\". temps Numeric vector temperatures (degrees Celsius). ions Numeric giving molar sodium equivalent ionic concentration. Values must least 0.01M.","code":""},{"path":"/reference/MeltDNA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Melting of DNA — MeltDNA","text":"MeltDNA can return three types results: positional helicity, melting curves, negative derivative melting curves. type \"position\", list returned one component sequence myDNAStringSet.  list component contains matrix probability helicity (Theta) temperature (rows) every position sequence (columns). type \"melt\", matrix average Theta across entire sequence returned.  matrix row input temperature (temps), column sequence myDNAStringSet.  example, value element [3, 4] average helicity fourth input sequence third input temperature.  type \"derivative\" values matrix derivative melt curve temperature.","code":""},{"path":"/reference/MeltDNA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Melting of DNA — MeltDNA","text":"designing high resolution melt (HRM) assay, useful able predict results performing experiment.  Multi-state models DNA melting can provide near-qualitative agreement experimental DNA melt curves obtained quantitative PCR (qPCR).  MeltDNA employs algorithm Tostesen et al. (2003) approximation loop entropy runs nearly linear time memory, allows long DNA sequences (100,000 base pairs) analyzed. Denaturation highly cooperative process whereby regions double-stranded DNA tend melt together.  short sequences (< 100 base pairs) typically single transition helical random-coil state.  Longer sequences may exhibit complex melting behavior multiple peaks, domains DNA melt different temperatures.  melting curve represents average fractional helicity (Theta) temperature, can used genotyping high resolution melt analysis.","code":""},{"path":"/reference/MeltDNA.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Simulate Melting of DNA — MeltDNA","text":"MeltDNA uses nearest neighbor parameters SantaLucia (1998).","code":""},{"path":"/reference/MeltDNA.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate Melting of DNA — MeltDNA","text":"SantaLucia, J. (1998). unified view polymer, dumbbell, oligonucleotide DNA nearest-neighbor thermodynamics. Proceedings National Academy Sciences, 95(4), 1460-1465. Tostesen, E., et al. (2003). Speed-DNA melting algorithm complete nearest neighbor properties. Biopolymers, 70(3), 364-376. doi:10.1002/bip.10495.","code":""},{"path":[]},{"path":"/reference/MeltDNA.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate Melting of DNA — MeltDNA","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/MeltDNA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Melting of DNA — MeltDNA","text":"","code":"fas <- system.file(\"extdata\", \"IDH2.fas\", package=\"DECIPHER\") dna <- readDNAStringSet(fas)  # plot the melt curve for the two alleles temps <- seq(85, 100, 0.2) m <- MeltDNA(dna,              type=\"melt\", temps=temps, ions=0.1) matplot(temps, m,         type=\"l\", xlab=\"Temperature (\\u00B0C)\", ylab=\"Average Theta\") legend(\"topright\", names(dna), lty=seq_along(dna), col=seq_along(dna))   # plot the negative derivative curve for a subsequence of the two alleles temps <- seq(80, 95, 0.25) m <- MeltDNA(subseq(dna, 492, 542),              type=\"derivative\", temps=temps) matplot(temps, m,         type=\"l\", xlab=\"Temperature (\\u00B0C)\", ylab=\"-d(Theta)/dTemp\") legend(\"topright\", names(dna), lty=seq_along(dna), col=seq_along(dna))   # plot the positional helicity profile for the IDH2 allele temps <- seq(90.1, 90.5, 0.1) m <- MeltDNA(dna[1],              type=\"position\", temps=temps, ions=0.1) matplot(seq_len(dim(m[[1]])[2]), t(m[[1]]),         type=\"l\", xlab=\"Nucleotide Position\", ylab=\"Theta\") temps <- formatC(temps, digits=1, format=\"f\") legend(\"topright\", legend=paste(temps, \"\\u00B0C\", sep=\"\"),         col=seq_along(temps), lty=seq_along(temps), bg=\"white\")"},{"path":"/reference/NNLS.html","id":null,"dir":"Reference","previous_headings":"","what":"Sequential Coordinate-wise Algorithm for the Non-negative Least Squares\nProblem — NNLS","title":"Sequential Coordinate-wise Algorithm for the Non-negative Least Squares\nProblem — NNLS","text":"Consider linear system \\(\\bold{} x = b\\) \\(\\bold{} \\R\\textsuperscript{m x n}\\), \\(x \\R\\textsuperscript{n}\\), \\(b \\R\\textsuperscript{m}\\).  technique least squares proposes compute \\(x\\) sum squared residuals minimized.  NNLS solves least squares problem \\(\\min{||\\bold{} x = b||\\textsuperscript{2}}\\) subject constraint \\(x \\ge 0\\).  implementation Sequential Coordinate-wise Algorithm uses sparse input matrix \\(\\bold{}\\), makes efficient large sparse problems.","code":""},{"path":"/reference/NNLS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sequential Coordinate-wise Algorithm for the Non-negative Least Squares\nProblem — NNLS","text":"","code":"NNLS(   A,   b,   precision = sqrt(.Machine$double.eps),   processors = 1,   verbose = TRUE )"},{"path":"/reference/NNLS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sequential Coordinate-wise Algorithm for the Non-negative Least Squares\nProblem — NNLS","text":"List representing sparse matrix integer components j, numeric component x.  fourth component, dimnames, list two components contains names every row (component 1) column (component 2). b Numeric matrix set observed values.  (See details section .) precision desired accuracy. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display progress.","code":""},{"path":"/reference/NNLS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sequential Coordinate-wise Algorithm for the Non-negative Least Squares\nProblem — NNLS","text":"list two components: x matrix non-negative values best explains observed values given \\(b\\). res matrix residuals given \\(\\bold{} x - b\\).","code":""},{"path":"/reference/NNLS.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sequential Coordinate-wise Algorithm for the Non-negative Least Squares\nProblem — NNLS","text":"input \\(b\\) can either matrix vector numerics.  matrix assumed column contains set observations, output \\(x\\) number columns.  allows multiple NNLS problems using \\(\\bold{}\\) matrix solved simultaneously, greatly accelerates computation relative solving sequentially.","code":""},{"path":"/reference/NNLS.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Sequential Coordinate-wise Algorithm for the Non-negative Least Squares\nProblem — NNLS","text":"Franc, V., et al. (2005). Sequential coordinate-wise algorithm non-negative least squares problem.  Computer Analysis Images Patterns, 407-414.","code":""},{"path":[]},{"path":"/reference/NNLS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sequential Coordinate-wise Algorithm for the Non-negative Least Squares\nProblem — NNLS","text":"","code":"# unconstrained least squares: A <- matrix(c(1, -3, 2, -3, 10, -5, 2, -5, 6), ncol=3) b <- matrix(c(27, -78, 64), ncol=1) x <- solve(crossprod(A), crossprod(A, b))  # Non-negative least squares: w <- which(A > 0, arr.ind=TRUE) A <- list(i=w[,\"row\"], j=w[,\"col\"], x=A[w],           dimnames=list(1:dim(A)[1], 1:dim(A)[2])) x_nonneg <- NNLS(A, b) #> ================================================================================ #>  #> Time difference of 0 secs #>   # compare the unconstrained and constrained solutions: cbind(x, x_nonneg$x) #>   [,1] [,2] #> 1    1   17 #> 2   -4    0 #> 3    7    5  # the input value \"b\" can also be a matrix: b2 <- matrix(b, nrow=length(b), ncol=2) # repeat b in two columns x_nonneg <- NNLS(A, b2) # solution is repeated in two output columns #> ================================================================================ #>  #> Time difference of 0 secs #>"},{"path":"/reference/NonCoding.html","id":null,"dir":"Reference","previous_headings":"","what":"NonCoding Objects and Methods — NonCoding","title":"NonCoding Objects and Methods — NonCoding","text":"Non-coding RNAs can represented conserved sequence motifs, secondary structure, k-mer frequencies.  Class NonCoding provides objects functions representing non-coding RNAs. Non-coding RNAs can represented conserved sequence motifs, secondary structure, k-mer frequencies.  Class NonCoding provides objects functions representing non-coding RNAs.","code":""},{"path":"/reference/NonCoding.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NonCoding Objects and Methods — NonCoding","text":"x object class NonCoding. ... optional parameters.","code":""},{"path":"/reference/NonCoding.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"NonCoding Objects and Methods — NonCoding","text":"Objects class NonCoding stored lists containing compact representation family non-coding RNAs.  first list component matrix sequence motifs identify non-coding RNAs, second matrix hairpin loops conserved across family, third list k-mer frequencies derived representative sequences, fourth vector log-odds scores sequence lengths.  optional fifth list component denotes log-odds scores dependencies among patterns.  Patterns defined distance either end non-coding RNA, helps identify boundaries non-coding RNA genome. Objects class NonCoding stored lists containing compact representation family non-coding RNAs.  first list component matrix sequence motifs identify non-coding RNAs, second matrix hairpin loops conserved across family, third list k-mer frequencies derived representative sequences, fourth vector log-odds scores sequence lengths.  optional fifth list component denotes log-odds scores dependencies among patterns.  Patterns defined distance either end non-coding RNA, helps identify boundaries non-coding RNA genome.","code":""},{"path":"/reference/NonCoding.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"NonCoding Objects and Methods — NonCoding","text":"Wright, E. S. (2021). FindNonCoding: rapid simple detection non-coding RNAs genomes. Bioinformatics. https://doi.org/10.1093/bioinformatics/btab708 Wright, E. S. (2021). FindNonCoding: rapid simple detection non-coding RNAs genomes. Bioinformatics. https://doi.org/10.1093/bioinformatics/btab708","code":""},{"path":[]},{"path":"/reference/NonCoding.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"NonCoding Objects and Methods — NonCoding","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/NonCoding.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NonCoding Objects and Methods — NonCoding","text":"","code":"data(NonCodingRNA_Bacteria) x <- NonCodingRNA_Bacteria print(x) #> $`tRNA-Ala` #> NonCoding object with 10 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Arg` #> NonCoding object with 7 motifs, 4 hairpins, and 4-mer frequencies. #>  #> $`tRNA-Asn` #> NonCoding object with 9 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Asp` #> NonCoding object with 9 motifs, 2 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Cys` #> NonCoding object with 8 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Gln` #> NonCoding object with 10 motifs, 3 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Glu` #> NonCoding object with 8 motifs, 3 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Gly` #> NonCoding object with 9 motifs, 3 hairpins, and 4-mer frequencies. #>  #> $`tRNA-His` #> NonCoding object with 10 motifs, 2 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Ile` #> NonCoding object with 8 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Leu` #> NonCoding object with 11 motifs, 4 hairpins, and 4-mer frequencies. #>  #> $`tRNA-Lys` #> NonCoding object with 9 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Met` #> NonCoding object with 11 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Phe` #> NonCoding object with 9 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Pro` #> NonCoding object with 10 motifs, 3 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Ser` #> NonCoding object with 10 motifs, 4 hairpins, and 4-mer frequencies. #>  #> $`tRNA-Thr` #> NonCoding object with 10 motifs, 3 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Trp` #> NonCoding object with 10 motifs, 3 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Tyr` #> NonCoding object with 14 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Val` #> NonCoding object with 8 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Sec` #> NonCoding object with 20 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`rRNA_5S-RF00001` #> NonCoding object with 20 motifs, 4 hairpins, and 4-mer frequencies. #>  #> $`rRNA_16S-RF00177` #> NonCoding object with 8 motifs, 20 hairpins, and 4-mer frequencies. #>  #> $`rRNA_23S-RF02541` #> NonCoding object with 11 motifs, 20 hairpins, and 4-mer frequencies. #>  #> $`tmRNA-RF00023` #> NonCoding object with 20 motifs, 6 hairpins, and 4-mer frequencies. #>  #> $`tmRNA_Alpha-RF01849` #> NonCoding object with 17 motifs, 10 hairpins, and 4-mer frequencies. #>  #> $`RNase_P_class_A-RF00010` #> NonCoding object with 20 motifs, 13 hairpins, and 4-mer frequencies. #>  #> $`RNase_P_class_B-RF00011` #> NonCoding object with 15 motifs, 13 hairpins, and 4-mer frequencies. #>  #> $`SsrS-RF00013` #> NonCoding object with 14 motifs, 4 hairpins, and 4-mer frequencies. #>  #> $`Intron_Gp_I-RF00028` #> NonCoding object with 15 motifs, 3 hairpins, and 4-mer frequencies. #>  #> $`Intron_Gp_II-RF00029` #> NonCoding object with 9 motifs, 2 hairpins, and 4-mer frequencies. #>  #> $`SmallSRP-RF00169` #> NonCoding object with 16 motifs, 5 hairpins, and 4-mer frequencies. #>  #> $`Cyclic-di-GMP_Riboswitch-RF01051` #> NonCoding object with 14 motifs, 3 hairpins, and 4-mer frequencies. #>  #> $`Cyclic-di-AMP_Riboswitch-RF00379` #> NonCoding object with 19 motifs, 4 hairpins, and 4-mer frequencies. #>  #> $`T-box_Leader-RF00230` #> NonCoding object with 20 motifs, 7 hairpins, and 4-mer frequencies. #>  #> $`Ribosomal_Protein_L10_Leader-RF00557` #> NonCoding object with 11 motifs, 2 hairpins, and 4-mer frequencies. #>  #> $`Cobalamin_Riboswitch-RF00174` #> NonCoding object with 11 motifs, 7 hairpins, and 4-mer frequencies. #>  #> $`TPP_Riboswitch-RF00059` #> NonCoding object with 10 motifs, 4 hairpins, and 4-mer frequencies. #>  #> $`SAM_Riboswitch-RF00162` #> NonCoding object with 14 motifs, 5 hairpins, and 4-mer frequencies. #>  #> $`Fluoride_Riboswitch-RF01734` #> NonCoding object with 9 motifs, 3 hairpins, and 4-mer frequencies. #>  #> $`FMN_Riboswitch-RF00050` #> NonCoding object with 12 motifs, 6 hairpins, and 4-mer frequencies. #>  #> $`Glycine_Riboswitch-RF00504` #> NonCoding object with 10 motifs, 3 hairpins, and 4-mer frequencies. #>  #> $`HEARO-RF02033` #> NonCoding object with 17 motifs, 3 hairpins, and 4-mer frequencies. #>  #> $`Flavo_1-RF01705` #> NonCoding object with 8 motifs, 2 hairpins, and 4-mer frequencies. #>  #> $`Acido_Lenti_1-RF01687` #> NonCoding object with 6 motifs, 2 hairpins, and 3-mer frequencies. #>  #> $`5'_ureB-RF02514` #> NonCoding object with 10 motifs, 1 hairpin, and 4-mer frequencies. #>  class(x) #> [1] \"list\" attributes(x[[1]]) #> $names #> [1] \"motifs\"       \"hairpins\"     \"kmers\"        \"lengthScores\" \"dependence\"   #>  #> $class #> [1] \"NonCoding\" #>  #> $K #> [1] 3 #>  #> $minLength #> [1] 47 #>  #> $maxLength #> [1] 154 #>  #> $maxLoopLength #> [1] 500 #>  #> $background #> meanlog   sdlog  #>      NA      NA  #>  x[[1]] # the first non-coding RNA #> NonCoding object with 10 motifs, 4 hairpins, and 3-mer frequencies. x[[1]][[\"motifs\"]] # sequence motifs #>    begin_low begin_high end_low end_high          motif          pwm #> 1          0          0      66       68       GGGGcydT 6.190340.... #> 2          8          8      58       60       AGCTCAGy 0.887309.... #> 3         16         16      55       57            TGG 0.005205.... #> 4         19         20      43       45   kAGAGCrCyTsc 0.024808.... #> 5         31         32      29       31 wTkGCAwksArGRG 0.261497.... #> 6         45         46      21       23       GTCrgsGG 0.016786.... #> 7         53         54      12       14      TTCGAwyCC 6.189574.... #> 8         62         63       1        3    scThrkCTCCA 6.190340.... #> 9         73         73       0        2              C 0.011661.... #> 10        74         74       0        0             CA 0.024090.... #>        minscore   prevalence   background #> 1  0, 6.546.... 0.094171.... 0.990257.... #> 2  0, 7.992.... 0.122470.... 0.997144.... #> 3        0, Inf 0.171047.... 0.947469.... #> 4  0, 8.836.... 0.074318.... 0.993209.... #> 5  0, 10.15.... 0.078148.... 0.998369.... #> 6  0, 5.741.... 0.095427.... 0.967199.... #> 7  0, 1.188.... 0.095427.... 0.998925.... #> 8  0, 7.637.... 0.095427.... 0.994214.... #> 9        0, Inf 0.301436.... 0.727689.... #> 10       0, Inf 0.363336.... 0.950034.... x[[1]][[\"hairpins\"]] # hairpin loops #>   begin_low begin_high end_low end_high width_low width_high length_low #> 1        -4          0      -3        4        72         81          8 #> 2         9          9      49       51        16         16          5 #> 3        14         14      23       25        37         38          5 #> 4        24         25      29       31        21         21          7 #>   length_high           dG   prevalence   background #> 1          13 -Inf, -1.... 0.159193.... 0.014745.... #> 2           6 -Inf, -3.... 0.736407.... 0.006730.... #> 3           6 -Inf, -3.... 0.155095.... 0.013687.... #> 4           9 -Inf, -8.... 0.302477.... 0.001134.... head(x[[1]][[\"kmers\"]]) # k-mer frequencies #> [1]  189  872  435  151  113 1742    data(NonCodingRNA_Bacteria) x <- NonCodingRNA_Bacteria print(x) #> $`tRNA-Ala` #> NonCoding object with 10 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Arg` #> NonCoding object with 7 motifs, 4 hairpins, and 4-mer frequencies. #>  #> $`tRNA-Asn` #> NonCoding object with 9 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Asp` #> NonCoding object with 9 motifs, 2 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Cys` #> NonCoding object with 8 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Gln` #> NonCoding object with 10 motifs, 3 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Glu` #> NonCoding object with 8 motifs, 3 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Gly` #> NonCoding object with 9 motifs, 3 hairpins, and 4-mer frequencies. #>  #> $`tRNA-His` #> NonCoding object with 10 motifs, 2 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Ile` #> NonCoding object with 8 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Leu` #> NonCoding object with 11 motifs, 4 hairpins, and 4-mer frequencies. #>  #> $`tRNA-Lys` #> NonCoding object with 9 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Met` #> NonCoding object with 11 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Phe` #> NonCoding object with 9 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Pro` #> NonCoding object with 10 motifs, 3 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Ser` #> NonCoding object with 10 motifs, 4 hairpins, and 4-mer frequencies. #>  #> $`tRNA-Thr` #> NonCoding object with 10 motifs, 3 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Trp` #> NonCoding object with 10 motifs, 3 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Tyr` #> NonCoding object with 14 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Val` #> NonCoding object with 8 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Sec` #> NonCoding object with 20 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`rRNA_5S-RF00001` #> NonCoding object with 20 motifs, 4 hairpins, and 4-mer frequencies. #>  #> $`rRNA_16S-RF00177` #> NonCoding object with 8 motifs, 20 hairpins, and 4-mer frequencies. #>  #> $`rRNA_23S-RF02541` #> NonCoding object with 11 motifs, 20 hairpins, and 4-mer frequencies. #>  #> $`tmRNA-RF00023` #> NonCoding object with 20 motifs, 6 hairpins, and 4-mer frequencies. #>  #> $`tmRNA_Alpha-RF01849` #> NonCoding object with 17 motifs, 10 hairpins, and 4-mer frequencies. #>  #> $`RNase_P_class_A-RF00010` #> NonCoding object with 20 motifs, 13 hairpins, and 4-mer frequencies. #>  #> $`RNase_P_class_B-RF00011` #> NonCoding object with 15 motifs, 13 hairpins, and 4-mer frequencies. #>  #> $`SsrS-RF00013` #> NonCoding object with 14 motifs, 4 hairpins, and 4-mer frequencies. #>  #> $`Intron_Gp_I-RF00028` #> NonCoding object with 15 motifs, 3 hairpins, and 4-mer frequencies. #>  #> $`Intron_Gp_II-RF00029` #> NonCoding object with 9 motifs, 2 hairpins, and 4-mer frequencies. #>  #> $`SmallSRP-RF00169` #> NonCoding object with 16 motifs, 5 hairpins, and 4-mer frequencies. #>  #> $`Cyclic-di-GMP_Riboswitch-RF01051` #> NonCoding object with 14 motifs, 3 hairpins, and 4-mer frequencies. #>  #> $`Cyclic-di-AMP_Riboswitch-RF00379` #> NonCoding object with 19 motifs, 4 hairpins, and 4-mer frequencies. #>  #> $`T-box_Leader-RF00230` #> NonCoding object with 20 motifs, 7 hairpins, and 4-mer frequencies. #>  #> $`Ribosomal_Protein_L10_Leader-RF00557` #> NonCoding object with 11 motifs, 2 hairpins, and 4-mer frequencies. #>  #> $`Cobalamin_Riboswitch-RF00174` #> NonCoding object with 11 motifs, 7 hairpins, and 4-mer frequencies. #>  #> $`TPP_Riboswitch-RF00059` #> NonCoding object with 10 motifs, 4 hairpins, and 4-mer frequencies. #>  #> $`SAM_Riboswitch-RF00162` #> NonCoding object with 14 motifs, 5 hairpins, and 4-mer frequencies. #>  #> $`Fluoride_Riboswitch-RF01734` #> NonCoding object with 9 motifs, 3 hairpins, and 4-mer frequencies. #>  #> $`FMN_Riboswitch-RF00050` #> NonCoding object with 12 motifs, 6 hairpins, and 4-mer frequencies. #>  #> $`Glycine_Riboswitch-RF00504` #> NonCoding object with 10 motifs, 3 hairpins, and 4-mer frequencies. #>  #> $`HEARO-RF02033` #> NonCoding object with 17 motifs, 3 hairpins, and 4-mer frequencies. #>  #> $`Flavo_1-RF01705` #> NonCoding object with 8 motifs, 2 hairpins, and 4-mer frequencies. #>  #> $`Acido_Lenti_1-RF01687` #> NonCoding object with 6 motifs, 2 hairpins, and 3-mer frequencies. #>  #> $`5'_ureB-RF02514` #> NonCoding object with 10 motifs, 1 hairpin, and 4-mer frequencies. #>  class(x) #> [1] \"list\" attributes(x[[1]]) #> $names #> [1] \"motifs\"       \"hairpins\"     \"kmers\"        \"lengthScores\" \"dependence\"   #>  #> $class #> [1] \"NonCoding\" #>  #> $K #> [1] 3 #>  #> $minLength #> [1] 47 #>  #> $maxLength #> [1] 154 #>  #> $maxLoopLength #> [1] 500 #>  #> $background #> meanlog   sdlog  #>      NA      NA  #>  x[[1]] # the first non-coding RNA #> NonCoding object with 10 motifs, 4 hairpins, and 3-mer frequencies. x[[1]][[\"motifs\"]] # sequence motifs #>    begin_low begin_high end_low end_high          motif          pwm #> 1          0          0      66       68       GGGGcydT 6.190340.... #> 2          8          8      58       60       AGCTCAGy 0.887309.... #> 3         16         16      55       57            TGG 0.005205.... #> 4         19         20      43       45   kAGAGCrCyTsc 0.024808.... #> 5         31         32      29       31 wTkGCAwksArGRG 0.261497.... #> 6         45         46      21       23       GTCrgsGG 0.016786.... #> 7         53         54      12       14      TTCGAwyCC 6.189574.... #> 8         62         63       1        3    scThrkCTCCA 6.190340.... #> 9         73         73       0        2              C 0.011661.... #> 10        74         74       0        0             CA 0.024090.... #>        minscore   prevalence   background #> 1  0, 6.546.... 0.094171.... 0.990257.... #> 2  0, 7.992.... 0.122470.... 0.997144.... #> 3        0, Inf 0.171047.... 0.947469.... #> 4  0, 8.836.... 0.074318.... 0.993209.... #> 5  0, 10.15.... 0.078148.... 0.998369.... #> 6  0, 5.741.... 0.095427.... 0.967199.... #> 7  0, 1.188.... 0.095427.... 0.998925.... #> 8  0, 7.637.... 0.095427.... 0.994214.... #> 9        0, Inf 0.301436.... 0.727689.... #> 10       0, Inf 0.363336.... 0.950034.... x[[1]][[\"hairpins\"]] # hairpin loops #>   begin_low begin_high end_low end_high width_low width_high length_low #> 1        -4          0      -3        4        72         81          8 #> 2         9          9      49       51        16         16          5 #> 3        14         14      23       25        37         38          5 #> 4        24         25      29       31        21         21          7 #>   length_high           dG   prevalence   background #> 1          13 -Inf, -1.... 0.159193.... 0.014745.... #> 2           6 -Inf, -3.... 0.736407.... 0.006730.... #> 3           6 -Inf, -3.... 0.155095.... 0.013687.... #> 4           9 -Inf, -8.... 0.302477.... 0.001134.... head(x[[1]][[\"kmers\"]]) # k-mer frequencies #> [1]  189  872  435  151  113 1742"},{"path":"/reference/NonCodingRNA.html","id":null,"dir":"Reference","previous_headings":"","what":"NonCoding Models for Common Non-Coding RNA Families — NonCodingRNA","title":"NonCoding Models for Common Non-Coding RNA Families — NonCodingRNA","text":"Pre-trained NonCoding models common RNA families found genomes organisms belonging domain life.","code":""},{"path":"/reference/NonCodingRNA.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"NonCoding Models for Common Non-Coding RNA Families — NonCodingRNA","text":"Models built sequences belonging families tRNADB-CE (http://trna.ie.niigata-u.ac.jp/cgi-bin/trnadb/index.cgi) Rfam (http://rfam.xfam.org).","code":""},{"path":"/reference/NonCodingRNA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"NonCoding Models for Common Non-Coding RNA Families — NonCodingRNA","text":"set NonCoding models contained named list.  Models built 1000 representative sequences per non-coding RNA family.","code":""},{"path":"/reference/NonCodingRNA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NonCoding Models for Common Non-Coding RNA Families — NonCodingRNA","text":"","code":"data(NonCodingRNA_Archaea) data(NonCodingRNA_Bacteria) data(NonCodingRNA_Eukarya) names(NonCodingRNA_Bacteria) #>  [1] \"tRNA-Ala\"                             #>  [2] \"tRNA-Arg\"                             #>  [3] \"tRNA-Asn\"                             #>  [4] \"tRNA-Asp\"                             #>  [5] \"tRNA-Cys\"                             #>  [6] \"tRNA-Gln\"                             #>  [7] \"tRNA-Glu\"                             #>  [8] \"tRNA-Gly\"                             #>  [9] \"tRNA-His\"                             #> [10] \"tRNA-Ile\"                             #> [11] \"tRNA-Leu\"                             #> [12] \"tRNA-Lys\"                             #> [13] \"tRNA-Met\"                             #> [14] \"tRNA-Phe\"                             #> [15] \"tRNA-Pro\"                             #> [16] \"tRNA-Ser\"                             #> [17] \"tRNA-Thr\"                             #> [18] \"tRNA-Trp\"                             #> [19] \"tRNA-Tyr\"                             #> [20] \"tRNA-Val\"                             #> [21] \"tRNA-Sec\"                             #> [22] \"rRNA_5S-RF00001\"                      #> [23] \"rRNA_16S-RF00177\"                     #> [24] \"rRNA_23S-RF02541\"                     #> [25] \"tmRNA-RF00023\"                        #> [26] \"tmRNA_Alpha-RF01849\"                  #> [27] \"RNase_P_class_A-RF00010\"              #> [28] \"RNase_P_class_B-RF00011\"              #> [29] \"SsrS-RF00013\"                         #> [30] \"Intron_Gp_I-RF00028\"                  #> [31] \"Intron_Gp_II-RF00029\"                 #> [32] \"SmallSRP-RF00169\"                     #> [33] \"Cyclic-di-GMP_Riboswitch-RF01051\"     #> [34] \"Cyclic-di-AMP_Riboswitch-RF00379\"     #> [35] \"T-box_Leader-RF00230\"                 #> [36] \"Ribosomal_Protein_L10_Leader-RF00557\" #> [37] \"Cobalamin_Riboswitch-RF00174\"         #> [38] \"TPP_Riboswitch-RF00059\"               #> [39] \"SAM_Riboswitch-RF00162\"               #> [40] \"Fluoride_Riboswitch-RF01734\"          #> [41] \"FMN_Riboswitch-RF00050\"               #> [42] \"Glycine_Riboswitch-RF00504\"           #> [43] \"HEARO-RF02033\"                        #> [44] \"Flavo_1-RF01705\"                      #> [45] \"Acido_Lenti_1-RF01687\"                #> [46] \"5'_ureB-RF02514\"                      head(NonCodingRNA_Bacteria) #> $`tRNA-Ala` #> NonCoding object with 10 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Arg` #> NonCoding object with 7 motifs, 4 hairpins, and 4-mer frequencies. #>  #> $`tRNA-Asn` #> NonCoding object with 9 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Asp` #> NonCoding object with 9 motifs, 2 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Cys` #> NonCoding object with 8 motifs, 4 hairpins, and 3-mer frequencies. #>  #> $`tRNA-Gln` #> NonCoding object with 10 motifs, 3 hairpins, and 3-mer frequencies. #>"},{"path":"/reference/OrientNucleotides.html","id":null,"dir":"Reference","previous_headings":"","what":"Orient Nucleotide Sequences — OrientNucleotides","title":"Orient Nucleotide Sequences — OrientNucleotides","text":"Orients nucleotide sequences match directionality complementarity specified reference sequences.","code":""},{"path":"/reference/OrientNucleotides.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Orient Nucleotide Sequences — OrientNucleotides","text":"","code":"OrientNucleotides(   myXStringSet,   reference = which.max(width(myXStringSet)),   type = \"sequences\",   orientation = \"all\",   threshold = 0.05,   verbose = TRUE,   processors = 1 )"},{"path":"/reference/OrientNucleotides.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Orient Nucleotide Sequences — OrientNucleotides","text":"myXStringSet DNAStringSet RNAStringSet unaligned sequences. reference index reference sequences (desired) orientation.  default first sequence maximum width used. type Character string indicating type results desired.  (abbreviation ) either \"sequences\", \"orientations\", \"\". orientation Character string(s) indicating allowed reorientation(s) non-reference sequences.  (abbreviation ) either \"\", \"reverse\", \"complement\", /\"\" (reverse complement). threshold Numeric giving decrease k-mer distance required adopt alternative orientation. verbose Logical indicating whether display progress. processors number processors use, NULL automatically detect use available processors.","code":""},{"path":"/reference/OrientNucleotides.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Orient Nucleotide Sequences — OrientNucleotides","text":"OrientNucleotides can return two types results: relative orientations sequences /reoriented sequences.  type \"sequences\" (default) reoriented sequences returned.  type \"orientations\" character vector returned specifies whether sequences reversed (\"r\"), complemented (\"c\"), reversed complemented (\"rc\"), orientation (\"\") reference sequences (marked NA).  type \"\" output list first component containing \"orientations\" second component containing \"sequences\".","code":""},{"path":"/reference/OrientNucleotides.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Orient Nucleotide Sequences — OrientNucleotides","text":"Biological sequences can sometimes inconsistent orientation interferes analysis.  OrientNucleotides reorient sequences changing directionality /complementarity match specified reference sequences set.  process works finding k-mer distance reference sequence(s) allowed orientation sequences.  Alternative orientations lessen distance least threshold adopted.  Note procedure requires moderately similar reference sequence available sequence needs reoriented.  Sequences corresponding reference unavailable likely left alone alternative orientations pass threshold. reason, recommended specify several markedly different sequences references.","code":""},{"path":[]},{"path":"/reference/OrientNucleotides.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Orient Nucleotide Sequences — OrientNucleotides","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/OrientNucleotides.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Orient Nucleotide Sequences — OrientNucleotides","text":"","code":"db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") dna <- SearchDB(db, remove=\"all\") #> Search Expression: #> select row_names, sequence from _Seqs where row_names in (select row_names #> from Seqs) #>  #> DNAStringSet of length: 175 #> Time difference of 0.01 secs #>  DNA <- dna # 175 sequences  # reorient subsamples of the first 169 sequences s <- sample(169, 30) DNA[s] <- reverseComplement(dna[s]) s <- sample(169, 30) DNA[s] <- reverse(dna[s]) s <- sample(169, 30) DNA[s] <- complement(dna[s])  DNA <- OrientNucleotides(DNA, reference=170:175) #> ======================================================================================================================================================================================================== #>  #> Time difference of 1.01 secs DNA==dna # all were correctly reoriented #>   [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  [46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  [61] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  [76] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  [91] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [106] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [121] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [136] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [151] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [166] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE"},{"path":"/reference/PFASUM.html","id":null,"dir":"Reference","previous_headings":"","what":"PFASUM Amino Acid Substitution Matrices — PFASUM","title":"PFASUM Amino Acid Substitution Matrices — PFASUM","text":"PFASUM amino acid substitution matrices defined Keul, F., et al. (2017).","code":""},{"path":"/reference/PFASUM.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"PFASUM Amino Acid Substitution Matrices — PFASUM","text":"format : num 1:25, 1:25, 1:90 0.9492 -1.7337 0.2764 1.8153 0.0364 ...  - attr(*, \"dimnames\")=List 3 ..$ : chr 1:25 \"\" \"R\" \"N\" \"D\" ...  ..$ : chr 1:25 \"\" \"R\" \"N\" \"D\" ...  ..$ : chr 1:90 \"11\" \"12\" \"13\" \"14\" ...","code":""},{"path":"/reference/PFASUM.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"PFASUM Amino Acid Substitution Matrices — PFASUM","text":"Keul, F., et al. (2017). PFASUM: substitution matrix Pfam structural alignments. BMC Bioinformatics, 18(1), 293.","code":""},{"path":"/reference/PFASUM.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"PFASUM Amino Acid Substitution Matrices — PFASUM","text":"Substitution matrix values represent log-odds observing aligned pair amino acids versus likelihood finding pair chance. PFASUM substitution matrices stored array named sub-matrix's similarity threshold.  (See examples section .)  cases values units third-bits (\\(log(odds\\ ratio)*3/log(2)\\)).","code":""},{"path":"/reference/PFASUM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PFASUM Amino Acid Substitution Matrices — PFASUM","text":"","code":"data(PFASUM) PFASUM31 <- PFASUM[,, \"31\"] # the PFASUM31 matrix PFASUM31[\"A\", \"R\"] # score for A/R pairing #> [1] -0.768  data(BLOSUM62) plot(BLOSUM62[1:20, 1:20], PFASUM31[1:20, 1:20]) abline(a=0, b=1)"},{"path":"/reference/PredictDBN.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict RNA Secondary Structure in Dot-Bracket Notation — PredictDBN","title":"Predict RNA Secondary Structure in Dot-Bracket Notation — PredictDBN","text":"Predicts consensus RNA secondary structure multiple sequence alignment using mutual information.","code":""},{"path":"/reference/PredictDBN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict RNA Secondary Structure in Dot-Bracket Notation — PredictDBN","text":"","code":"PredictDBN(   myXStringSet,   type = \"states\",   minOccupancy = 0.4,   impact = c(1, 1.2, 0.4, -1),   avgProdCorr = 1,   slope = 2,   shift = 1.3,   threshold = 0.4,   pseudoknots = 1,   weight = NA,   useFreeEnergy = TRUE,   deltaGrules = NULL,   processors = 1,   verbose = TRUE )"},{"path":"/reference/PredictDBN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict RNA Secondary Structure in Dot-Bracket Notation — PredictDBN","text":"myXStringSet DNAStringSet RNAStringSet object containing aligned sequences. type Character string indicating type results desired.  (unambiguous abbreviation ) one \"states\", \"pairs\", \"evidence\", \"scores\", \"structures\", \"search\".  (See value section .) minOccupancy Numeric specifying minimum occupancy (1 - fraction gaps) required include column alignment prediction. impact vector four elements giving weights /U, G/C, G/U, pairings, respectively.  last element impact penalty pairings inconsistent two positions paired (e.g., /- /C). avgProdCorr Numeric specifying weight average product correction (APC) term, described Buslje et al. (2009). slope Numeric giving slope sigmoid used convert mutual information values scores ranging zero one. shift Numeric giving relative shift sigmoid used convert mutual information values scores ranging zero one. threshold Numeric specifying score threshold consider positions pairing.  applicable type \"states\" \"pairs\". pseudoknots Integer indicating maximum order pseudoknots acceptable.  value 0 prevent pseudoknots structure, whereas 1 (default) search first-order psuedoknots.  used type \"states\" \"pairs\". weight Either numeric vector weights sequence, single number implying equal weights, NA (default) automatically calculate sequence weights based myXStringSet. useFreeEnergy Logical determining whether RNA free energy predictions incorporated along mutual information secondary structure prediction. deltaGrules Free energy rules possible base pairings quadruplets.  NULL, defaults pseudoenergies (deltaGrulesRNA).  applicable useFreeEnergies TRUE. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display progress.","code":""},{"path":"/reference/PredictDBN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict RNA Secondary Structure in Dot-Bracket Notation — PredictDBN","text":"type \"states\" (default), output character vector predicted secondary structure assignment position myXStringSet.  Standard dot-bracket notation (DBN) used, .'' signifies unpaired position, ('' )'' paired position, successive []'', {}'', <>'' indicate increasing order pseudoknots.  Columns minOccupancy denoted ``-'' character indicate contained many gaps included consensus structure. type \"pairs\", matrix returned one row base pairing three columns giving positions paired bases pseudoknot order. type \"evidence\", matrix returned one row base pairing three columns giving positions paired bases respective scores (greater equal threshold).  differs type  \"pairs\" \"evidence\" perform traceback.  Therefore, possible conflicting evidence single base evidence pairing multiple bases. type \"scores\", matrix three rows returned, values column represent maximum score state position.  Columns sum 1 position minOccupancy 0 otherwise. type \"structures\", output list one element sequence myXStringSet.  list element contains matrix dimension 3 (state) number nucleotides sequence.  Columns matrix sum zero nucleotide located position minOccupancy.  Otherwise, positions considered paired consistent pairing (.e., /U, C/G, G/U) consensus secondary structure. type \"search\" attempt made find additional secondary structure beyond positions exhibiting covariation.  First, anchors identified pairs covarying positions score threshold.  Next, regions anchors searched previously unidentified stem loops.  Finally, helices assigned score according length, .e. one minus probability finding many consecutive pairs within anchor boundaries chance.  Hence, output type  \"search\" find secondary structure outside consensus structure shared sequences, can identify secondary structure conserved alignment regions.","code":""},{"path":"/reference/PredictDBN.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict RNA Secondary Structure in Dot-Bracket Notation — PredictDBN","text":"PredictDBN employs extension method described Freyhult et al. (2005) determining consensus RNA secondary structure.  uses mutual information (\\(H\\)) measure find covarying positions multiple sequence alignment.  original method modified addition different weights type base pairing input sequence.  formula mutual information positions \\(\\) \\(j\\) becomes: $$H(,j) = \\sum_{XY \\bp}^{} \\left( impact(XY) \\cdot f_{,j}(XY) \\cdot \\log_2 \\left( \\frac{f_{,j}(XY)}{f_{}(X) \\cdot f_{j}(Y)} \\right) \\right)$$ , \\(bp\\) denotes base pairings /U, C/G, G/U; impact weight; \\(f\\) frequency single bases pairs weighted corresponding weight sequence. penalty added bases inconsistent pairing: $$H_{mod}(,j) = H(,j) + \\sum_{XY \\notin bp}^{} \\Big( impact(XY) \\cdot f_{,j}(XY) \\Big)$$ Next average product correction (Buslje et al., 2009) applied matrix \\(H\\): $$H_{APC}(,j) = H_{mod}(,j) - avgProdCorr \\cdot \\frac{\\overline{H_{mod}(,.)} \\cdot \\overline{H_{mod}(.,j)}}{\\overline{H_{mod}(.,.)}}$$ mutual information values rescaled 0 1 applying sigmoidal transformation, controlled shift slope: $$H_{final}(,j) = \\left( 1 + \\exp \\left( slope \\cdot log_e \\left( \\frac{H_{APC}(,j)}{shift \\cdot H_{APC}[n]} \\right) \\right) \\right)^{-1}$$ , \\(n\\) number positions minOccupancy divided two (.e., maximum possible number paired positions) \\(H_{APC}[n]\\) denotes \\(n^{th}\\) highest value matrix \\(H_{APC}\\). useFreeEnergies TRUE, mutual information supplemented probabalistic model folding based deltaGrules.  , palindromes sequence ranked free energy, converted probabilities base pairing assuming exponential distribution free energies.  tends improve predictive accuracy aligned sequences insufficiently diverse considerable evidence compensatory mutations. type \"states\" \"pairs\", secondary structure determined using variant Nussinov algorithm similar described Venkatachalam et al. (2014).  Pairings score threshold considered traceback.  psuedoknots greater 0, paired positions removed consideration method applied find pseudoknots. practice secondary structure prediction accurate input alignment high quality, contains wide diversity sequences, number sequences large, regions completely conserved across sequences, sequences span entire alignment (.e., partial/incomplete sequences).","code":""},{"path":"/reference/PredictDBN.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Predict RNA Secondary Structure in Dot-Bracket Notation — PredictDBN","text":"Buslje, C., et al. (2009). Correction phylogeny, small number observations data redundancy improves identification coevolving amino acid pairs using mutual information. Bioinformatics, 25(9), 1125-1131. Freyhult, E., et al. (2005). Predicting RNA Structure Using Mutual Information. Applied Bioinformatics, 4(1), 53-59. Venkatachalam, B., et al. (2014). Faster algorithms RNA-folding using Four-Russians method. Algorithms Molecular Biology : AMB, 9(1), 1-12. Wright, E. S. (2020). RNAconTest: comparing tools noncoding RNA multiple sequence alignment based structural consistency. RNA 2020, 26, 531-540.","code":""},{"path":[]},{"path":"/reference/PredictDBN.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Predict RNA Secondary Structure in Dot-Bracket Notation — PredictDBN","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/PredictDBN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict RNA Secondary Structure in Dot-Bracket Notation — PredictDBN","text":"","code":"# load the example non-coding RNA sequences db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") rna <- SearchDB(db, type=\"RNAStringSet\") #> Search Expression: #> select row_names, sequence from _Seqs where row_names in (select row_names #> from Seqs) #>  #> RNAStringSet of length: 175 #> Time difference of 0.01 secs #>   if (FALSE) { # predict the secondary structure in dot-bracket notation (dbn) p <- PredictDBN(rna, \"states\") # predict the secondary structure in dbn p # pairs are denoted by (), and (optionally) pseudoknots by [], {}, and <>  # convert the dot-bracket notation into pairs of positions within the alignment p <- PredictDBN(rna, \"pairs\") # paired positions in the alignment head(p) # matrix giving the pairs and their pseudoknot order (when > 0)  # plot an arc diagram with the base pairings plot(NA, xlim=c(0, 1), ylim=c(0, 1),   xaxs=\"i\", yaxs=\"i\",   xlab=\"Alignment position\", ylab=\"\",   bty=\"n\", xaxt=\"n\", yaxt=\"n\") ticks <- pretty(seq_len(width(rna)[1])) axis(1, ticks/width(rna)[1], ticks) rs <- c(seq(0, pi, len=100), NA) r <- (p[, 2] - p[, 1] + 1)/width(rna)[1]/2 r <- rep(r, each=101) x <- (p[, 1] + p[, 2])/2/width(rna)[1] x <- rep(x, each=101) + r*cos(rs) y <- r*sin(rs)/max(r, na.rm=TRUE) lines(x, y, xpd=TRUE)  # show all available evidence of base pairing p <- PredictDBN(rna, \"evidence\") # all pairs with scores >= threshold head(p) # matrix giving the pairs and their scores  # determine the score at every alignment position p <- PredictDBN(rna, \"scores\") # score in the alignment p[\"(\", 122] # score for left-pairing at alignment position 122 p[\")\", 260] # score for right-pairing at alignment position 260  # find the scores individually for every sequence in the alignment p <- PredictDBN(rna, \"structures\") # scores per sequence p[[1]][, 1] # the scores for the first position in the first sequence p[[2]][, 10] # the scores for the tenth position in the second sequence # these positional scores can be used as shades of red, green, and blue: BrowseSeqs(rna, patterns=p) # red = unpaired, green = left-pairing, blue = right # positions in black are not part of the consensus secondary structure  # search for additional secondary structure between the consensus pairs p <- PredictDBN(rna, \"search\") # scores per sequence after searching BrowseSeqs(rna, patterns=p) # red = unpaired, green = left-pairing, blue = right # note that \"search\" identified many more pairings than \"structures\" }"},{"path":"/reference/PredictHEC.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict Protein Secondary Structure as Helix, Beta-Sheet, or Coil — PredictHEC","title":"Predict Protein Secondary Structure as Helix, Beta-Sheet, or Coil — PredictHEC","text":"Predicts 3-state protein secondary structure based primary (amino acid) sequence using GOR IV method (Garnier et al., 1996).","code":""},{"path":"/reference/PredictHEC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict Protein Secondary Structure as Helix, Beta-Sheet, or Coil — PredictHEC","text":"","code":"PredictHEC(   myAAStringSet,   type = \"states\",   windowSize = 7,   background = c(H = -0.12, E = -0.25, C = 0.23),   HEC_MI1 = NULL,   HEC_MI2 = NULL )"},{"path":"/reference/PredictHEC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict Protein Secondary Structure as Helix, Beta-Sheet, or Coil — PredictHEC","text":"myAAStringSet AAStringSet object sequences. type Character string indicating type results desired.  (unambiguous abbreviation ) one \"states\", \"scores\", \"probabilities\". windowSize Numeric specifying number residues left right center position use prediction. background Numeric vector background ``scores'' three states (H, E, C). HEC_MI1 array dimensions 20 x 21 x 3 giving mutual information single residues. HEC_MI2 array dimensions 20 x 20 x 21 x 21 x 3 giving mutual information pairs residues.","code":""},{"path":"/reference/PredictHEC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict Protein Secondary Structure as Helix, Beta-Sheet, or Coil — PredictHEC","text":"type \"states\" (default), output character vector secondary structure assignment (\"H\", \"E\", \"C\") residue myAAStringSet. Otherwise, output list one element sequence myAAStringSet.  list element contains matrix dimension 3 (H, E, C) number residues sequence.  type \"scores\", values matrix represent log-odds ``scores''. type \"probabilities\" values represent normalized probabilities three states position.","code":""},{"path":"/reference/PredictHEC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict Protein Secondary Structure as Helix, Beta-Sheet, or Coil — PredictHEC","text":"GOR (Garnier-Osguthorpe-Robson) method information-theory method prediction secondary structure based primary sequence protein.  Version IV method makes 3-state predictions based mutual information contained single residues pairs residues within windowSize residues position assigned.  approach 65\\ secondary structure use single sequence.  implementation GOR IV use decision constants number contiguous states assigning final state.  Note characters standard 20 amino acids assigned state.","code":""},{"path":"/reference/PredictHEC.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Predict Protein Secondary Structure as Helix, Beta-Sheet, or Coil — PredictHEC","text":"Garnier, J., Gibrat, J. F., & Robson, B. (1996). GOR method predicting protein secondary structure amino acid sequence. Methods Enzymology, 266, 540-553.","code":""},{"path":[]},{"path":"/reference/PredictHEC.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Predict Protein Secondary Structure as Helix, Beta-Sheet, or Coil — PredictHEC","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/PredictHEC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict Protein Secondary Structure as Helix, Beta-Sheet, or Coil — PredictHEC","text":"","code":"fas <- system.file(\"extdata\", \"50S_ribosomal_protein_L2.fas\", package=\"DECIPHER\") dna <- readDNAStringSet(fas) aa <- translate(dna) hec <- PredictHEC(aa) head(hec) #> [1] \"CCCCCCCCCCCCHHHHHHHCCCCCCCCCCCCEEEECCCCCCCCCCCCEEEEEECCCCCCEEEEEHHHCCCCCCHHHHHHHECCCCCCHHHEEEEECCCCCCEEEECCCCCCCCCEEEHHHHHHHHHCCCCCCCCCCCCCEECHHEEECCCCCEEEEECCCCEEEECCCCCHEEEHHCCCCCEEEECCCCEEECCCCCCCCHHHEHCCCCCCEEECCCCCCEEEEECCCCCCCCCCCCEECCCCCCECCCCECCCCCEEECCCCCCHEEHHCCC\"  #> [2] \"CCCCECCCCCCCCCEEEEEEECEEECCCCCCHEEEEECCCCCCCCCCCEEEEEECCCCCCEEEEEEECCCCCCCCCEEEEEEECCCCCHHHEEHHHHCCCCEEEECCCCCCEEEEEECCCCCCHHHCCCCCCCCCCCCEEEEEEECCCCCCHEEEEHCCCHHEECCCCCCEEEEECCCCCCEEEEEECEEEEEECCCCCHHHHHHCCCCCEEEECCCCCCCEEEECCCCCCCCCCCCEECCCCCCCCHHHHHHCCCCCCCCCCCCHHHHHHHCC\" #> [3] \"CCCCECCCCCCCCCEEEEEEECEEECCCCCCHEEEEECCCCCCCCCCCEEEEEECCCCCCEEEEEEECCCCCCCCCEEEEEEECCCCCHHHEEHHHHCCCCEEEECCCCCCEEEEEECCCCCCHHHCCCCCCCCCCCCEEEEEEECCCCCCHEEEEHCCCHHEECCCCCCEEEEECCCCCCEEEEEECEEEEEECCCCCHHHHHHCCCCCEEEECCCCCCCEEEECCCCCCCCCCCCEECCCCCCCCHHHHHHCCCCCCCCCCCCHHHHHHHCC\" #> [4] \"CCCCECCCCCCCCCEEEEEEECEEECCCCCCHEEEEECCCCCCCCCCCEEEEEECCCCCCEEEEEEECCCCCCCCCEEEEEEECCCCCHHHEEHHHHCCCCEEEECCCCCCEEEEEECCCCCCHHHCCCCCCCCCCCCEEEEEEECCCCCCHEEEEHCCCHHEECCCCCCEEEEECCCCCCEEEEEECEEEEEECCCCCHHHHHHCCCCCEEEECCCCCCCEEEECCCCCCCCCCCCEECCCCCCCCHHHHHHCCCCCCCCCCCCHHHHHHHCC\" #> [5] \"CCEEEECCCCCCCEEEEEEECCCCCCCCCCCCEECCCCCCCCCCCCCEEEEEEECCCCCCEEEEHHHHCCCCCCHHHHHHHCCCCCCHHHHEEEEHCCCCHEEEECCCCCCCCCEEECCCCCCEECCCCCCCCCCCCCCEEEEEEECCCCCCEEEHHCCHHEEEEECCCCCEEEEHCCCHHHHHHHHHCEEECCCCCCHHHHHHHHHCCCCCECCCCCCEEECECCCCCCCCCCCCCCECCCCCCCCEEEECCCCCEECCCCCCEEEEECCCC\"  #> [6] \"CCEEEECCCCCCCEEEEEEECCCCCCCCCCCCEECCCCCCCCCCCCCEEEEEEECCCCCCEEEEHHHHCCCCCCHHHHHHHCCCCCCHHHHEEEEHCCCCHEEEECCCCCCCCCEEECCCCCCEECCCCCCCCCCCCCCEEEEEEECCCCCCEEEHHCCHHEEEEECCCCCEEEEHCCCHHHHHHHHHCEEECCCCCCHHHHHHHHHCCCCCECCCCCCEEECECCCCCCCCCCCCCCECCCCCCCCEEEECCCCCEECCCCCCEEEEECCCC\""},{"path":"/reference/RESTRICTION_ENZYMES.html","id":null,"dir":"Reference","previous_headings":"","what":"Common Restriction Enzyme's Cut Sites — RESTRICTION_ENZYMES","title":"Common Restriction Enzyme's Cut Sites — RESTRICTION_ENZYMES","text":"character vector common restriction sites named restriction enzyme cuts site.  Sequence specificity listed 5' 3' orientation based IUPAC_CODE_MAP.  cut site either signified ``/'' palindromic sites, two numbers giving position top bottom cut positions relative site's 3'-end.","code":""},{"path":"/reference/RESTRICTION_ENZYMES.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Common Restriction Enzyme's Cut Sites — RESTRICTION_ENZYMES","text":"format : Named chr 1:224 \"GACGT/C\" \"G/GTACC\" \"GT/MKAC\" ... attr(*, \"names\")= chr 1:224 \"AatII\" \"Acc65I\" \"AccI\" \"AciI\" ...","code":""},{"path":"/reference/RESTRICTION_ENZYMES.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Common Restriction Enzyme's Cut Sites — RESTRICTION_ENZYMES","text":"Restriction enzymes sold .","code":""},{"path":"/reference/RESTRICTION_ENZYMES.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Common Restriction Enzyme's Cut Sites — RESTRICTION_ENZYMES","text":"","code":"data(RESTRICTION_ENZYMES) RESTRICTION_ENZYMES #>              AatII             Acc65I               AccI               AciI  #>          \"GACGT/C\"          \"G/GTACC\"          \"GT/MKAC\"      \"CCGC(-3/-1)\"  #>               AclI               AcuI               AfeI              AflII  #>          \"AA/CGTT\"    \"CTGAAG(16/14)\"          \"AGC/GCT\"          \"C/TTAAG\"  #>             AflIII               AgeI               AhdI               AleI  #>          \"A/CRYGT\"          \"A/CCGGT\"     \"GACNNN/NNGTC\"      \"CACNN/NNGTG\"  #>               AluI               AlwI              AlwNI               ApaI  #>            \"AG/CT\"       \"GGATC(4/5)\"       \"CAGNNN/CTG\"          \"GGGCC/C\"  #>              ApaLI              ApeKI               ApoI               AscI  #>          \"G/TGCAC\"           \"G/CWGC\"          \"R/AATTY\"        \"GG/CGCGCC\"  #>               AseI              AsiSI               AvaI              AvaII  #>          \"AT/TAAT\"        \"GCGAT/CGC\"          \"C/YCGRG\"           \"G/GWCC\"  #>              AvrII              BaeGI              BamHI               BanI  #>          \"C/CTAGG\"          \"GKGCM/C\"          \"G/GATCC\"          \"G/GYRCC\"  #>              BanII               BbsI              BbvCI               BbvI  #>          \"GRGCY/C\"      \"GAAGAC(2/6)\"   \"CCTCAGC(-5/-2)\"      \"GCAGC(8/12)\"  #>               BccI              BceAI              BciVI               BclI  #>       \"CCATC(4/5)\"     \"ACGGC(12/14)\"      \"GTATCC(6/5)\"          \"T/GATCA\"  #>              BcoDI               BfaI              BfuAI              BfuCI  #>       \"GTCTC(1/5)\"            \"C/TAG\"      \"ACCTGC(4/8)\"            \"/GATC\"  #>               BglI              BglII               BlpI              BmgBI  #>     \"GCCNNNN/NGGC\"          \"A/GATCT\"         \"GC/TNAGC\"    \"CACGTC(-3/-3)\"  #>               BmrI               BmtI               BpmI             Bpu10I  #>      \"ACTGGG(5/4)\"          \"GCTAG/C\"    \"CTGGAG(16/14)\"   \"CCTNAGC(-5/-2)\"  #>              BpuEI              BsaAI              BsaBI              BsaHI  #>    \"CTTGAG(16/14)\"          \"YAC/GTR\"      \"GATNN/NNATC\"          \"GR/CGYC\"  #>               BsaI              BsaJI              BsaWI              BseRI  #>      \"GGTCTC(1/5)\"          \"C/CNNGG\"          \"W/CCGGW\"     \"GAGGAG(10/8)\"  #>              BseYI               BsgI              BsiEI            BsiHKAI  #>    \"CCCAGC(-5/-1)\"    \"GTGCAG(16/14)\"          \"CGRY/CG\"          \"GWGCW/C\"  #>              BsiWI               BslI              BsmBI              BsmFI  #>          \"C/GTACG\"     \"CCNNNNN/NNGG\"      \"CGTCTC(1/5)\"     \"GGGAC(10/14)\"  #>               BsmI           Bsp1286I             BspCNI              BspDI  #>     \"GAATGC(1/-1)\"          \"GDGCH/C\"       \"CTCAG(9/7)\"          \"AT/CGAT\"  #>              BspEI              BspHI              BspQI              BsrBI  #>          \"T/CCGGA\"          \"T/CATGA\"     \"GCTCTTC(1/4)\"    \"CCGCTC(-3/-3)\"  #>              BsrDI              BsrFI              BsrGI               BsrI  #>      \"GCAATG(2/0)\"          \"R/CCGGY\"          \"T/GTACA\"      \"ACTGG(1/-1)\"  #>             BssHII              BssKI              BssSI             BstAPI  #>          \"G/CGCGC\"           \"/CCNGG\"    \"CACGAG(-5/-1)\"     \"GCANNNN/NTGC\"  #>              BstBI             BstEII              BstNI              BstUI  #>          \"TT/CGAA\"         \"G/GTNACC\"           \"CC/WGG\"            \"CG/CG\"  #>              BstXI              BstYI            BstZ17I             Bsu36I  #>    \"CCANNNNN/NTGG\"          \"R/GATCY\"          \"GTA/TAC\"         \"CC/TNAGG\"  #>               BtgI              BtgZI              BtsCI               BtsI  #>          \"C/CRYGG\"    \"GCGATG(10/14)\"       \"GGATG(2/0)\"      \"GCAGTG(2/0)\"  #>           BtsIMutI              Cac8I             CviAII            CviKI-1  #>       \"CAGTG(2/0)\"          \"GCN/NGC\"            \"C/ATG\"            \"RG/CY\"  #>              CviQI               DdeI               DraI             DraIII  #>            \"G/TAC\"           \"C/TNAG\"          \"TTT/AAA\"       \"CACNNN/GTG\"  #>               DrdI               EaeI               EagI               EarI  #>    \"GACNNNN/NNGTC\"          \"Y/GGCCR\"          \"C/GGCCG\"      \"CTCTTC(1/4)\"  #>               EciI            Eco53kI              EcoNI           EcoO109I  #>     \"GGCGGA(11/9)\"          \"GAG/CTC\"     \"CCTNN/NNNAGG\"         \"RG/GNCCY\"  #>            EcoP15I              EcoRI              EcoRV               FatI  #>    \"CAGCAG(25/27)\"          \"G/AATTC\"          \"GAT/ATC\"            \"/CATG\"  #>               FauI             Fnu4HI               FokI               FseI  #>       \"CCCGC(4/6)\"           \"GC/NGC\"      \"GGATG(9/13)\"        \"GGCCGG/CC\"  #>               FspI              HaeII             HaeIII               HgaI  #>          \"TGC/GCA\"          \"RGCGC/Y\"            \"GG/CC\"      \"GACGC(5/10)\"  #>               HhaI             HincII            HindIII              HinfI  #>            \"GCG/C\"          \"GTY/RAC\"          \"A/AGCTT\"           \"G/ANTC\"  #>             HinP1I               HpaI               HphI           Hpy166II  #>            \"G/CGC\"          \"GTT/AAC\"       \"GGTGA(8/7)\"          \"GTN/NAC\"  #>            Hpy188I          Hpy188III             Hpy99I              HpyAV  #>           \"TCN/GA\"          \"TC/NNGA\"           \"CGWCG/\"       \"CCTTC(6/5)\"  #>          HpyCH4III           HpyCH4IV            HpyCH4V               KasI  #>           \"ACN/GT\"            \"A/CGT\"            \"TG/CA\"          \"G/GCGCC\"  #>               KpnI              MboII               MfeI              MluCI  #>          \"GGTAC/C\"       \"GAAGA(8/7)\"          \"C/AATTG\"            \"/AATT\"  #>               MluI               MlyI               MmeI               MnlI  #>          \"A/CGCGT\"       \"GAGTC(5/5)\"    \"TCCRAC(20/18)\"        \"CCTC(7/6)\"  #>               MscI               MseI               MslI             MspA1I  #>          \"TGG/CCA\"            \"T/TAA\"      \"CAYNN/NNRTG\"          \"CMG/CKG\"  #>               MwoI               NaeI               NarI               NciI  #>     \"GCNNNNN/NNGC\"          \"GCC/GGC\"          \"GG/CGCC\"           \"CC/SGG\"  #>               NcoI               NdeI             NgoMIV               NheI  #>          \"C/CATGG\"          \"CA/TATG\"          \"G/CCGGC\"          \"G/CTAGC\"  #>             NlaIII              NlaIV            NmeAIII               NotI  #>            \"CATG/\"          \"GGN/NCC\"    \"GCCGAG(21/19)\"        \"GC/GGCCGC\"  #>               NruI               NsiI               NspI          Nt.BstNBI  #>          \"TCG/CGA\"          \"ATGCA/T\"          \"RCATG/Y\"      \"GAGTC(4/-5)\"  #>               PacI             PaeR7I               PciI              PflFI  #>        \"TTAAT/TAA\"          \"C/TCGAG\"          \"A/CATGT\"       \"GACN/NNGTC\"  #>              PflMI              PluTI               PmeI               PmlI  #>     \"CCANNNN/NTGG\"          \"GGCGC/C\"        \"GTTT/AAAC\"          \"CAC/GTG\"  #>              PpuMI              PshAI               PsiI              PspGI  #>         \"RG/GWCCY\"      \"GACNN/NNGTC\"          \"TTA/TAA\"           \"/CCWGG\"  #>             PspOMI              PspXI               PstI               PvuI  #>          \"G/GGCCC\"        \"VC/TCGAGB\"          \"CTGCA/G\"          \"CGAT/CG\"  #>              PvuII               RsaI              RsrII               SacI  #>          \"CAG/CTG\"            \"GT/AC\"         \"CG/GWCCG\"          \"GAGCT/C\"  #>              SacII               SalI             Sau96I               SbfI  #>          \"CCGC/GG\"          \"G/TCGAC\"           \"G/GNCC\"        \"CCTGCA/GG\"  #>               ScaI              ScrFI              SexAI              SfaNI  #>          \"AGT/ACT\"           \"CC/NGG\"         \"A/CCWGGT\"       \"GCATC(5/9)\"  #>               SfcI               SfiI               SfoI              SgrAI  #>          \"C/TRYAG\"   \"GGCCNNNN/NGGCC\"          \"GGC/GCC\"        \"CR/CCGGYG\"  #>               SmaI               SmlI              SnaBI               SpeI  #>          \"CCC/GGG\"          \"C/TYRAG\"          \"TAC/GTA\"          \"A/CTAGT\"  #>               SphI               SspI               StuI               StyI  #>          \"GCATG/C\"          \"AAT/ATT\"          \"AGG/CCT\"          \"C/CWWGG\"  #>               SwaI              TaqaI               TfiI             Tsp45I  #>        \"ATTT/AAAT\"            \"T/CGA\"           \"G/AWTC\"           \"/GTSAC\"  #>              TspMI              TspRI               XbaI               XcmI  #>          \"C/CCGGG\"       \"NNCASTGNN/\"          \"T/CTAGA\" \"CCANNNNN/NNNNTGG\"  #>               XmnI               ZraI  #>      \"GAANN/NNTTC\"          \"GAC/GTC\""},{"path":"/reference/ReadDendrogram.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a Dendrogram from a Newick Formatted File — ReadDendrogram","title":"Read a Dendrogram from a Newick Formatted File — ReadDendrogram","text":"Reads dendrogram object file Newick (also known New Hampshire) parenthetic format.","code":""},{"path":"/reference/ReadDendrogram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a Dendrogram from a Newick Formatted File — ReadDendrogram","text":"","code":"ReadDendrogram(   file,   convertBlanks = TRUE,   internalLabels = TRUE,   keepRoot = TRUE )"},{"path":"/reference/ReadDendrogram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a Dendrogram from a Newick Formatted File — ReadDendrogram","text":"file connection object character string. convertBlanks Logical specifying whether convert underscores unquoted leaf labels spaces. internalLabels Logical indicating whether keep internal node labels ``edgetext'' preceding node dendrogram. keepRoot Logical specifying whether keep root node (one present) dendrogram leaf.","code":""},{"path":"/reference/ReadDendrogram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a Dendrogram from a Newick Formatted File — ReadDendrogram","text":"object class dendrogram.","code":""},{"path":"/reference/ReadDendrogram.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read a Dendrogram from a Newick Formatted File — ReadDendrogram","text":"ReadDendrogram create dendrogram object Newick formatted tree.  Note edge lengths must specified, labels optional.  Leaves numbered labels alphabetical order.","code":""},{"path":[]},{"path":"/reference/ReadDendrogram.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Read a Dendrogram from a Newick Formatted File — ReadDendrogram","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/ReadDendrogram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read a Dendrogram from a Newick Formatted File — ReadDendrogram","text":"","code":"tf <- tempfile() dists <- matrix(c(0, 10, 20, 10, 0, 5, 20, 5, 0),     nrow=3,     dimnames=list(c(\"dog\", \"elephant\", \"horse\"))) dend1 <- TreeLine(myDistMatrix=dists, method=\"NJ\", type=\"dendrogram\") #> ================================================================================ #>  #> Time difference of 0 secs #>  WriteDendrogram(dend1, file=tf)  dend2 <- ReadDendrogram(tf) layout(matrix(1:2)) plot(dend1, main=\"Dendrogram Written\") plot(dend2, main=\"Dendrogram Read\")   unlink(tf)"},{"path":"/reference/RemoveGaps.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove Gap Characters in Sequences — RemoveGaps","title":"Remove Gap Characters in Sequences — RemoveGaps","text":"Removes gaps (\"-\" \".\" characters) set sequences, either deleting gaps shared sequences set.","code":""},{"path":"/reference/RemoveGaps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove Gap Characters in Sequences — RemoveGaps","text":"","code":"RemoveGaps(   myXStringSet,   removeGaps = \"all\",   includeMask = FALSE,   processors = 1 )"},{"path":"/reference/RemoveGaps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove Gap Characters in Sequences — RemoveGaps","text":"myXStringSet AAStringSet, DNAStringSet, RNAStringSet object containing sequences. removeGaps Determines gaps (\"-\" \".\" characters) removed sequences.  (unambiguous abbreviation ) one \"none\", \"\" \"common\". includeMask Logical specifying whether consider mask character (\"+\") gap. processors number processors use, NULL automatically detect use available processors.","code":""},{"path":"/reference/RemoveGaps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove Gap Characters in Sequences — RemoveGaps","text":"XStringSet type myXStringSet.","code":""},{"path":"/reference/RemoveGaps.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Remove Gap Characters in Sequences — RemoveGaps","text":"removeGaps argument controls gaps removed myXStringSet.  Setting removeGaps \"\" remove gaps input sequences, whereas setting removeGaps \"common\" remove gaps exist position every sequence.  Therefore, latter method leave gaps place shared every sequence, requiring sequences myXStringSet length (.e., aligned).  Setting removeGaps \"none\" simply return myXStringSet unaltered.","code":""},{"path":[]},{"path":"/reference/RemoveGaps.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Remove Gap Characters in Sequences — RemoveGaps","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/RemoveGaps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove Gap Characters in Sequences — RemoveGaps","text":"","code":"dna <- DNAStringSet(c(\"ACT-G-\", \"AC--G-\")) dna #> DNAStringSet object of length 2: #>     width seq #> [1]     6 ACT-G- #> [2]     6 AC--G- RemoveGaps(dna, \"all\") #> DNAStringSet object of length 2: #>     width seq #> [1]     4 ACTG #> [2]     3 ACG RemoveGaps(dna, \"common\") #> DNAStringSet object of length 2: #>     width seq #> [1]     4 ACTG #> [2]     4 AC-G"},{"path":"/reference/ScoreAlignment.html","id":null,"dir":"Reference","previous_headings":"","what":"Score a Multiple Sequence Alignment — ScoreAlignment","title":"Score a Multiple Sequence Alignment — ScoreAlignment","text":"Calculates score multiple sequence alignment based either sum--pairs sum--adjacent-pairs scoring.","code":""},{"path":"/reference/ScoreAlignment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Score a Multiple Sequence Alignment — ScoreAlignment","text":"","code":"ScoreAlignment(   myXStringSet,   method = \"pairs\",   perfectMatch = 1,   misMatch = 0,   gapOpening = -7.5,   gapExtension = -0.6,   substitutionMatrix = NULL,   structures = NULL,   structureMatrix = NULL,   includeTerminalGaps = FALSE,   weight = 1 )"},{"path":"/reference/ScoreAlignment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Score a Multiple Sequence Alignment — ScoreAlignment","text":"myXStringSet AAStringSet, DNAStringSet, RNAStringSet object aligned sequences. method Character string indicating method scoring.  (abbreviation ) one \"pairs\" sum--pairs \"adjacent\" sum--adjacent-pairs.  (See details section .) perfectMatch Numeric giving reward aligning two matching nucleotides alignment.  used DNAStringSet RNAStringSet inputs. misMatch Numeric giving cost aligning two mismatched nucleotides alignment.  used DNAStringSet RNAStringSet inputs. gapOpening Numeric giving cost opening closing gap alignment. gapExtension Numeric giving cost extending open gap alignment. substitutionMatrix Either substitution matrix representing substitution scores alignment name amino acid substitution matrix use alignment.  latter may one following: BLOSUM45'', BLOSUM50'', BLOSUM62'', BLOSUM80'', BLOSUM100'', PAM30'', PAM40'', PAM70'', PAM120'', PAM250'', ``MIQS''.  default (NULL) use perfectMatch misMatch penalties DNA/RNA PFASUM50 AA. structures Either NULL (default) list matrices one list element per sequence myXStringSet. structureMatrix structure matrix structures supplied, NULL otherwise. includeTerminalGaps Logical specifying whether include terminal gaps (\"-\" \".\" characters end sequence) calculation score. weight numeric vector weights sequence, single number implying equal weights.","code":""},{"path":"/reference/ScoreAlignment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Score a Multiple Sequence Alignment — ScoreAlignment","text":"single numeric score.","code":""},{"path":"/reference/ScoreAlignment.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Score a Multiple Sequence Alignment — ScoreAlignment","text":"Sum--pairs scoring standard way judge whether set sequences homologous.  ScoreAlignment calculates sum--pairs score myXStringSet method \"pairs\".  score can also used compare among different alignments sequences. method \"adjacent\" sum--adjacent-pairs scores calculated, sequence compared next sequence.  Hence, input order sequences myXStringSet matters method \"adjacent\". scores linearly related number sequences alignment number sites alignment.  Therefore, possible normalize score dividing width length (minus 1) myXStringSet.","code":""},{"path":[]},{"path":"/reference/ScoreAlignment.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Score a Multiple Sequence Alignment — ScoreAlignment","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/ScoreAlignment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Score a Multiple Sequence Alignment — ScoreAlignment","text":"","code":"# small example x <- DNAStringSet(c(\"C-G\", \"CTG\", \"C-G\", \"CTG\")) ScoreAlignment(x, method=\"pairs\", gapOpening=-1) # +3 -1 +3 = 5 #> [1] 5 ScoreAlignment(x, method=\"adjacent\", gapOpening=-1) # +3 -3 +3 = 3 #> [1] 3  # DNA alignment with the defaults fas <- system.file(\"extdata\", \"Streptomyces_ITS_aligned.fas\", package=\"DECIPHER\") dna <- readDNAStringSet(fas) dna # input alignment #> DNAStringSet object of length 88: #>      width seq                                              names                #>  [1]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTTTCCGAATGGGGAAACC supercont3.1 of S... #>  [2]   627 NNNNCACACCGCCCGTCA-CGTC...GGGGTTTCCGAATGGGGAAACC supercont3.1 of S... #>  [3]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTTTCCGAATGGGGAAACC supercont1.1 of S... #>  [4]   627 CGTACACACCGCCCGTCA-CGTC...GGGGTTTCCGAATGGGGAAACC supercont1.1 of S... #>  [5]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTTTCCGAATGGGGAAACC supercont1.1 of S... #>  ...   ... ... #> [84]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTTTCCGAATGGGGAAACC gi|297189896|ref|... #> [85]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTGTCCGAATGGGGAAACC gi|224581106|ref|... #> [86]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTGTCCGAATGGGGAAACC gi|224581106|ref|... #> [87]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTGTCCGAATGGGGAAACC gi|224581106|ref|... #> [88]   627 TGTACACACCGCCCGTCA-CGTC...GGGGTTTCCGAATGGGGAAACC gi|224581108|ref|... ScoreAlignment(dna, method=\"pairs\") #> [1] 31679.96 ScoreAlignment(dna, method=\"adjacent\") #> [1] 41222.2  # provide a DNA substitution matrix for greater discerning power sub <- matrix(c(1.5, -2.134, -0.739, -1.298,     -2.134, 1.832, -2.462, 0.2,     -0.739, -2.462, 1.522, -2.062,     -1.298, 0.2, -2.062, 1.275),   nrow=4,   dimnames=list(DNA_BASES, DNA_BASES)) ScoreAlignment(dna, substitutionMatrix=sub) #> [1] 46318.15  # use structures with an amino acid alignment fas <- system.file(\"extdata\", \"50S_ribosomal_protein_L2.fas\", package=\"DECIPHER\") dna <- readDNAStringSet(fas) aa <- AlignTranslation(dna, type=\"AAStringSet\") #> Determining distance matrix based on shared 5-mers: #> ================================================================================ #>  #> Time difference of 0.73 secs #>  #> Clustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.02 secs #>  #> Aligning Sequences: #> ================================================================================ #>  #> Time difference of 0.84 secs #>  #> Iteration 1 of 2: #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.06 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.04 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 0.41 secs #>  #> Iteration 2 of 2: #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.06 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.04 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 0.04 secs #>  structureMatrix <- matrix(c(0.187, -0.8, -0.873,     -0.8, 0.561, -0.979,     -0.873, -0.979, 0.221),   nrow=3,   dimnames=list(c(\"H\", \"E\", \"C\"), c(\"H\", \"E\", \"C\"))) ScoreAlignment(aa,   structures=PredictHEC(aa, type=\"probabilities\"),   structureMatrix=structureMatrix) #> [1] 270542.2"},{"path":"/reference/SearchDB.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain Specific Sequences from a Database — SearchDB","title":"Obtain Specific Sequences from a Database — SearchDB","text":"Returns set sequences meeting search criteria.","code":""},{"path":"/reference/SearchDB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain Specific Sequences from a Database — SearchDB","text":"","code":"SearchDB(   dbFile,   tblName = \"Seqs\",   identifier = \"\",   type = \"XStringSet\",   limit = -1,   replaceChar = NA,   nameBy = \"row_names\",   orderBy = \"row_names\",   countOnly = FALSE,   removeGaps = \"none\",   quality = \"Phred\",   clause = \"\",   processors = 1,   verbose = TRUE )"},{"path":"/reference/SearchDB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain Specific Sequences from a Database — SearchDB","text":"dbFile SQLite connection object character string specifying path database file. tblName Character string specifying table sequences located. identifier Optional character string used narrow search results matching specific identifier.  \"\" (default) identifiers selected. type type XStringSet (sequences) return.  (unambiguous abbreviation ) one \"XStringSet\", \"DNAStringSet\", \"RNAStringSet\", \"AAStringSet\", \"BStringSet\", \"QualityScaledXStringSet\", \"QualityScaledDNAStringSet\", \"QualityScaledRNAStringSet\", \"QualityScaledAAStringSet\", \"QualityScaledBStringSet\".  type \"XStringSet\" \"QualityScaledXStringSet\" attempt made guess type sequences based composition. limit Number results display.  default (-1) limit number results. replaceChar Optional character used replace characters sequence present XStringSet's alphabet.  applicable type==\"BStringSet\".  default (NA) results error incompatible character exist.  (See details section .) nameBy Character string giving column name naming XStringSet. orderBy Character string giving column name sorting results.  Defaults order entries database.  Optionally can followed \" ASC\" \" DESC\" specify ascending (default) descending order. countOnly Logical specifying whether return number sequences. removeGaps Determines gaps (\"-\" \".\" characters) removed sequences.  (unambiguous abbreviation ) one \"none\", \"\" \"common\". quality type quality object return type QualityScaledXStringSet.  (unambiguous abbreviation ) one \"Phred\", \"Solexa\", \"Illumina\".  Note recent versions Illumina software provide \"Phred\" formatted quality scores. clause optional character string append query part ``clause''. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display queries sent database.","code":""},{"path":"/reference/SearchDB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain Specific Sequences from a Database — SearchDB","text":"XStringSet QualityScaledXStringSet sequences meet specified criteria.  names object correspond value nameBy column database.","code":""},{"path":"/reference/SearchDB.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Obtain Specific Sequences from a Database — SearchDB","text":"type \"DNAStringSet\" U's converted T's creating DNAStringSet, vise-versa type \"RNAStringSet\".  remaining characters XStringSet's alphabet converted replaceChar removed replaceChar \"\".  Note replaceChar NA (default), result error unexpected character found.  Quality information interpreted PredQuality scores.","code":""},{"path":"/reference/SearchDB.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Obtain Specific Sequences from a Database — SearchDB","text":"ES Wright (2016) \"Using DECIPHER v2.0 Analyze Big Biological Sequence Data R\". R Journal, 8(1), 352-359.","code":""},{"path":[]},{"path":"/reference/SearchDB.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Obtain Specific Sequences from a Database — SearchDB","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/SearchDB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain Specific Sequences from a Database — SearchDB","text":"","code":"db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") # get all sequences in the default table: dna <- SearchDB(db) #> Search Expression: #> select row_names, sequence from _Seqs where row_names in (select row_names #> from Seqs) #>  #> DNAStringSet of length: 175 #> Time difference of 0.02 secs #>  # select a random sequence: dna <- SearchDB(db, orderBy=\"random()\", limit=1) #> Search Expression: #> select Seqs.row_names, _Seqs.sequence from Seqs join _Seqs on Seqs.row_names = #> _Seqs.row_names where _Seqs.row_names in (select row_names from Seqs) order by #> random() limit 1 #>  #> DNAStringSet of length: 1 #> Time difference of 0 secs #>  # remove gaps from \"Mycobacterium\" sequences: dna <- SearchDB(db, identifier=\"Mycobacterium\", removeGaps=\"all\") #> Search Expression: #> select row_names, sequence from _Seqs where row_names in (select row_names #> from Seqs where identifier is \"Mycobacterium\") #>  #> DNAStringSet of length: 22 #> Time difference of 0 secs #>  # provide a more complex query: dna <- SearchDB(db, nameBy=\"description\", orderBy=\"bases\", removeGaps=\"common\",                 clause=\"nonbases is 0\") #> Search Expression: #> select description, _Seqs.sequence from Seqs join _Seqs on Seqs.row_names = #> _Seqs.row_names where _Seqs.row_names in (select row_names from Seqs where #> nonbases is 0) order by bases #>  #> DNAStringSet of length: 19 #> Time difference of 0 secs #>"},{"path":"/reference/Seqs2DB.html","id":null,"dir":"Reference","previous_headings":"","what":"Add Sequences from Text File to Database — Seqs2DB","title":"Add Sequences from Text File to Database — Seqs2DB","text":"Adds sequences database.","code":""},{"path":"/reference/Seqs2DB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add Sequences from Text File to Database — Seqs2DB","text":"","code":"Seqs2DB(   seqs,   type,   dbFile,   identifier,   tblName = \"Seqs\",   chunkSize = 1e+07,   replaceTbl = FALSE,   fields = c(accession = \"ACCESSION\", rank = \"ORGANISM\"),   processors = 1,   verbose = TRUE,   ... )"},{"path":"/reference/Seqs2DB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add Sequences from Text File to Database — Seqs2DB","text":"seqs connection object character string specifying file path file containing sequences, XStringSet object type XStringSet, QualityScaledXStringSet object type QualityScaledXStringSet. Files compressed gzip, bzip2, xz, lzma compression automatically detected decompressed import.  Full URL paths (e.g., \"http://\" \"ftp://\") uncompressed text files gzip compressed text files can also used. type type sequences (seqs) imported.  (unambiguous abbreviation ) one \"FASTA\", \"FASTQ\", \"GenBank\", \"XStringSet\", \"QualityScaledXStringSet\". dbFile SQLite connection object character string specifying path database file.  dbFile exist new database created location. identifier Character string specifying \"id\" give imported sequences database. tblName Character string specifying table add sequences. chunkSize Number characters read time. replaceTbl Logical indicating whether overwrite entire table database.  FALSE (default) sequences appended already existing tblName.  TRUE entire table dropped, removing existing sequences adding new sequences. fields Named character vector providing fields import \"GenBank\" formatted file text columns database (applicable \"type\"s).  default import \"ACCESSION\" field column named \"accession\" \"ORGANISM\" field column named \"rank\".  uppercase fields, \"LOCUS\" \"VERSION\", can specified similar manner.  Note \"DEFINITION\" field automatically imported column named \"description\" database. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display query sent database. ... arguments passed directly Codec compressing sequence information.","code":""},{"path":"/reference/Seqs2DB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add Sequences from Text File to Database — Seqs2DB","text":"total number sequences database table returned import.","code":""},{"path":"/reference/Seqs2DB.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add Sequences from Text File to Database — Seqs2DB","text":"Sequences imported database chunks lines specified chunkSize.  sequences can identified searching database identifier provided.  Sequences added database verbatim, sequence information lost sequences exported database.  sequence (record) names recorded column named ``description'' database.","code":""},{"path":"/reference/Seqs2DB.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Add Sequences from Text File to Database — Seqs2DB","text":"replaceTbl TRUE sequences already table overwritten, equivalent dropping entire table.","code":""},{"path":"/reference/Seqs2DB.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add Sequences from Text File to Database — Seqs2DB","text":"ES Wright (2016) \"Using DECIPHER v2.0 Analyze Big Biological Sequence Data R\". R Journal, 8(1), 352-359.","code":""},{"path":[]},{"path":"/reference/Seqs2DB.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add Sequences from Text File to Database — Seqs2DB","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/Seqs2DB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add Sequences from Text File to Database — Seqs2DB","text":"","code":"gen <- system.file(\"extdata\", \"Bacteria_175seqs.gen\", package=\"DECIPHER\") dbConn <- dbConnect(SQLite(), \":memory:\") Seqs2DB(gen, \"GenBank\", dbConn, \"Bacteria\") #>  Reading GenBank file chunk 1 #>  #> 175 total sequences in table Seqs. #> Time difference of 0.02 secs #>  BrowseDB(dbConn) dna <- SearchDB(dbConn, nameBy=\"description\") #> Search Expression: #> select description, _Seqs.sequence from Seqs join _Seqs on Seqs.row_names = #> _Seqs.row_names where _Seqs.row_names in (select row_names from Seqs) #>  #> DNAStringSet of length: 175 #> Time difference of 0 secs #>  dbDisconnect(dbConn)"},{"path":"/reference/StaggerAlignment.html","id":null,"dir":"Reference","previous_headings":"","what":"Produce a Staggered Alignment — StaggerAlignment","title":"Produce a Staggered Alignment — StaggerAlignment","text":"Staggers overlapping characters multiple sequence alignment better explained multiple insertions multiple deletions.","code":""},{"path":"/reference/StaggerAlignment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Produce a Staggered Alignment — StaggerAlignment","text":"","code":"StaggerAlignment(   myXStringSet,   tree = NULL,   threshold = 3,   fullLength = FALSE,   processors = 1,   verbose = TRUE )"},{"path":"/reference/StaggerAlignment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Produce a Staggered Alignment — StaggerAlignment","text":"myXStringSet AAStringSet, DNAStringSet, RNAStringSet object aligned sequences. tree bifurcating dendrogram representing evolutionary relationships sequences, created TreeLine.  root topmost node tree.  default (NULL) automatically infer tree myXStringSet. threshold Numeric giving ratio insertions deletions must met stagger region alignment.  Specifically, number insertions divided deletions must less threshold stagger. fullLength Logical specifying whether sequences full-length (TRUE), terminal gaps treated missing data (FALSE, default).  Either single logical, vector one logical per sequence, list right left components containing logicals right left sides alignment. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display progress.","code":""},{"path":"/reference/StaggerAlignment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Produce a Staggered Alignment — StaggerAlignment","text":"XStringSet aligned sequences.","code":""},{"path":"/reference/StaggerAlignment.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Produce a Staggered Alignment — StaggerAlignment","text":"Multiple sequence aligners typically maximize true homologies expense increased false homologies.  StaggerAlignment creates ``staggered alignment'' separates regions alignment likely homologous separate regions.  re-balances trade-true positives false positives decreasing number false homologies loss true homologies.  resulting alignment less aesthetically pleasing widened introduction many gaps.  However, evolutionary sense staggered alignment correct aligned position represents hypothesis evolutionary events: overlapping characters two sequences represent positions common ancestor sequence may evolved substitution. single parameter threshold controls degree staggering. value represents ratio insertions deletions must crossed order stagger region.  threshold 1 mean region better explained separate insertions deletions staggered.  higher value threshold makes likely stagger, vise-versa.  high value conservatively stagger regions gaps, resulting false homologies also fewer true homologies.  default value (3) intended remove false homologies eliminates true homologies.  may preferable tailor threshold depending purpose alignment, downstream procedures (tree building) may less sensitive false homologies.","code":""},{"path":"/reference/StaggerAlignment.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Produce a Staggered Alignment — StaggerAlignment","text":"Coming soon!","code":""},{"path":[]},{"path":"/reference/StaggerAlignment.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Produce a Staggered Alignment — StaggerAlignment","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/StaggerAlignment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Produce a Staggered Alignment — StaggerAlignment","text":"","code":"db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") dna <- SearchDB(db, remove=\"all\") #> Search Expression: #> select row_names, sequence from _Seqs where row_names in (select row_names #> from Seqs) #>  #> DNAStringSet of length: 175 #> Time difference of 0.01 secs #>  alignedDNA <- AlignSeqs(dna) #> Determining distance matrix based on shared 9-mers: #> ================================================================================ #>  #> Time difference of 1.52 secs #>  #> Clustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.03 secs #>  #> Aligning Sequences: #> ================================================================================ #>  #> Time difference of 1.41 secs #>  #> Iteration 1 of 2: #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.07 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.02 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 1.06 secs #>  #> Iteration 2 of 2: #>  #> Determining distance matrix based on alignment: #> ================================================================================ #>  #> Time difference of 0.07 secs #>  #> Reclustering into groups by similarity: #> ================================================================================ #>  #> Time difference of 0.01 secs #>  #> Realigning Sequences: #> ================================================================================ #>  #> Time difference of 0.38 secs #>  staggerDNA <- StaggerAlignment(alignedDNA) #> Calculating distance matrix: #> ================================================================================ #>  #> Time difference of 0.06 secs #>  #> Constructing neighbor-joining tree: #> ================================================================================ #>  #> Time difference of 0.01 secs #>  #> Staggering insertions and deletions: #> ================================================================================ #>  #> Time difference of 1.67 secs #>  BrowseSeqs(staggerDNA, highlight=1)"},{"path":"/reference/Synteny.html","id":null,"dir":"Reference","previous_headings":"","what":"Synteny blocks and hits — Synteny","title":"Synteny blocks and hits — Synteny","text":"Syntenic blocks DNA segments composed conserved hits occurring order two sequences.  two sequences typically chromosomes different species hypothesized contain homology.  Class \"Synteny\" provides objects functions storing viewing syntenic blocks hits shared sequences. Syntenic blocks DNA segments composed conserved hits occurring order two sequences.  two sequences typically chromosomes different species hypothesized contain homology.  Class \"Synteny\" provides objects functions storing viewing syntenic blocks hits shared sequences.","code":""},{"path":"/reference/Synteny.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Synteny blocks and hits — Synteny","text":"x object class Synteny. bounds Logical specifying whether plot sequence boundaries horizontal vertical lines. boxBlocks Logical indicating whether draw rectangle around hits belonging block synteny. colorBy Numeric giving index reference sequence, character string indicating color neighbor'', frequency'', ``none''.  (See details section .) colorRamp function return n colors given number n.  Examples rainbow, heat.colors, terrain.colors, cm.colors, (default) colorRampPalette. barColor Character string giving background color bar. barSides Logical indicating whether draw black lines along long-sides bar. horizontal Logical indicating whether plot sequences horizontally (TRUE) vertically (FALSE). labels Character vector providing names corresponding ``identifier'' labels diagonal. width Numeric giving fractional width bar zero one. scaleBar Logical controlling whether scale bar drawn colorBy frequency''.  scale bar displays mapping color level sequence conservation.  applicable \\code{colorBy} value frequency''. gap Distance subplots, margin lines. line.main main specified, line.main provides line argument mtext. cex.labels Magnification labels. font.labels Font labels diagonal. quote Logical indicating whether print output surrounded quotes. right Logical specifying whether right align strings. ... graphical parameters pairs plot, including: main, cex.main, font.main, oma. arguments print, including print.gap max.","code":""},{"path":"/reference/Synteny.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Synteny blocks and hits — Synteny","text":"Objects class Synteny stored square matrices list elements dimnames giving identifier'' corresponding sequences.  synteny matrix can separated three parts: along, , diagonal.  list element along diagonal contains integer vector width sequence(s) belonging identifier''.  List elements diagonal (column j > row ) contain matrix hits'' corresponding matches sequences \\emph{} \\emph{j}.  List elements diagonal contain \\code{matrix} blocks'' synteny sequences j . pairs method creates scatterplot matrix Synteny object.  Dot plots diagonal show hits identifier j, forward hits colored black, hits reverse strand identifier j colored red.  Plots diagonal show blocks synteny colored score, green (highest scoring) blue magenta (lowest scoring). plot method displays bar view sequences order input object (x).  coloring scheme bar determined colorBy argument, color palette set colorRamp.  colorBy index, sequences colored according regions shared homology specified reference sequence (default 1).  colorBy neighbor'' shared syntenic blocks connected neighboring sequences.  \\code{colorBy} frequency'' positions sequence colored based degree conservation sequences.  case, regions correspondence sequence(s) colored barColor. Objects class Synteny stored square matrices list elements dimnames giving identifier'' corresponding sequences.  synteny matrix can separated three parts: along, , diagonal.  list element along diagonal contains integer vector width sequence(s) belonging identifier''.  List elements diagonal (column j > row ) contain matrix hits'' corresponding matches sequences \\emph{} \\emph{j}.  List elements diagonal contain \\code{matrix} blocks'' synteny sequences j . pairs method creates scatterplot matrix Synteny object.  Dot plots diagonal show hits identifier j, forward hits colored black, hits reverse strand identifier j colored red.  Plots diagonal show blocks synteny colored score, green (highest scoring) blue magenta (lowest scoring). plot method displays bar view sequences order input object (x).  coloring scheme bar determined colorBy argument, color palette set colorRamp.  colorBy index, sequences colored according regions shared homology specified reference sequence (default 1).  colorBy neighbor'' shared syntenic blocks connected neighboring sequences.  \\code{colorBy} frequency'' positions sequence colored based degree conservation sequences.  case, regions correspondence sequence(s) colored barColor.","code":""},{"path":[]},{"path":"/reference/Synteny.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Synteny blocks and hits — Synteny","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/Synteny.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Synteny blocks and hits — Synteny","text":"","code":"# a small example: dbConn <- dbConnect(SQLite(), \":memory:\") s1 <- DNAStringSet(\"ACTAGACCCAGACCGATAAACGGACTGGACAAG\") s3 <- reverseComplement(s1) s2 <- c(s1, s3) Seqs2DB(c(c(s1, s2), s3),         \"XStringSet\",         dbConn,         c(\"s1\", \"s2\", \"s2\", \"s3\")) #> Adding 4 sequences to the database. #>  #> 4 total sequences in table Seqs. #> Time difference of 0.01 secs #>  syn <- FindSynteny(dbConn, minScore=1) #> ================================================================================ #>  #> Time difference of 0.12 secs #>  syn # Note:  > 100% hits because of sequence reuse across blocks #>          s1        s2        s3 #> s1    1 seq 200% hits 100% hits #> s2 2 blocks    2 seqs 200% hits #> s3  1 block  2 blocks     1 seq pairs(syn, boxBlocks=TRUE)  plot(syn)  dbDisconnect(dbConn)  # a larger example: db <- system.file(\"extdata\", \"Influenza.sqlite\", package=\"DECIPHER\") synteny <- FindSynteny(db, minScore=50) #> ================================================================================ #>  #> Time difference of 0.45 secs #>  class(synteny) # 'Synteny' #> [1] \"Synteny\" synteny #>          H9N2     H5N1     H2N2     H7N9     H1N1 #> H9N2   8 seqs 74% hits 78% hits 76% hits 73% hits #> H5N1 8 blocks   8 seqs 70% hits 74% hits 84% hits #> H2N2 8 blocks 8 blocks   8 seqs 73% hits 71% hits #> H7N9 8 blocks 8 blocks 8 blocks   8 seqs 74% hits #> H1N1 8 blocks 8 blocks 8 blocks 8 blocks   8 seqs  # accessing parts i <- 1 j <- 2 synteny[i, i][[1]] # width of sequences in i #>  Influenza A virus (A/Hong Kong/1073/99(H9N2)) segment 5, complete  #>                                                               1557  #>  Influenza A virus (A/Hong Kong/1073/99(H9N2)) segment 8, complete  #>                                                                890  #>  Influenza A virus (A/Hong Kong/1073/99(H9N2)) segment 7, complete  #>                                                               1025  #>   Influenza A virus ha gene for Hemagglutinin, genomic RNA, strain  #>                                                               1714  #>   Influenza A virus na gene for neuraminidase, genomic RNA, strain  #>                                                               1418  #> Influenza A virus pb2 gene for polymerase Pb2, genomic RNA, strain  #>                                                               2341  #> Influenza A virus pb1 gene for polymerase Pb1, genomic RNA, strain  #>                                                               2328  #>   Influenza A virus pa gene for polymerase PA, genomic RNA, strain  #>                                                               2225  synteny[j, j][[1]] # width of sequences in j #> Influenza A virus (A/goose/Guangdong/1/1996(H5N1)) polymerase PB2  #>                                                              2341  #> Influenza A virus (A/goose/Guangdong/1/1996(H5N1)) polymerase PB1  #>                                                              2341  #>  Influenza A virus (A/goose/Guangdong/1/1996(H5N1)) polymerase PA  #>                                                              2233  #>   Influenza A virus (A/goose/Guangdong/1/1996(H5N1)) nucleocapsid  #>                                                              1565  #>     Influenza A virus (A/goose/Guangdong/1/1996(H5N1)) segment 6,  #>                                                              1458  #>  Influenza A virus (A/goose/Guangdong/1/1996(H5N1)) hemagglutinin  #>                                                              1760  #>     Influenza A virus (A/goose/Guangdong/1/1996(H5N1)) segment 7,  #>                                                              1027  #>     Influenza A virus (A/goose/Guangdong/1/1996(H5N1)) segment 8,  #>                                                               865  head(synteny[i, j][[1]]) # hits between i & j #>      index1 index2 strand width start1 start2 frame1 frame2 #> [1,]      7      2      0    73      1      2      0      0 #> [2,]      7      2      0    32     75     76      0      0 #> [3,]      7      2      0    64    115    116      0      0 #> [4,]      7      2      0   237    186    187      3      1 #> [5,]      7      2      0   126    426    427      3      1 #> [6,]      7      2      0    10    558    559      0      0 synteny[j, i][[1]] # blocks between i & j #>      index1 index2 strand score start1 start2 end1 end2 first_hit last_hit #> [1,]      7      2      0  1970      1      2 2328 2329         1       31 #> [2,]      6      1      0  1867      3      3 2341 2341        32       52 #> [3,]      8      3      0  1763      1      5 2225 2229        53       77 #> [4,]      1      4      0  1385      1      7 1557 1563        78       93 #> [5,]      3      7      0   871     10      3 1016 1009        94      102 #> [6,]      2      8      0   296     13      1  877  865       103      119 #> [7,]      4      6      0   110    308    292 1689 1703       120      132 #> [8,]      5      5      0   105      1     21 1287 1313       133      147  # plotting pairs(synteny) # dot plots  pairs(synteny, boxBlocks=TRUE) # boxes around blocks   plot(synteny) # bar view colored by position in genome 1  plot(synteny, barColor=\"#268FD6\") # emphasize missing regions  plot(synteny, \"frequency\") # most regions are shared by all  plot(synteny, \"frequency\", colorRamp=rainbow) # change the colors  plot(synteny, \"neighbor\") # connect neighbors     # a small example: dbConn <- dbConnect(SQLite(), \":memory:\") s1 <- DNAStringSet(\"ACTAGACCCAGACCGATAAACGGACTGGACAAG\") s3 <- reverseComplement(s1) s2 <- c(s1, s3) Seqs2DB(c(c(s1, s2), s3),         \"XStringSet\",         dbConn,         c(\"s1\", \"s2\", \"s2\", \"s3\")) #> Adding 4 sequences to the database. #>  #> 4 total sequences in table Seqs. #> Time difference of 0.01 secs #>  syn <- FindSynteny(dbConn, minScore=1) #> ================================================================================ #>  #> Time difference of 0.12 secs #>  syn # Note:  > 100% hits because of sequence reuse across blocks #>          s1        s2        s3 #> s1    1 seq 200% hits 100% hits #> s2 2 blocks    2 seqs 200% hits #> s3  1 block  2 blocks     1 seq pairs(syn, boxBlocks=TRUE)  plot(syn)  dbDisconnect(dbConn)  # a larger example: db <- system.file(\"extdata\", \"Influenza.sqlite\", package=\"DECIPHER\") synteny <- FindSynteny(db, minScore=50) #> ================================================================================ #>  #> Time difference of 0.47 secs #>  class(synteny) # 'Synteny' #> [1] \"Synteny\" synteny #>          H9N2     H5N1     H2N2     H7N9     H1N1 #> H9N2   8 seqs 74% hits 78% hits 76% hits 73% hits #> H5N1 8 blocks   8 seqs 70% hits 74% hits 84% hits #> H2N2 8 blocks 8 blocks   8 seqs 73% hits 71% hits #> H7N9 8 blocks 8 blocks 8 blocks   8 seqs 74% hits #> H1N1 8 blocks 8 blocks 8 blocks 8 blocks   8 seqs  # accessing parts i <- 1 j <- 2 synteny[i, i][[1]] # width of sequences in i #>  Influenza A virus (A/Hong Kong/1073/99(H9N2)) segment 5, complete  #>                                                               1557  #>  Influenza A virus (A/Hong Kong/1073/99(H9N2)) segment 8, complete  #>                                                                890  #>  Influenza A virus (A/Hong Kong/1073/99(H9N2)) segment 7, complete  #>                                                               1025  #>   Influenza A virus ha gene for Hemagglutinin, genomic RNA, strain  #>                                                               1714  #>   Influenza A virus na gene for neuraminidase, genomic RNA, strain  #>                                                               1418  #> Influenza A virus pb2 gene for polymerase Pb2, genomic RNA, strain  #>                                                               2341  #> Influenza A virus pb1 gene for polymerase Pb1, genomic RNA, strain  #>                                                               2328  #>   Influenza A virus pa gene for polymerase PA, genomic RNA, strain  #>                                                               2225  synteny[j, j][[1]] # width of sequences in j #> Influenza A virus (A/goose/Guangdong/1/1996(H5N1)) polymerase PB2  #>                                                              2341  #> Influenza A virus (A/goose/Guangdong/1/1996(H5N1)) polymerase PB1  #>                                                              2341  #>  Influenza A virus (A/goose/Guangdong/1/1996(H5N1)) polymerase PA  #>                                                              2233  #>   Influenza A virus (A/goose/Guangdong/1/1996(H5N1)) nucleocapsid  #>                                                              1565  #>     Influenza A virus (A/goose/Guangdong/1/1996(H5N1)) segment 6,  #>                                                              1458  #>  Influenza A virus (A/goose/Guangdong/1/1996(H5N1)) hemagglutinin  #>                                                              1760  #>     Influenza A virus (A/goose/Guangdong/1/1996(H5N1)) segment 7,  #>                                                              1027  #>     Influenza A virus (A/goose/Guangdong/1/1996(H5N1)) segment 8,  #>                                                               865  head(synteny[i, j][[1]]) # hits between i & j #>      index1 index2 strand width start1 start2 frame1 frame2 #> [1,]      7      2      0    73      1      2      0      0 #> [2,]      7      2      0    32     75     76      0      0 #> [3,]      7      2      0    64    115    116      0      0 #> [4,]      7      2      0   237    186    187      3      1 #> [5,]      7      2      0   126    426    427      3      1 #> [6,]      7      2      0    10    558    559      0      0 synteny[j, i][[1]] # blocks between i & j #>      index1 index2 strand score start1 start2 end1 end2 first_hit last_hit #> [1,]      7      2      0  1970      1      2 2328 2329         1       31 #> [2,]      6      1      0  1867      3      3 2341 2341        32       52 #> [3,]      8      3      0  1763      1      5 2225 2229        53       77 #> [4,]      1      4      0  1385      1      7 1557 1563        78       93 #> [5,]      3      7      0   871     10      3 1016 1009        94      102 #> [6,]      2      8      0   296     13      1  877  865       103      119 #> [7,]      4      6      0   110    308    292 1689 1703       120      132 #> [8,]      5      5      0   105      1     21 1287 1313       133      147  # plotting pairs(synteny) # dot plots  pairs(synteny, boxBlocks=TRUE) # boxes around blocks   plot(synteny) # bar view colored by position in genome 1  plot(synteny, barColor=\"#268FD6\") # emphasize missing regions  plot(synteny, \"frequency\") # most regions are shared by all  plot(synteny, \"frequency\", colorRamp=rainbow) # change the colors  plot(synteny, \"neighbor\") # connect neighbors"},{"path":"/reference/Taxa.html","id":null,"dir":"Reference","previous_headings":"","what":"Taxa training and testing objects — Taxa","title":"Taxa training and testing objects — Taxa","text":"Taxonomic classification process assigning organism label part taxonomic hierarchy (e.g., Phylum, Class, Order, Family, Genus).  , labels assigned based organism's DNA RNA sequence rank level determined classification's confidence. Class Taxa provides objects functions storing viewing training testing objects used taxonomic classification. Taxonomic classification process assigning organism label part taxonomic hierarchy (e.g., Phylum, Class, Order, Family, Genus).  , labels assigned based organism's DNA RNA sequence rank level determined classification's confidence. Class Taxa provides objects functions storing viewing training testing objects used taxonomic classification.","code":""},{"path":"/reference/Taxa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Taxa training and testing objects — Taxa","text":"x object class Taxa subclass Train Test. y (optional) object class Taxa opposite subclass x. showRanks Logical specifying whether show rank levels plotting object class Taxa subclass Test.  TRUE (default), ranks shown (colored) concentric rings radial lines delimiting taxa boundaries. n Numeric vector giving frequency classification x y object subclass Test, default (NULL) treat classifications occurring .  Typically, specifying n useful classifications represent varying numbers observations, e.g., unique sequences originally classified. ... optional parameters. Numeric character vector indices extract objects class Taxa subclass Test. j Numeric character vector rank levels extract objects class Taxa subclass Test. threshold Numeric specifying confidence threshold truncate output taxonomic classifications. Note threshold must higher original classifications change.","code":""},{"path":"/reference/Taxa.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Taxa training and testing objects — Taxa","text":"Objects class Taxa stored lists, can either subclass Train Test.  function LearnTaxa returns object subclass Train, function IdTaxa can return object class Test. Training objects built set reference sequences known taxonomic classifications.  List elements contain information required IdTaxa assigning classification test sequences. Testing objects can generated IdTaxa Training object set test sequences.  list element contains taxon, confidence, (optionally) rank name taxonomic assignment. information stored Taxa can visualized plot function displayed print.  objects subclass Train can subsetted without losing class. Objects class Taxa stored lists, can either subclass Train Test.  function LearnTaxa returns object subclass Train, function IdTaxa can return object class Test. Training objects built set reference sequences known taxonomic classifications.  List elements contain information required IdTaxa assigning classification test sequences. Testing objects can generated IdTaxa Training object set test sequences.  list element contains taxon, confidence, (optionally) rank name taxonomic assignment. information stored Taxa can visualized plot function displayed print.  objects subclass Train can subsetted without losing class.","code":""},{"path":[]},{"path":"/reference/Taxa.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Taxa training and testing objects — Taxa","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/Taxa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Taxa training and testing objects — Taxa","text":"","code":"data(\"TrainingSet_16S\") plot(TrainingSet_16S) #> Warning: argument 1 does not name a graphical parameter   # import test sequences fas <- system.file(\"extdata\", \"Bacteria_175seqs.fas\", package=\"DECIPHER\") dna <- readDNAStringSet(fas)  # remove any gaps in the sequences dna <- RemoveGaps(dna)  # classify the test sequences ids <- IdTaxa(dna, TrainingSet_16S, strand=\"top\") #> ================================================================================ #>  #> Time difference of 5.14 secs #>  ids #>   A test set of class 'Taxa' with length 175 #>       confidence name                 taxon #>   [1]        64% uncultured bacter... Root; Bacteria; Firmicutes; Bacilli; Ba... #>   [2]        69% uncultured bacter... Root; Bacteria; Firmicutes; Bacilli; Ba... #>   [3]        64% uncultured bacter... Root; Bacteria; Firmicutes; Bacilli; Ba... #>   [4]        91% uncultured bacter... Root; Bacteria; Firmicutes; Bacilli; La... #>   [5]        65% uncultured bacter... Root; Bacteria; Firmicutes; Clostridia;... #>   ...        ... ...                  ... #> [171]        38% uncultured bacter... Root; unclassified_Root                    #> [172]        50% uncultured bacter... Root; unclassified_Root                    #> [173]        30% uncultured bacter... Root; unclassified_Root                    #> [174]        49% uncultured bacter... Root; unclassified_Root                    #> [175]        53% uncultured bacter... Root; unclassified_Root                     plot(ids) # plot all rank levels plot(ids[, 1:4]) # plot the first rank levels plot(ids[j=c(\"rootrank\", \"class\", \"genus\")]) # plot specific rank levels plot(ids[threshold=70]) # plot high confidence classifications     data(\"TrainingSet_16S\") plot(TrainingSet_16S) #> Warning: argument 1 does not name a graphical parameter   # import test sequences fas <- system.file(\"extdata\", \"Bacteria_175seqs.fas\", package=\"DECIPHER\") dna <- readDNAStringSet(fas)  # remove any gaps in the sequences dna <- RemoveGaps(dna)  # classify the test sequences ids <- IdTaxa(dna, TrainingSet_16S, strand=\"top\") #> ================================================================================ #>  #> Time difference of 4.97 secs #>  ids #>   A test set of class 'Taxa' with length 175 #>       confidence name                 taxon #>   [1]        77% uncultured bacter... Root; Bacteria; Firmicutes; Bacilli; Ba... #>   [2]        65% uncultured bacter... Root; Bacteria; Firmicutes; Bacilli; Ba... #>   [3]        61% uncultured bacter... Root; Bacteria; Firmicutes; Bacilli; Ba... #>   [4]        92% uncultured bacter... Root; Bacteria; Firmicutes; Bacilli; La... #>   [5]        65% uncultured bacter... Root; Bacteria; Firmicutes; Clostridia;... #>   ...        ... ...                  ... #> [171]        38% uncultured bacter... Root; unclassified_Root                    #> [172]        47% uncultured bacter... Root; unclassified_Root                    #> [173]        32% uncultured bacter... Root; unclassified_Root                    #> [174]        48% uncultured bacter... Root; unclassified_Root                    #> [175]        54% uncultured bacter... Root; unclassified_Root                     plot(ids) # plot all rank levels plot(ids[, 1:4]) # plot the first rank levels plot(ids[j=c(\"rootrank\", \"class\", \"genus\")]) # plot specific rank levels plot(ids[threshold=70]) # plot high confidence classifications"},{"path":"/reference/TerminalChar.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine the Number of Terminal Characters — TerminalChar","title":"Determine the Number of Terminal Characters — TerminalChar","text":"Counts number terminal characters every sequence XStringSet.  Terminal characters defined specific character repeated beginning end sequence.","code":""},{"path":"/reference/TerminalChar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine the Number of Terminal Characters — TerminalChar","text":"","code":"TerminalChar(myXStringSet, char = \"\")"},{"path":"/reference/TerminalChar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine the Number of Terminal Characters — TerminalChar","text":"myXStringSet XStringSet object sequences. char single character giving terminal character count, empty character (\"\") indicating count gap (\"-\") unknown (\".\") characters.","code":""},{"path":"/reference/TerminalChar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine the Number of Terminal Characters — TerminalChar","text":"matrix containing results sequence respective row.  first column contains number leading char, second contains number trailing char, third contains total number characters -.","code":""},{"path":[]},{"path":"/reference/TerminalChar.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Determine the Number of Terminal Characters — TerminalChar","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/TerminalChar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine the Number of Terminal Characters — TerminalChar","text":"","code":"db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") dna <- SearchDB(db) #> Search Expression: #> select row_names, sequence from _Seqs where row_names in (select row_names #> from Seqs) #>  #> DNAStringSet of length: 175 #> Time difference of 0.01 secs #>  t <- TerminalChar(dna)"},{"path":"/reference/TileSeqs.html","id":null,"dir":"Reference","previous_headings":"","what":"Form a Set of Tiles for Each Group of Sequences. — TileSeqs","title":"Form a Set of Tiles for Each Group of Sequences. — TileSeqs","text":"Creates set tiles represent group sequences database downstream applications.","code":""},{"path":"/reference/TileSeqs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Form a Set of Tiles for Each Group of Sequences. — TileSeqs","text":"","code":"TileSeqs(   dbFile,   tblName = \"Seqs\",   identifier = \"\",   minLength = 26,   maxLength = 27,   maxTilePermutations = 10,   minCoverage = 0.9,   add2tbl = FALSE,   processors = 1,   verbose = TRUE,   ... )"},{"path":"/reference/TileSeqs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Form a Set of Tiles for Each Group of Sequences. — TileSeqs","text":"dbFile SQLite connection object character string specifying path database file. tblName Character string specifying table sequences use forming tiles. identifier Optional character string used narrow search results matching specific identifier.  \"\" identifiers selected. minLength Integer providing minimum number nucleotides tile.  Typically slightly less maxLength. maxLength Integer providing maximum number nucleotides tile.  Tiles designed primarily length, ideally slightly greater maximum length oligos used downstream functions. maxTilePermutations Integer specifying maximum number tiles target site. minCoverage Numeric providing fraction coverage desired target site group.  example, minCoverage 0.9 request additional tiles added 90\\ group represented tile permutations. add2tbl Logical character string specifying table name add result. processors number processors use, NULL automatically detect use available processors. verbose Logical indicating whether display progress. ... Additional arguments passed directly SearchDB.","code":""},{"path":"/reference/TileSeqs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Form a Set of Tiles for Each Group of Sequences. — TileSeqs","text":"data.frame row tile, multiple columns information.  row_names column gives row number.  start, end, start_aligned, end_aligned columns provide positioning tile consensus sequence formed group.  column misprime logical specifying whether tile meets specified constraints.  columns width id indicate tile's length group origin, respectively. coverage field gives fraction sequences containing tile group encompass tile's start end positions alignment, whereas groupCoverage contains fraction sequences group containing tile respective target site. example, single sequence 10 information (gap) first alignment position, coverage 100\\ groupCoverage 10\\ final column, target_site, provides sequence tile.","code":""},{"path":"/reference/TileSeqs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Form a Set of Tiles for Each Group of Sequences. — TileSeqs","text":"TileSeqs create set overlapping tiles representing target site alignment sequences.  common tile permutations added desired minimum group coverage obtained.  dbFile assumed contain DNAStringSet sequences (U's converted T's). Target sites one tiles meeting set requirements marked misprime equals TRUE.  Requirements include minimum group coverage, minimum length, maximum length.  Additionally, tiles required contain four runs single base four di-nucleotide repeats.","code":""},{"path":"/reference/TileSeqs.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Form a Set of Tiles for Each Group of Sequences. — TileSeqs","text":"add2tbl TRUE tiles added database table currently contains sequences used tiling.  added tiles may cause interference querying table sequences. Therefore, recommended add tiles table, example, using add2tbl=\"Tiles\".","code":""},{"path":[]},{"path":"/reference/TileSeqs.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Form a Set of Tiles for Each Group of Sequences. — TileSeqs","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/TileSeqs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Form a Set of Tiles for Each Group of Sequences. — TileSeqs","text":"","code":"db <- system.file(\"extdata\", \"Bacteria_175seqs.sqlite\", package=\"DECIPHER\") tiles <- TileSeqs(db, identifier=\"Pseudomonadales\") #> ================================================================================ #>  #> Time difference of 1.11 secs #>"},{"path":"/reference/TrainingSet_16S.html","id":null,"dir":"Reference","previous_headings":"","what":"Training Set for Classification of 16S rRNA Gene Sequences — TrainingSet_16S","title":"Training Set for Classification of 16S rRNA Gene Sequences — TrainingSet_16S","text":"pre-trained classifier 16S rRNA gene sequences generated LearnTaxa.","code":""},{"path":"/reference/TrainingSet_16S.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Training Set for Classification of 16S rRNA Gene Sequences — TrainingSet_16S","text":"training set class 'Taxa' * K-mer size: 8 * Number rank levels: 10 * Total number sequences: 2472 * Number taxonomic groups: 2472 * Number problem groups: 5 * Number problem sequences: 8","code":""},{"path":"/reference/TrainingSet_16S.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Training Set for Classification of 16S rRNA Gene Sequences — TrainingSet_16S","text":"Derived version 16 RDP Training Set (http://rdp.cme.msu.edu) based Bergey's Manual.","code":""},{"path":"/reference/TrainingSet_16S.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Training Set for Classification of 16S rRNA Gene Sequences — TrainingSet_16S","text":"original training sequences pruned maximum one sequence per group, described 'Classifying Sequences' vignette.","code":""},{"path":"/reference/TrainingSet_16S.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Training Set for Classification of 16S rRNA Gene Sequences — TrainingSet_16S","text":"16S rRNA training set provided illustrative purposes . highly recommended use comprehensive training set classifying real sequences.  Examples comprehensive training sets can found http://DECIPHER.codes/Download.html.","code":""},{"path":"/reference/TrainingSet_16S.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Training Set for Classification of 16S rRNA Gene Sequences — TrainingSet_16S","text":"Whitman, W.B., Goodfellow, M., Kampfer, P., Busse, H.-J., Trujillo, M.E., Ludwig, W. & Suzuki, K.-. (eds., 2012). Bergey's Manual Systematic Bacteriology, 2nd ed., Springer-Verlag, New York, NY.","code":""},{"path":"/reference/TrainingSet_16S.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Training Set for Classification of 16S rRNA Gene Sequences — TrainingSet_16S","text":"","code":"data(TrainingSet_16S) TrainingSet_16S #>   A training set of class 'Taxa' #>    * K-mer size: 8 #>    * Number of rank levels: 10 #>    * Total number of sequences: 2472 #>    * Number of groups: 2472 #>    * Number of problem groups: 5 #>    * Number of problem sequences: 8 plot(TrainingSet_16S) #> Warning: argument 1 does not name a graphical parameter"},{"path":"/reference/TreeLine.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a Phylogenetic Tree — TreeLine","title":"Construct a Phylogenetic Tree — TreeLine","text":"Builds phylogenetic tree set sequences distance matrix.","code":""},{"path":"/reference/TreeLine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Phylogenetic Tree — TreeLine","text":"","code":"TreeLine(   myXStringSet = NULL,   myDistMatrix = NULL,   method = \"ML\",   type = \"dendrogram\",   model = MODELS,   cutoff = -Inf,   showPlot = FALSE,   collapse = -1,   reconstruct = FALSE,   root = 0,   informationCriterion = \"AICc\",   maxGenerations = 20,   maxTime = Inf,   quadrature = FALSE,   costMatrix = NULL,   processors = 1,   verbose = TRUE )"},{"path":"/reference/TreeLine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a Phylogenetic Tree — TreeLine","text":"myXStringSet AAStringSet, DNAStringSet, RNAStringSet method \"ML\", method \"MP\", reconstruct FALSE. myDistMatrix symmetric \\(N\\) x \\(N\\) distance matrix values dissimilarity \\(N\\) sequences object class 'dist'.  method \"ML\" \"MP\" myDistMatrix optional.  Missing values (.e., NA) myDistMatrix imputed using ultrametric method described Makarenkov Lapointe (2004). method phylogenetic method used.  (abbreviation ) one \"ML\" (default), \"MP\", \"NJ\", \"complete\", \"single\", \"UPGMA\", \"WPGMA\".  (See details section .) type Character string indicating type output desired.  (abbreviation ) one \"dendrogram\" (default), \"clusters\", \"\".  (See value section .) model One available MODELS evolution provided character vector list components Protein' /Nucleotide'.  applicable method \"ML\" reconstruct FALSE.  Automatic model selection performed one model provided. cutoff vector maximum edge length separating sequences cluster.  negative value (default) prevent clustering.  Multiple cutoffs may provided ascending descending order.  (See details section .) showPlot Logical specifying whether plot resulting dendrogram. collapse Numeric controlling internal edges tree removed collapsing nodes.  collapse zero nodes height collapsed single node, resulting multifurcating tree.  collapse greater zero, nodes within collapse difference height made single node. value collapse less zero (default) ensure dendrogram purely bifurcating.  Note collapse effect cluster numbers cutoff. reconstruct Logical numeric determining whether perform ancestral state reconstruction myXStringSet specified. TRUE, maximum likelihood character states determined internal nodes dendrogram provided \"state\" attribute, unless method \"MP\", case parsimonious state given node.  numeric value zero one (exclusive) can provided method MP, case fraction (marginal) likelihood state must greater likelihood alternative states, otherwise ambiguous degeneracy code used.  applicable type \"dendrogram\" (default) \"\". root Integer specifying index outgroup 0 (default) midpoint root dendrogram. informationCriterion Character string specifying information criterion use automatic model selection.  Must (abbreviation ) either \"AICc\" \"BIC\".  best model automatically chosen based informationCriterion calculated likelihood sample size (defined number variable sites myXStringSet).  applicable method \"ML\". maxGenerations Integer indicating maximum number generations optimization perform.  generations potentially better search tree space expense added runtime.  applicable method \"ML\" \"MP\". maxTime Numeric giving maximum number hours algorithm allowed run returning result.  maxTime reached, algorithm proceed next available opportunity.  Therefore, maxTime soft maximum guarantee results returned exactly allotted time.  applicable method \"ML\" \"MP\". quadrature Logical determining whether use Laguerre quadrature equal-sized bins discretizing rate distribution across sites. default use equal-sized bins direct comparison among likelihoods computed programs, although Laguerre quadrature theoretically offers improvement accuracy number rates (Felsenstein, 2001). costMatrix Either NULL (default) symmetric matrix setting penalties used Sankoff parsimony.  default (NULL) apply cost 1 state changes 0 otherwise (.e., equivalent Fitch parsimony).  matrix states taken row column names.  applicable method \"MP\". processors number processors use, NULL automatically detect use available processors.  Note, number processors steps automatically selected one processors optimize performance. verbose Logical indicating whether display progress.","code":""},{"path":"/reference/TreeLine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a Phylogenetic Tree — TreeLine","text":"type \"dendrogram\" (default), tree class dendrogram returned attributes including pertinent information. type \"clusters\", data.frame returned column cutoff specified.  data.frame dimensions \\(N*M\\), one \\(N\\) sequences assigned cluster \\(M\\)-level cutoff. type \"\" list returned containing \"clusters\" \"dendrogram\" outputs.","code":""},{"path":"/reference/TreeLine.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct a Phylogenetic Tree — TreeLine","text":"TreeLine builds phylogenetic tree using either myDistMatrix /myXStringSet.  output either dendrogram /data.frame containing cluster numbers. Typical use cases include: (1) Provide XStringSet obtain maximum likelihood maximum parsimony tree, optionally ancestral states. (2) Provide matrix dist object (e.g., DistanceMatrix) obtain neighbor-joining ultrametric tree, optionally clusters similarity defined distance cutoffs. Multiple methods tree building supported: (1) Maximum likelihood: ML iteratively maximizes likelihood tree model parameters given aligned sequences (myXStringSet).  One MODELS sequence evolution must specified, best model automatically selected. (2) Maximum parsimony: MP iterative maximizes parsimony tree given aligned sequences (myXStringSet) costMatrix.  default cost matrix binary, corresponding Fitch (1971) parsimony. (3) Neighbor-joining: NJ uses Neighbor-Joining method proposed Saitou Nei, creates reasonable minimum evolution tree distance matrix (myDistMatrix). (4) Ultrametric: method complete assigns clusters using complete-linkage sequences cluster cutoff distance apart.  method single assigns clusters using single-linkage sequences cluster within cutoff least one sequence cluster.  UPGMA WPGMA assign clusters using average-linkage compromise sensitivity complete-linkage clustering outliers tendency single-linkage clustering connect distant relatives appear closely related.  UPGMA produces unweighted tree, leaf contributes equally average edge lengths, whereas WPGMA produces weighted result. returned dendrogram information stored attributes, can accessed attributes attr functions.  method \"ML\" \"MP\", edges tree branch support values included attributes.  \"support\" values represent fraction computed trees partition separating sequences either side, proxy confidence.  maximum likelihood trees, edges also \"probability\" representing aBayes support probability (Anisimova, 2011).  reconstruct FALSE, edge tree \"state\" attribute representing (marginal) likelihood node parsimonious state method \"MP\".  Maximum likelihood trees also provide likelihoods site reconstruct FALSE. non-negative cutoff(s) supplied, TreeLine assign clusters based edge lengths tree.  Multiple cutoffs may provided sorted order.  cutoffs provided descending order clustering new value cutoff continued within prior cutoff's clusters.  way clusters lower values cutoff completely contained within umbrella clusters higher values cutoff.  useful defining taxonomy, groups need hierarchically nested.  multiple cutoffs provided ascending order clustering level cutoff independent prior level.","code":""},{"path":"/reference/TreeLine.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Construct a Phylogenetic Tree — TreeLine","text":"Note cophenetic distance leaves dendrogram equal sum branch lengths separating leaves.  typical phylogenetic interpretation different trees produced hclust leaves merged height equal cophenetic distance.  Hence, always use Cophenetic (rather cophenetic) compute correct cophenetic distances.","code":""},{"path":"/reference/TreeLine.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Construct a Phylogenetic Tree — TreeLine","text":"Anisimova M., Gil, M., Dufayard, J., Dessimoz, C., Gascuel, O. (2011) Survey branch support methods demonstrates accuracy, power, robustness fast likelihood-based approximation schemes. Syst Biol., 60(5), 685-99. Felsenstein, J. (1981) Evolutionary trees DNA sequences: maximum likelihood approach. Journal Molecular Evolution, 17(6), 368-376. Felsenstein J. (2001) Taking variation evolutionary rates sites account inferring phylogenies. Journal molecular evolution, 53, 447-455. Fitch, W. M. (1971) Toward defining course evolution: minimum change specified tree topology. Systematic Zoology, 20:406-416. Makarenkov V., Lapointe, F. (2004) weighted least-squares approach inferring phylogenies incomplete distance matrices. Bioinformatics, 20(13), 2113-2121. Saitou, N. Nei, M. (1987) neighbor-joining method: new method reconstructing phylogenetic trees. Molecular Biology Evolution, 4(4), 406-425. Sankoff, D. (1975) Minimal mutation trees sequences. SIAM Journal Applied Math, 28.","code":""},{"path":[]},{"path":"/reference/TreeLine.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Construct a Phylogenetic Tree — TreeLine","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/TreeLine.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a Phylogenetic Tree — TreeLine","text":"","code":"# using the matrix from the original paper by Saitou and Nei m <- matrix(0,8,8) # only the lower triangle is used m[2:8,1] <- c(7, 8, 11, 13, 16, 13, 17) m[3:8,2] <- c(5, 8, 10, 13, 10, 14) m[4:8,3] <- c(5, 7, 10, 7, 11) m[5:8,4] <- c(8, 11, 8, 12) m[6:8,5] <- c(5, 6, 10) m[7:8,6] <- c(9, 13) m[8,7] <- c(8)  # returns an object of class \"dendrogram\" tree <- TreeLine(myDistMatrix=m, cutoff=10, method=\"NJ\", showPlot=TRUE) #> ================================================================================  #>  #> Time difference of 0.01 secs #>   # example of specifying multiple cutoffs clusters <- TreeLine(myDistMatrix=m, method=\"UPGMA\", type=\"clusters\", cutoff=c(2,6,10,20)) #> ================================================================================ #>  #> Time difference of 0 secs #>  head(clusters) #>   cluster_2 cluster_6 cluster_10 cluster_20 #> 1         7         5          2          1 #> 2         5         3          2          1 #> 3         4         2          2          1 #> 4         3         2          2          1 #> 5         2         1          1          1 #> 6         1         1          1          1  # example of creating a complete-linkage tree from an alignment fas <- system.file(\"extdata\", \"50S_ribosomal_protein_L2.fas\", package=\"DECIPHER\") dna <- readDNAStringSet(fas) dna <- AlignTranslation(dna, verbose=FALSE) dna # input alignment #> DNAStringSet object of length 317: #>       width seq                                             names                #>   [1]  1011 ----------------------...---------------------- Rickettsia prowaz... #>   [2]  1011 ----------------------...---------------------- Porphyromonas gin... #>   [3]  1011 ----------------------...---------------------- Porphyromonas gin... #>   [4]  1011 ----------------------...---------------------- Porphyromonas gin... #>   [5]  1011 ----------------------...---------------------- Pasteurella multo... #>   ...   ... ... #> [313]  1011 ----------------------...---------------------- Pectobacterium at... #> [314]  1011 ----------------------...---------------------- Acinetobacter sp.... #> [315]  1011 ----------------------...GGGTCGCGGTGGTCGTCAGTCT Thermosynechococc... #> [316]  1011 ----------------------...---------------------- Bradyrhizobium ja... #> [317]  1011 ----------------------...AGGT------------------ Gloeobacter viola... d <- DistanceMatrix(dna, type=\"dist\") # returns an object of class 'dist' #> ================================================================================ #>  #> Time difference of 0.16 secs #>  complete <- TreeLine(myDistMatrix=d, method=\"complete\", cutoff=0.05, showPlot=TRUE) #> ================================================================================  #>  #> Time difference of 0.12 secs #>   if (FALSE) { # example of maximum likelihood tree building tree <- TreeLine(myXStringSet=head(dna, 10), reconstruct=TRUE) plot(tree)  # displaying ancestral states on each edge start <- 50 end <- 52 tree <- dendrapply(tree,   function(x) {     attr(x, \"edgetext\") <- substring(attr(x, \"state\"),       start,       end)     x   }) plot(tree,   edgePar=list(p.lwd=1e-5,     p.col=\"#00000000\",     t.col=c(\"#AA3355\", \"#33FFFF\")),   edge.root=FALSE) }  # example of maximum parsimony tree building costs <- matrix(c(0, 2, 1, 2, 2, 0, 2, 1, 1, 2, 0, 2, 2, 1, 2, 0), 4) dimnames(costs) <- list(DNA_BASES, DNA_BASES) costs #>   A C G T #> A 0 2 1 2 #> C 2 0 2 1 #> G 1 2 0 2 #> T 2 1 2 0 tree <- TreeLine(myXStringSet=head(dna, 10), method=\"MP\", costMatrix=costs) #> PHASE 1 OF 3: INITIAL TREES #>  #> 1/3. Optimizing initial tree #1 of 10 to 100: #> score = 1604.0 (-0.062%), 1 Climb   #> 1/3. Optimizing initial tree #2 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 1/3. Optimizing initial tree #3 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 1/3. Optimizing initial tree #4 of 10 to 100: #> score = 1604.0 (0.000%), 1 Climb   #> 1/3. Optimizing initial tree #5 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 1/3. Optimizing initial tree #6 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 1/3. Optimizing initial tree #7 of 10 to 100: #> score = 1604.0 (0.000%), 2 Climbs   #> 1/3. Optimizing initial tree #8 of 10 to 100: #> score = 1604.0 (0.000%), 1 Climb   #> 1/3. Optimizing initial tree #9 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 1/3. Optimizing initial tree #10 of 10 to 100: #> score = 1604.0 (0.000%), 1 Climb   #>  #> PHASE 2 OF 3: REGROW GENERATION 1 OF 10 TO 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 2098.0 (+23.546%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 1721.0 (+6.798%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 2098.0 (+23.546%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #>  #> PHASE 2 OF 3: REGROW GENERATION 2 OF 10 TO 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 1950.0 (+17.744%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 2609.0 (+38.521%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #>  #> PHASE 2 OF 3: REGROW GENERATION 3 OF 10 TO 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 2078.0 (+22.810%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 1604.0 (0.000%), 5 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 2876.0 (+44.228%), 0 Climbs   #>  #> PHASE 2 OF 3: REGROW GENERATION 4 OF 10 TO 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 2098.0 (+23.546%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 1720.0 (+6.744%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1720.0 (+6.744%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #>  #> PHASE 2 OF 3: REGROW GENERATION 5 OF 10 TO 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 2079.0 (+22.848%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #>  #> PHASE 2 OF 3: REGROW GENERATION 6 OF 10 TO 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 2080.0 (+22.885%), 0 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #>  #> PHASE 2 OF 3: REGROW GENERATION 7 OF 10 TO 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1817.0 (+11.723%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 2731.0 (+41.267%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 1830.0 (+12.350%), 0 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #>  #> PHASE 2 OF 3: REGROW GENERATION 8 OF 10 TO 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 1720.0 (+6.744%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #>  #> PHASE 2 OF 3: REGROW GENERATION 9 OF 10 TO 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 2098.0 (+23.546%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 3076.0 (+47.854%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 2875.0 (+44.209%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 2098.0 (+23.546%), 0 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 2118.0 (+24.268%), 0 Climbs   #>  #> PHASE 2 OF 3: REGROW GENERATION 10 OF 10 TO 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1816.0 (+11.674%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 1721.0 (+6.798%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 2552.0 (+37.147%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #>  #> PHASE 2 OF 3: REGROW GENERATION 11 OF 11 TO 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 2099.0 (+23.583%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 1830.0 (+12.350%), 0 Climbs   #>  #> PHASE 2 OF 3: REGROW GENERATION 12 OF 12 TO 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 1720.0 (+6.744%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 2552.0 (+37.147%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 1894.0 (+15.312%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #>  #> PHASE 2 OF 3: REGROW GENERATION 13 OF 13 TO 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #>  #> PHASE 2 OF 3: REGROW GENERATION 14 OF 14 TO 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 1904.0 (+15.756%), 0 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #>  #> PHASE 2 OF 3: REGROW GENERATION 15 OF 15 TO 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 1816.0 (+11.674%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 1951.0 (+17.786%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #>  #> PHASE 2 OF 3: REGROW GENERATION 16 OF 16 TO 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 1817.0 (+11.723%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 2731.0 (+41.267%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 2098.0 (+23.546%), 0 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 1720.0 (+6.744%), 0 Climbs   #>  #> PHASE 2 OF 3: REGROW GENERATION 17 OF 17 TO 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #>  #> PHASE 2 OF 3: REGROW GENERATION 18 OF 18 TO 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1816.0 (+11.674%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 2045.0 (+21.565%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 2942.0 (+45.479%), 0 Climbs   #>  #> PHASE 2 OF 3: REGROW GENERATION 19 OF 19 TO 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 2079.0 (+22.848%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 2117.0 (+24.232%), 0 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 2078.0 (+22.810%), 0 Climbs   #>  #> PHASE 2 OF 3: REGROW GENERATION 20 OF 20 #>  #> 2/3. Optimizing regrown tree #1 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #2 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #3 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #4 of 10 to 100: #> score = 1817.0 (+11.723%), 0 Climbs   #> 2/3. Optimizing regrown tree #5 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #6 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #7 of 10 to 100: #> score = 1604.0 (0.000%), 0 Climbs   #> 2/3. Optimizing regrown tree #8 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #9 of 10 to 100: #> score = 1605.0 (+0.062%), 0 Climbs   #> 2/3. Optimizing regrown tree #10 of 10 to 100: #> score = 1830.0 (+12.350%), 0 Climbs   #>  #> PHASE 3 OF 3: SHAKEN TREES #>  #> Grafting 20 trees to the best tree: #> score = 1604.0 (0.000%), 0 Grafts of 2   #>  #> 3/3. Optimizing shaken tree #1 of 10 to 1000: #> score = 1604.0 (0.000%), 1 Climb   #> 3/3. Optimizing shaken tree #2 of 10 to 1000: #> score = 1604.0 (0.000%), 3 Climbs   #> 3/3. Optimizing shaken tree #3 of 10 to 1000: #> score = 1604.0 (0.000%), 3 Climbs   #> 3/3. Optimizing shaken tree #4 of 10 to 1000: #> score = 1604.0 (0.000%), 1 Climb   #> 3/3. Optimizing shaken tree #5 of 10 to 1000: #> score = 1604.0 (0.000%), 2 Climbs   #> 3/3. Optimizing shaken tree #6 of 10 to 1000: #> score = 1604.0 (0.000%), 1 Climb   #> 3/3. Optimizing shaken tree #7 of 10 to 1000: #> score = 1604.0 (0.000%), 3 Climbs   #> 3/3. Optimizing shaken tree #8 of 10 to 1000: #> score = 1604.0 (0.000%), 0 Climbs   #> 3/3. Optimizing shaken tree #9 of 10 to 1000: #> score = 1604.0 (0.000%), 1 Climb   #> 3/3. Optimizing shaken tree #10 of 10 to 1000: #> score = 1604.0 (0.000%), 0 Climbs   #>  #> Grafting 10 trees to the best tree: #> score = 1604.0 (0.000%), 0 Grafts of 0   #>  #> Time difference of 1.69 secs #>   # example of accessing and using the attributes attributes(tree) #> $members #> [1] 10 #>  #> $height #> [1] 0.4406528 #>  #> $class #> [1] \"dendrogram\" #>  #> $method #> [1] \"MP\" #>  #> $score #> [1] 1604 #>  #> $midpoint #> [1] 5.0625 #>  plot(dendrapply(tree,   function(x) {     s <- attr(x, \"support\")     if (!is.null(s))       attr(x, \"edgetext\") <- formatC(as.numeric(s), digits=2, format=\"f\")     attr(x, \"edgePar\") <- list(p.col=NA, p.lwd=1e-5, t.col=\"#CC55AA\", t.cex=0.7)     x   }),   horiz=TRUE)"},{"path":"/reference/TrimDNA.html","id":null,"dir":"Reference","previous_headings":"","what":"Trims DNA Sequences to the High Quality Region Between Patterns — TrimDNA","title":"Trims DNA Sequences to the High Quality Region Between Patterns — TrimDNA","text":"Aids trimming DNA sequences high quality region set patterns potentially present left right sides.","code":""},{"path":"/reference/TrimDNA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trims DNA Sequences to the High Quality Region Between Patterns — TrimDNA","text":"","code":"TrimDNA(   myDNAStringSet,   leftPatterns,   rightPatterns,   type = \"ranges\",   quality = NULL,   maxDistance = 0.1,   minOverlap = 5,   allowInternal = TRUE,   alpha = 0.1,   threshold = 0.01,   maxAverageError = threshold,   maxAmbiguities = 0.1,   minWidth = 36,   verbose = TRUE )"},{"path":"/reference/TrimDNA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trims DNA Sequences to the High Quality Region Between Patterns — TrimDNA","text":"myDNAStringSet DNAStringSet QualityScaledDNAStringSet object containing sequences trimmed.  \"type\" \"sequences\" output class match class myXStringSet.  Note qualities QualityScaledDNAStringSet ignored quality argument must supplied separately. leftPatterns DNAStringSet character vector patterns remove left side myDNAStringSet, \"\" prevent trimming patterns left. rightPatterns DNAStringSet character vector patterns remove right side myDNAStringSet, \"\" prevent trimming patterns right. type Character string indicating type results desired.  (abbreviation ) either \"ranges\", \"sequences\" \"\". quality Either NULL (default) skip quality trimming, PhredQuality, SolexaQuality, IlluminaQuality object containing quality scores corresponding myDNAStringSet. maxDistance Numeric zero one giving maximum distance match leftPatterns rightPatterns initiate trimming. example, 0.1 (default) allow 10\\ mismatches pattern sequence. minOverlap Integer specifying minimum number nucleotides leftPatterns rightPatterns must overlap sequence initiate trimming. allowInternal Logical initiating whether search leftPatterns rightPatterns within myDNAStringSet, (FALSE ) overlapping ends. alpha Numeric zero one giving smoothing parameter exponential moving average applied quality scores trimming.  Higher values result less smoothing lower values. threshold Numeric zero one specifying threshold trim poor quality regions sequence.  Higher values allow sequence preserved expense greater error rate. maxAverageError Numeric zero threshold indicating maximum average error rate trimmed region sequence. Trimmed sequences average error rates maxAverageError rejected.  Note expected number errors sequence equal average error rate multiplied length sequence. maxAmbiguities Numeric zero one giving maximum fraction ambiguous (e.g., \"N\") positions tolerated within trimmed region sequence.  Trimmed sequences greater fraction ambiguities maxAmbiguities rejected. minWidth Integer giving minimum number nucleotides pattern must overlap sequence initiate trimming. verbose Logical indicating whether display progress.","code":""},{"path":"/reference/TrimDNA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trims DNA Sequences to the High Quality Region Between Patterns — TrimDNA","text":"TrimDNA can return two types results: IRanges can used trimming myDNAStringSet, trimmed DNAStringSet QualityScaledDNAStringSet containing sequences minWidth nucleotides trimming.  Note ambiguity codes (IUPAC_CODE_MAP) supported leftPatterns rightPatterns, myDNAStringSet prevent trivial matches (e.g., runs N's). type \"ranges\" (default) output IRanges object start, end, width every sequence. information can accessed corresponding accessor function (see examples ).  Note start 1 end 0 sequences least minWidth nucleotides trimming. type \"sequences\" trimmed sequences returned least minWidth nucleotides length. type \"\" output list two components, first containing ranges second containing sequences.","code":""},{"path":"/reference/TrimDNA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Trims DNA Sequences to the High Quality Region Between Patterns — TrimDNA","text":"sequencing run, often necessary trim resulting sequences high quality region located set patterns. TrimDNA works follows: first left right patterns identified within sequences allowInternal TRUE (default).  patterns found internally, search conducted flanking ends patterns partially overlap sequence.  region leftPatterns rightPatterns returned, unless quality information provided.  Note patterns must orientation sequence, may require using reverseComplement PCR primer. quality contains quality scores, converted error probabilities exponential moving average applied smooth signal.  longest region leftPatterns rightPatterns average error probability threshold returned, long average error rate maxAverageError.  Note possible filter maxAverageError setting threshold 1, vise-versa setting maxAverageError value threshold.","code":""},{"path":[]},{"path":"/reference/TrimDNA.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Trims DNA Sequences to the High Quality Region Between Patterns — TrimDNA","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/TrimDNA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Trims DNA Sequences to the High Quality Region Between Patterns — TrimDNA","text":"","code":"# simple example of trimming a single sequence dna <- DNAStringSet(\"AAAAAAAAAATTACTTCCCCCCCCCC\") qscores <- PhredQuality(\"0000000000AAAAAAAAAAAAAAAA\")  x <- TrimDNA(dna,             leftPatterns=\"AAAAAA\",             rightPatterns=\"CCCCCC\",             quality=qscores,             minWidth=1,             allowInternal=TRUE,             type=\"both\") #> Finding left pattern: 100% internal, 0% flanking #>  #> Finding right pattern: 100% internal, 0% flanking #>  #> Trimming by quality score: 100% left, 0% right #>  #> Time difference of 0 secs #>   x[[1]] #> IRanges object with 1 range and 0 metadata columns: #>           start       end     width #>       <integer> <integer> <integer> #>   [1]        15        16         2 start(x[[1]]) #> [1] 15 end(x[[1]]) #> [1] 16 width(x[[1]]) #> [1] 2 subseq(dna, start(x[[1]]), end(x[[1]])) #> DNAStringSet object of length 1: #>     width seq #> [1]     2 TT x[[2]] #> DNAStringSet object of length 1: #>     width seq #> [1]     2 TT  # example of trimming a FASTQ file by quality scores fpath <- system.file(\"extdata\",   \"s_1_sequence.txt\",   package=\"Biostrings\") reads <- readQualityScaledDNAStringSet(fpath) #> Warning: metadata columns on input DNAStringSet object were dropped trimmed <- TrimDNA(reads,   leftPatterns=\"\",   rightPatterns=\"\",   type=\"sequences\",   quality=quality(reads)) #> Trimming by quality score: 0% left, 0% right #>  #> Time difference of 0.01 secs #>  trimmed #>   A QualityScaledDNAStringSet instance containing: #>  #> DNAStringSet object of length 256: #>       width seq                                             names                #>   [1]    36 GGACTTTGTAGGATACCCTCGCTTTCCTTCTCCTGT            HWI-EAS88_1_1_1_1... #>   [2]    36 GATTTCTTACCTATTAGTGGTTGAACAGCATCGGAC            HWI-EAS88_1_1_1_8... #>   [3]    36 GCGGTGGTCTATAGTGTTATTAATATCAATTTGGGT            HWI-EAS88_1_1_1_9... #>   [4]    36 GTTACCATGATGTTATTTCTTCATTTGGAGGTAAAA            HWI-EAS88_1_1_1_8... #>   [5]    36 GTATGTTTCTCCTGCTTATCACCTTCTTGAAGGCTT            HWI-EAS88_1_1_1_9... #>   ...   ... ... #> [252]    36 GTTTAGATATGAGTCACATTTTGTTCATGGTAGAGT            HWI-EAS88_1_1_1_6... #> [253]    36 GTTTTACAGACACCTAAAGCTACATCGTCAACGTTA            HWI-EAS88_1_1_1_1... #> [254]    36 GATGAACTAAGTCAACCTCAGCACTAACCTTGCGAG            HWI-EAS88_1_1_1_3... #> [255]    36 GTTTGGTTCGCTTTGAGTCTTCTTCGGTTCCGACTA            HWI-EAS88_1_1_1_8... #> [256]    36 GCAATCTGCCGACCACTCGCGATTCAATCATGACTT            HWI-EAS88_1_1_1_8... #>  #> PhredQuality object of length 256: #>       width seq #>   [1]    36 ]]]]]]]]]]]]Y]Y]]]]]]]]]]]]VCHVMPLAS #>   [2]    36 ]]]]]]]]]]]]Y]]]]]]]]]YPV]T][PZPICCK #>   [3]    36 ]]]]Y]]]]]V]T]]]]]T]]]]]V]TMJEUXEFLA #>   [4]    36 ]]]]]]]]]]]]]]]]]]]]]]T]]]]RJRZTQLOA #>   [5]    36 ]]]]]]]]]]]]]]]]]T]]]]]]]]]]MJUJVLSS #>   ...   ... ... #> [252]    36 ]]]]]]]]]]]Y]]]]]NY]]]]Y]VR]MJQNSAOC #> [253]    36 ]]]]]]]]]]]]]]]]]]]]]]]Y]]]VTVVRVMSM #> [254]    36 ]]]]Y]Y]]]]]]]OYY]]]Y]]]YYVVTSZUOOHH #> [255]    36 ]]]]]]]]]]]]]]]T]]]]]]]]]V]T[OVXEJSJ #> [256]    36 ]]]]]]]]]]]Y]]T]T]]]]TRYVMEVVRSRHHNH #>  DNAStringSet(trimmed) # drop the qualities #> DNAStringSet object of length 256: #>       width seq                                             names                #>   [1]    36 GGACTTTGTAGGATACCCTCGCTTTCCTTCTCCTGT            HWI-EAS88_1_1_1_1... #>   [2]    36 GATTTCTTACCTATTAGTGGTTGAACAGCATCGGAC            HWI-EAS88_1_1_1_8... #>   [3]    36 GCGGTGGTCTATAGTGTTATTAATATCAATTTGGGT            HWI-EAS88_1_1_1_9... #>   [4]    36 GTTACCATGATGTTATTTCTTCATTTGGAGGTAAAA            HWI-EAS88_1_1_1_8... #>   [5]    36 GTATGTTTCTCCTGCTTATCACCTTCTTGAAGGCTT            HWI-EAS88_1_1_1_9... #>   ...   ... ... #> [252]    36 GTTTAGATATGAGTCACATTTTGTTCATGGTAGAGT            HWI-EAS88_1_1_1_6... #> [253]    36 GTTTTACAGACACCTAAAGCTACATCGTCAACGTTA            HWI-EAS88_1_1_1_1... #> [254]    36 GATGAACTAAGTCAACCTCAGCACTAACCTTGCGAG            HWI-EAS88_1_1_1_3... #> [255]    36 GTTTGGTTCGCTTTGAGTCTTCTTCGGTTCCGACTA            HWI-EAS88_1_1_1_8... #> [256]    36 GCAATCTGCCGACCACTCGCGATTCAATCATGACTT            HWI-EAS88_1_1_1_8..."},{"path":"/reference/WriteDendrogram.html","id":null,"dir":"Reference","previous_headings":"","what":"Write a Dendrogram to Newick Format — WriteDendrogram","title":"Write a Dendrogram to Newick Format — WriteDendrogram","text":"Writes dendrogram object file Newick (also known New Hampshire) parenthetic format.","code":""},{"path":"/reference/WriteDendrogram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write a Dendrogram to Newick Format — WriteDendrogram","text":"","code":"WriteDendrogram(   x,   file = \"\",   quoteLabels = TRUE,   convertBlanks = !quoteLabels,   internalLabels = TRUE,   digits = 10,   append = FALSE )"},{"path":"/reference/WriteDendrogram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write a Dendrogram to Newick Format — WriteDendrogram","text":"x object class dendrogram. file connection character string naming file path tree exported.  \"\" (default), tree printed standard output connection, console unless redirected sink. quoteLabels Logical specifying whether place leaf labels double quotes. convertBlanks Logical specifying whether convert spaces leaf labels underscores. internalLabels Logical indicating whether write ``edgetext'' preceding node internal node label. digits maximum number digits print edge lengths. append Logical indicating whether append existing file.  applicable file character string.  FALSE (default), file overwritten.","code":""},{"path":"/reference/WriteDendrogram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write a Dendrogram to Newick Format — WriteDendrogram","text":"NULL.","code":""},{"path":"/reference/WriteDendrogram.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Write a Dendrogram to Newick Format — WriteDendrogram","text":"WriteDendrogram write dendrogram object file standard Newick format.  Note special characters (commas, square brackets, colons, semi-colons, parentheses) present leaf labels likely cause broken Newick file unless quoteLabels TRUE (default).","code":""},{"path":[]},{"path":"/reference/WriteDendrogram.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Write a Dendrogram to Newick Format — WriteDendrogram","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/WriteDendrogram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write a Dendrogram to Newick Format — WriteDendrogram","text":"","code":"dists <- matrix(c(0, 10, 20, 10, 0, 5, 20, 5, 0),     nrow=3,     dimnames=list(c(\"dog\", \"elephant\", \"horse\"))) dend <- TreeLine(myDistMatrix=dists, method=\"NJ\") #> ================================================================================ #>  #> Time difference of 0 secs #>  WriteDendrogram(dend) #> (\"dog\":11.25,(\"elephant\":0,\"horse\":10):1.25);"},{"path":"/reference/WriteGenes.html","id":null,"dir":"Reference","previous_headings":"","what":"Write Genes to a File — WriteGenes","title":"Write Genes to a File — WriteGenes","text":"Writes predicted genes file GenBank (gbk) general feature format (gff).","code":""},{"path":"/reference/WriteGenes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write Genes to a File — WriteGenes","text":"","code":"WriteGenes(x, file = \"\", format = \"gbk\", append = FALSE)"},{"path":"/reference/WriteGenes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write Genes to a File — WriteGenes","text":"x object class Genes. file connection character string naming file path tree exported.  \"\" (default), tree printed standard output connection, console unless redirected sink. format Character specifying \"gbk\" \"gff\" output format. append Logical indicating whether append existing file.  applicable file character string.  FALSE (default), file overwritten.","code":""},{"path":"/reference/WriteGenes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write Genes to a File — WriteGenes","text":"NULL.","code":""},{"path":"/reference/WriteGenes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Write Genes to a File — WriteGenes","text":"WriteGenes write \"Genes\" object GenBank (format \"gbk\") general feature format (format \"gff\") file.","code":""},{"path":[]},{"path":"/reference/WriteGenes.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Write Genes to a File — WriteGenes","text":"Erik Wright eswright@pitt.edu","code":""},{"path":"/reference/WriteGenes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write Genes to a File — WriteGenes","text":"","code":"# import a test genome fas <- system.file(\"extdata\",   \"Chlamydia_trachomatis_NC_000117.fas.gz\",   package=\"DECIPHER\") genome <- readDNAStringSet(fas)  x <- FindGenes(genome) #> Iter  Models Start Motif  Init  Fold UpsNt  Term   RBS  Auto  Stop Genes #> 1          1 18.40                 _                                 886 1          1 18.40                 \\                                 886 1          1 18.40                 |                                 886 1          1 18.40                 /                                 886 1          1 18.40                 _                                 886 1          1 18.40                 \\                                 886 1          1 18.40                 |                                 886 1          1 18.40                 /                                 886 1          1 18.40                 _                                 886 2         12 18.40  0.48  0.90                                       888 3         15 18.38  0.53  1.16  0.40  1.41                           891 4         15 15.59  0.52  1.27  0.47  1.75  0.24                     893 5         12 15.62  0.52  1.25  0.48  1.83  0.25  0.98  0.10  0.07   896 6         16 15.61  0.51  1.24  0.51  1.91  0.25  1.08  0.10  0.07   896 7         14 15.61  0.51  1.24  0.48  1.94  0.25  1.08  0.10  0.07   896 8         13 15.60  0.52  1.25  0.53  1.97  0.26  1.07  0.10  0.07   897 9         12 15.59  0.52  1.25  0.49  1.99  0.26  1.09  0.10  0.07   896 10        12 15.59  0.52  1.25  0.49  1.99  0.26  1.13  0.10  0.07   895 11        12 15.59  0.52  1.24  0.50  2.00  0.26  1.09  0.10  0.07   895 12        12 15.59  0.52  1.24  0.51  2.00  0.26  1.12  0.10  0.07   894 #>  #> Time difference of 29.73 secs #>  WriteGenes(x[1:10,], format=\"gbk\") #> DEFINITION  NC_000117.1 Chlamydia trachomatis D/UW-3/CX chromosome, complete genome #> FEATURES             Location/Qualifiers #>      CDS             1..1176 #>                      /note=\"ID=1_1;\" #>      CDS             complement(1321..1593) #>                      /note=\"ID=1_2;\" #>      CDS             1794..2096 #>                      /note=\"ID=1_3;\" #>      CDS             2108..3583 #>                      /note=\"ID=1_4;\" #>      CDS             3585..5051 #>                      /note=\"ID=1_5;\" #>      CDS             complement(5150..6241) #>                      /note=\"ID=1_6;\" #>      CDS             complement(6369..6938) #>                      /note=\"ID=1_7;\" #>      CDS             7251..8201 #>                      /note=\"ID=1_8;\" #>      CDS             complement(8217..9119) #>                      /note=\"ID=1_9;\" #>      CDS             9373..9804 #>                      /note=\"ID=1_10;\" WriteGenes(x[1:10,], format=\"gff\") #> ##gff-version 3 #> ##sequence-region NC_000117.1 1 1042519 #> NC_000117.1\tDECIPHER_v2.29.1\tCDS\t1\t1176\t100\t+\t0\tID=1_1 #> NC_000117.1\tDECIPHER_v2.29.1\tCDS\t1321\t1593\t100\t-\t0\tID=1_2 #> NC_000117.1\tDECIPHER_v2.29.1\tCDS\t1794\t2096\t100\t+\t0\tID=1_3 #> NC_000117.1\tDECIPHER_v2.29.1\tCDS\t2108\t3583\t100\t+\t0\tID=1_4 #> NC_000117.1\tDECIPHER_v2.29.1\tCDS\t3585\t5051\t100\t+\t0\tID=1_5 #> NC_000117.1\tDECIPHER_v2.29.1\tCDS\t5150\t6241\t100\t-\t0\tID=1_6 #> NC_000117.1\tDECIPHER_v2.29.1\tCDS\t6369\t6938\t100\t-\t0\tID=1_7 #> NC_000117.1\tDECIPHER_v2.29.1\tCDS\t7251\t8201\t100\t+\t0\tID=1_8 #> NC_000117.1\tDECIPHER_v2.29.1\tCDS\t8217\t9119\t100\t-\t0\tID=1_9 #> NC_000117.1\tDECIPHER_v2.29.1\tCDS\t9373\t9804\t100\t+\t0\tID=1_10"},{"path":"/reference/deltaGrules.html","id":null,"dir":"Reference","previous_headings":"","what":"Free Energy of Hybridization of Probe/Target Quadruplets on Microarrays — deltaGrules","title":"Free Energy of Hybridization of Probe/Target Quadruplets on Microarrays — deltaGrules","text":"8D array four adjacent base pairs probe target sequences time.  dimension five elements defining nucleotide position (\"\", \"C\", \"G\", \"T\", \"-\").  array contains standard Gibbs free energy change probe binding (dG, kcal/mol) every quadruple base pairing.","code":""},{"path":"/reference/deltaGrules.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Free Energy of Hybridization of Probe/Target Quadruplets on Microarrays — deltaGrules","text":"format : num 1:5, 1:5, 1:5, 1:5, 1:5, 1:5, 1:5, 1:5 -0.141 0 0 0 0 ...  - attr(*, \"dimnames\")=List 8 ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...","code":""},{"path":"/reference/deltaGrules.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Free Energy of Hybridization of Probe/Target Quadruplets on Microarrays — deltaGrules","text":"Data obtained using NimbleGen microarrays Linear Free Energy Model developed Yilmaz et al.","code":""},{"path":"/reference/deltaGrules.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Free Energy of Hybridization of Probe/Target Quadruplets on Microarrays — deltaGrules","text":"first four dimensions correspond four probe positions 5' 3'.  fifth eighth dimensions correspond four positions 5' 3' target sequence.","code":""},{"path":"/reference/deltaGrules.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Free Energy of Hybridization of Probe/Target Quadruplets on Microarrays — deltaGrules","text":"Yilmaz LS, Loy , Wright ES, Wagner M, Noguera DR (2012) Modeling Formamide Denaturation Probe-Target Hybrids Improved Microarray Probe Design Microbial Diagnostics. PLoS ONE 7(8): e43862. doi:10.1371/journal.pone.0043862.","code":""},{"path":"/reference/deltaGrules.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Free Energy of Hybridization of Probe/Target Quadruplets on Microarrays — deltaGrules","text":"","code":"data(deltaGrules) # dG of probe = AGCT / target = A-CT pairing deltaGrules[\"A\", \"G\", \"C\", \"T\", \"A\", \"-\", \"C\", \"T\"] #> [1] 0.65071"},{"path":"/reference/deltaGrulesRNA.html","id":null,"dir":"Reference","previous_headings":"","what":"Pseudoenergy Parameters for RNA Quadruplets — deltaGrulesRNA","title":"Pseudoenergy Parameters for RNA Quadruplets — deltaGrulesRNA","text":"8D array four adjacent base pairs RNA duplex.  dimension five elements defining nucleotide position (\"\", \"C\", \"G\", \"U\", \"-\").  array contains pseudoenergy duplex formation every quadruple base pairing.","code":""},{"path":"/reference/deltaGrulesRNA.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Pseudoenergy Parameters for RNA Quadruplets — deltaGrulesRNA","text":"format : num 1:5, 1:5, 1:5, 1:5, 1:5, 1:5, 1:5, 1:5 -0.776 -0.197 -0.197 -0.291 0 ...  - attr(*, \"dimnames\")=List 8 ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...","code":""},{"path":"/reference/deltaGrulesRNA.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Pseudoenergy Parameters for RNA Quadruplets — deltaGrulesRNA","text":"Psuedoenergy values ungapped quadruplets inferred log-odds found palindromes within hairpin regions across thousands non-coding RNA alignments.  value represents log-odds vivo folding relative chance.","code":""},{"path":"/reference/deltaGrulesRNA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pseudoenergy Parameters for RNA Quadruplets — deltaGrulesRNA","text":"first four dimensions correspond four top strand positions 5' 3'.  fifth eighth dimensions correspond four bottom strand positions 5' 3'.","code":""},{"path":"/reference/deltaGrulesRNA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pseudoenergy Parameters for RNA Quadruplets — deltaGrulesRNA","text":"","code":"data(deltaGrulesRNA) # dG of the duplex AGCU / ACCU pairing (1 mismatch) deltaGrulesRNA[\"A\", \"G\", \"C\", \"U\", \"A\", \"C\", \"C\", \"U\"] #> [1] 0.5855934"},{"path":"/reference/deltaHrules.html","id":null,"dir":"Reference","previous_headings":"","what":"Change in Enthalpy of Hybridization of DNA/DNA Quadruplets in Solution — deltaHrules","title":"Change in Enthalpy of Hybridization of DNA/DNA Quadruplets in Solution — deltaHrules","text":"8D array four adjacent base pairs DNA duplex.  dimension five elements defining nucleotide position (\"\", \"C\", \"G\", \"T\", \"-\").  array contains standard enthalpy change probe binding (dH, kcal/mol) every quadruple base pairing.","code":""},{"path":"/reference/deltaHrules.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Change in Enthalpy of Hybridization of DNA/DNA Quadruplets in Solution — deltaHrules","text":"format : num 1:5, 1:5, 1:5, 1:5, 1:5, 1:5, 1:5, 1:5 -7.97 0 0 0 0 ...  - attr(*, \"dimnames\")=List 8 ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...","code":""},{"path":"/reference/deltaHrules.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Change in Enthalpy of Hybridization of DNA/DNA Quadruplets in Solution — deltaHrules","text":"Data variety publications SantaLucia et al.","code":""},{"path":"/reference/deltaHrules.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Change in Enthalpy of Hybridization of DNA/DNA Quadruplets in Solution — deltaHrules","text":"first four dimensions correspond four top strand positions 5' 3'.  fifth eighth dimensions correspond four bottom strand positions 5' 3'.","code":""},{"path":"/reference/deltaHrules.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Change in Enthalpy of Hybridization of DNA/DNA Quadruplets in Solution — deltaHrules","text":"SantaLucia, J., Jr., & Hicks, D. (2004) Thermodynamics DNA Structural Motifs. Annual Review Biophysics Biomolecular Structure, 33(1), 415-440. doi:10.1146/annurev.biophys.32.110601.141800.","code":""},{"path":"/reference/deltaHrules.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Change in Enthalpy of Hybridization of DNA/DNA Quadruplets in Solution — deltaHrules","text":"","code":"data(deltaHrules) # dH of the duplex AGCT / A-CT pairing deltaHrules[\"A\", \"G\", \"C\", \"T\", \"A\", \"-\", \"C\", \"T\"] #> [1] -8.366159"},{"path":"/reference/deltaHrulesRNA.html","id":null,"dir":"Reference","previous_headings":"","what":"Change in Enthalpy of Hybridization of RNA/RNA Quadruplets in Solution — deltaHrulesRNA","title":"Change in Enthalpy of Hybridization of RNA/RNA Quadruplets in Solution — deltaHrulesRNA","text":"8D array four adjacent base pairs RNA duplex.  dimension five elements defining nucleotide position (\"\", \"C\", \"G\", \"U\", \"-\").  array contains standard enthalpy change probe binding (dH, kcal/mol) every quadruple base pairing.","code":""},{"path":"/reference/deltaHrulesRNA.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Change in Enthalpy of Hybridization of RNA/RNA Quadruplets in Solution — deltaHrulesRNA","text":"format : num 1:5, 1:5, 1:5, 1:5, 1:5, 1:5, 1:5, 1:5 -6.55 0 0 0 0 ...  - attr(*, \"dimnames\")=List 8 ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...","code":""},{"path":"/reference/deltaHrulesRNA.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Change in Enthalpy of Hybridization of RNA/RNA Quadruplets in Solution — deltaHrulesRNA","text":"Data variety publications SantaLucia et al.","code":""},{"path":"/reference/deltaHrulesRNA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Change in Enthalpy of Hybridization of RNA/RNA Quadruplets in Solution — deltaHrulesRNA","text":"first four dimensions correspond four top strand positions 5' 3'.  fifth eighth dimensions correspond four bottom strand positions 5' 3'.","code":""},{"path":"/reference/deltaHrulesRNA.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Change in Enthalpy of Hybridization of RNA/RNA Quadruplets in Solution — deltaHrulesRNA","text":"SantaLucia, J., Jr., & Hicks, D. (2004) Thermodynamics DNA Structural Motifs. Annual Review Biophysics Biomolecular Structure, 33(1), 415-440. doi:10.1146/annurev.biophys.32.110601.141800.","code":""},{"path":"/reference/deltaHrulesRNA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Change in Enthalpy of Hybridization of RNA/RNA Quadruplets in Solution — deltaHrulesRNA","text":"","code":"data(deltaHrulesRNA) # dH of the duplex AGCU / A-CU pairing deltaHrulesRNA[\"A\", \"G\", \"C\", \"U\", \"A\", \"-\", \"C\", \"U\"] #> [1] -10.13403"},{"path":"/reference/deltaSrules.html","id":null,"dir":"Reference","previous_headings":"","what":"Change in Entropy of Hybridization of DNA/DNA Quadruplets in Solution — deltaSrules","title":"Change in Entropy of Hybridization of DNA/DNA Quadruplets in Solution — deltaSrules","text":"8D array four adjacent base pairs DNA duplex.  dimension five elements defining nucleotide position (\"\", \"C\", \"G\", \"T\", \"-\").  array contains standard entropy change probe binding (dS, kcal/mol) every quadruple base pairing.","code":""},{"path":"/reference/deltaSrules.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Change in Entropy of Hybridization of DNA/DNA Quadruplets in Solution — deltaSrules","text":"format : num 1:5, 1:5, 1:5, 1:5, 1:5, 1:5, 1:5, 1:5 -0.0226 0 0 0 0 ...  - attr(*, \"dimnames\")=List 8 ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"T\" ...","code":""},{"path":"/reference/deltaSrules.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Change in Entropy of Hybridization of DNA/DNA Quadruplets in Solution — deltaSrules","text":"Data variety publications SantaLucia et al.","code":""},{"path":"/reference/deltaSrules.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Change in Entropy of Hybridization of DNA/DNA Quadruplets in Solution — deltaSrules","text":"first four dimensions correspond four top strand positions 5' 3'.  fifth eighth dimensions correspond four bottom strand positions 5' 3'.","code":""},{"path":"/reference/deltaSrules.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Change in Entropy of Hybridization of DNA/DNA Quadruplets in Solution — deltaSrules","text":"SantaLucia, J., Jr., & Hicks, D. (2004) Thermodynamics DNA Structural Motifs. Annual Review Biophysics Biomolecular Structure, 33(1), 415-440. doi:10.1146/annurev.biophys.32.110601.141800.","code":""},{"path":"/reference/deltaSrules.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Change in Entropy of Hybridization of DNA/DNA Quadruplets in Solution — deltaSrules","text":"","code":"data(deltaSrules) # dS of the duplex AGCT / A-CT pairing deltaSrules[\"A\", \"G\", \"C\", \"T\", \"A\", \"-\", \"C\", \"T\"] #> [1] -0.03526087"},{"path":"/reference/deltaSrulesRNA.html","id":null,"dir":"Reference","previous_headings":"","what":"Change in Entropy of Hybridization of RNA/RNA Quadruplets in Solution — deltaSrulesRNA","title":"Change in Entropy of Hybridization of RNA/RNA Quadruplets in Solution — deltaSrulesRNA","text":"8D array four adjacent base pairs RNA duplex.  dimension five elements defining nucleotide position (\"\", \"C\", \"G\", \"T\", \"-\").  array contains standard entropy change probe binding (dS, kcal/mol) every quadruple base pairing.","code":""},{"path":"/reference/deltaSrulesRNA.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Change in Entropy of Hybridization of RNA/RNA Quadruplets in Solution — deltaSrulesRNA","text":"format : num 1:5, 1:5, 1:5, 1:5, 1:5, 1:5, 1:5, 1:5 -0.0182 0 0 0 0 ...  - attr(*, \"dimnames\")=List 8 ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...  ..$ : chr 1:5 \"\" \"C\" \"G\" \"U\" ...","code":""},{"path":"/reference/deltaSrulesRNA.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Change in Entropy of Hybridization of RNA/RNA Quadruplets in Solution — deltaSrulesRNA","text":"Data variety publications SantaLucia et al.","code":""},{"path":"/reference/deltaSrulesRNA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Change in Entropy of Hybridization of RNA/RNA Quadruplets in Solution — deltaSrulesRNA","text":"first four dimensions correspond four top strand positions 5' 3'.  fifth eighth dimensions correspond four bottom strand positions 5' 3'.","code":""},{"path":"/reference/deltaSrulesRNA.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Change in Entropy of Hybridization of RNA/RNA Quadruplets in Solution — deltaSrulesRNA","text":"SantaLucia, J., Jr., & Hicks, D. (2004) Thermodynamics DNA Structural Motifs. Annual Review Biophysics Biomolecular Structure, 33(1), 415-440. doi:10.1146/annurev.biophys.32.110601.141800.","code":""},{"path":"/reference/deltaSrulesRNA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Change in Entropy of Hybridization of RNA/RNA Quadruplets in Solution — deltaSrulesRNA","text":"","code":"data(deltaSrulesRNA) # dS of the duplex AGCU / A-CU pairing deltaSrulesRNA[\"A\", \"G\", \"C\", \"U\", \"A\", \"-\", \"C\", \"U\"] #> [1] -0.03847826"}]
